<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
  <h1><a href="book.htm">開放電腦計畫 -- 計算機硬體結構</a><BR/><sub>(使用 Verilog 實作)</sub></h1>
  <table id="bar" border="0" style="border:0;"><tr style="border:0;">
    <td style="text-align:left;border:0;"> <a href="book.html">目錄</a> | <a href="download.html">下載</a> | <a href="course.html">課程</a> | <a href="forum.html">討論</a> | <a href="exam.html">測驗</a></td>
    <td style="text-align:right;border:0;"><a href="http://ccckmit.wikidot.com/">陳鍾誠</a> 於 <a href="http://www.nqu.edu.tw/">金門大學</a></td>
  </tr></table>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#記憶單元-memory-unit">記憶單元 (Memory Unit)</a><ul>
<li><a href="#時序邏輯-sequential-logic">時序邏輯 (Sequential Logic)</a></li>
<li><a href="#正反器-閂鎖器">正反器 (閂鎖器)</a></li>
<li><a href="#sr-正反器">SR 正反器</a></li>
<li><a href="#有-enable-的正反器">有 enable 的正反器</a></li>
<li><a href="#閘級延遲-gate-delay">閘級延遲 (Gate Delay)</a></li>
<li><a href="#利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd">利用「閘級延遲」製作脈波變化偵測器 (Pulse Transition Detector, PTD)</a></li>
<li><a href="#使用脈衝偵測電路製作邊緣觸發正反器">使用「脈衝偵測電路」製作「邊緣觸發正反器」</a></li>
<li><a href="#使用脈衝偵測電路設計邊緣觸發暫存器">使用「脈衝偵測電路」設計邊緣觸發暫存器</a></li>
<li><a href="#使用脈衝偵測電路製作計數電路">使用「脈衝偵測電路」製作計數電路</a></li>
<li><a href="#暫存器單元">暫存器單元</a></li>
<li><a href="#記憶體">記憶體</a></li>
<li><a href="#結語">結語</a></li>
</ul></li>
</ul>
</div>
<h1 id="記憶單元-memory-unit"><a href="#記憶單元-memory-unit">記憶單元 (Memory Unit)</a></h1>
<h2 id="時序邏輯-sequential-logic"><a href="#時序邏輯-sequential-logic">時序邏輯 (Sequential Logic)</a></h2>
<p>組合邏輯 (Combinatorial Logic) 是一種沒有回饋線路的數位電路系統，而循序邏輯 (時序邏輯, Sequential Logic) 則是一種包含回饋線路的系統。</p>
<p>舉例而言，在下圖 (a) 的全加器的電路裏，您可以看到從輸入線路一路輸入接向輸出，這種稱為組合邏輯電路。而在下圖 (b) 的 栓鎖器 (正反器) 線路裏，線路從輸出 Q 又拉回 S 做為輸入，這種有倒勾的線路就稱為循序邏輯電路。</p>
<div class="figure">
<img src="../img/CombSeqCircuitCompare.jpg" />
</div>
<p>暫存器、靜態記憶體等記憶單元，都是由這種有反饋電路的時序邏輯所構成的，因此要瞭解記憶單元之前，先瞭解時序邏輯的 電路結構會是有幫助的。</p>
<h2 id="正反器-閂鎖器"><a href="#正反器-閂鎖器">正反器 (閂鎖器)</a></h2>
<p>正反器有很多種型式，以下是來自維基百科的一些正反器說明與範例。</p>
<ul>
<li>參考：<a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics)">http://en.wikipedia.org/wiki/Flip-flop_(electronics)</a></li>
</ul>
<blockquote>
<p>摘自維基百科：正反器（英語：Flip-flop, FF，中國大陸譯作觸發器，港澳譯作），學名雙穩態多諧振盪器（Bistable Multivibrator）， 是一種應用在數位電路上具有記憶功能的循序邏輯元件，可記錄二進位制數位訊號「1」和「0」。 正反器是構成序向邏輯電路以及各種複雜數位系統的基本邏輯單元。</p>
</blockquote>
<div class="figure">
<img src="../img/flop_flop.png" alt="圖、各種正反器" /><p class="caption">圖、各種正反器</p>
</div>
<h2 id="sr-正反器"><a href="#sr-正反器">SR 正反器</a></h2>
<p>正反器是可以用來儲存位元，是循序電路的基礎，以下是一個用 NAND 閘構成的正反器。</p>
<div class="figure">
<img src="../img/nandLatch.png" alt="圖、NAND 閘構成的正反器" /><p class="caption">圖、NAND 閘構成的正反器</p>
</div>
<p>我們可以根據上圖實作出對應的 Verilog 程式如下：</p>
<p>檔案：latch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> Sbar, Rbar;
<span class="dt">wire</span> Q, Qbar;

latch latch1(Sbar, Rbar, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: Sbar=%d Rbar=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, Sbar, Rbar, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;latch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  Sbar = <span class="dv">0</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">0</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\verilog&gt;iverilog -o latch latch.v

D:\verilog&gt;vvp latch
VCD info: dumpfile latch.vcd opened for output.
   0ns monitor: Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 100ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 150ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 250ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 300ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 350ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 450ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 500ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/latchWave.jpg" alt="圖、latch.vcd 的顯示圖形" /><p class="caption">圖、latch.vcd 的顯示圖形</p>
</div>
<h2 id="有-enable-的正反器"><a href="#有-enable-的正反器">有 enable 的正反器</a></h2>
<p>如果我們在上述正反器前面再加上兩個 NAND 閘進行控制，就可以形成一組有 enable 的正反器，以下是該正反器的圖形。</p>
<div class="figure">
<img src="../img/enLatch.jpg" alt="圖、有 enable 的正反器" /><p class="caption">圖、有 enable 的正反器</p>
</div>
<p>根據上述圖形我們可以設計出以下的 Verilog 程式。</p>
<p>檔案：enLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, en, R;
<span class="dt">wire</span> Q, Qbar;

enLatch enLatch1(en, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: en=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, en, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;enLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  en = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>
  en = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o enLatch enLatch.v

D:\verilog&gt;vvp enLatch
VCD info: dumpfile enLatch.vcd opened for output.
   0ns monitor: en=x Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: en=1 Sbar=x Rbar=x Q=x Qbar=x
 100ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 150ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 200ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 250ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 300ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 350ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 400ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 450ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 500ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 550ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 600ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 650ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 700ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 750ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 800ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 850ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 900ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 950ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
1000ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1</code></pre>
<div class="figure">
<img src="../img/enLatchWave.jpg" alt="圖、enLatch.vcd 的顯示圖形" /><p class="caption">圖、enLatch.vcd 的顯示圖形</p>
</div>
<h2 id="閘級延遲-gate-delay"><a href="#閘級延遲-gate-delay">閘級延遲 (Gate Delay)</a></h2>
<p>在 Verilog 模型下，邏輯閘預設是沒有任何延遲的，因此呈現出來永遠是即時的結果，但現實世界的電路 總是有少許延遲的，每經過一個閘就會延遲一點點的時間，經過的閘數越多，延遲也就會越久。</p>
<ul>
<li>參考： <a href="http://www.asic-world.com/verilog/gate3.html">http://www.asic-world.com/verilog/gate3.html</a></li>
</ul>
<p>為了模擬這種延遲，Verilog 允許你在閘上面附加延遲時間的語法，您可以分別指定最小延遲 min，典型延遲 typical 與最大延遲 max。</p>
<p>舉例而言，以下的語法宣告了一個 not 閘，其中的 <code>#(1:3:5)</code> 語法指定了最小延遲 min=1, 典型延遲 typical=3, 最大延遲 max=5。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="dt">not</span> #(<span class="dv">1</span>:<span class="dv">3</span>:<span class="dv">5</span>) n2(nclk2, clk);</code></pre>
<p>假如您不想分別指定這三種延遲，也可以只指定一個延遲參數，這樣 min, typical, max 三者都會設定為該數值， 舉例而言，以下是一個宣告延遲固定為 2 的 not 閘。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="dt">not</span> <span class="bn">#2</span> n1(nclk1, clk);</code></pre>
<p>為了說明這種延遲狀況，我們寫了一個範例程式 delay.v 來示範設定了閘級延遲的效果，請參考下列程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> main;
 <span class="dt">reg</span> clk;

 <span class="dt">not</span> <span class="bn">#2</span> n1(nclk1, clk);
 <span class="dt">not</span> #(<span class="dv">1</span>:<span class="dv">3</span>:<span class="dv">5</span>) n2(nclk2, clk);

 <span class="kw">initial</span> <span class="kw">begin</span>
   clk = <span class="dv">0</span>;
   <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: clk=%b nclk1=%d nclk2=%d&quot;</span>, <span class="dt">$stime</span>, clk, nclk1, nclk2);
   <span class="dt">$dumpfile</span>(<span class="st">&quot;delay.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
   <span class="dt">$dumpvars</span>;
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
   clk = clk + <span class="dv">1</span>;
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o delay delay.v
delay.v:5: warning: choosing typ expression.

D:\Dropbox\Public\web\oc\code&gt;vvp delay
VCD info: dumpfile delay.vcd opened for output.
         0ns monitor: clk=0 nclk1=z nclk2=z
         2ns monitor: clk=0 nclk1=1 nclk2=z
         3ns monitor: clk=0 nclk1=1 nclk2=1
        10ns monitor: clk=1 nclk1=1 nclk2=1
        12ns monitor: clk=1 nclk1=0 nclk2=1
        13ns monitor: clk=1 nclk1=0 nclk2=0
        20ns monitor: clk=0 nclk1=0 nclk2=0
        22ns monitor: clk=0 nclk1=1 nclk2=0
        23ns monitor: clk=0 nclk1=1 nclk2=1
        30ns monitor: clk=1 nclk1=1 nclk2=1
        32ns monitor: clk=1 nclk1=0 nclk2=1
        33ns monitor: clk=1 nclk1=0 nclk2=0
        40ns monitor: clk=0 nclk1=0 nclk2=0
        42ns monitor: clk=0 nclk1=1 nclk2=0
        43ns monitor: clk=0 nclk1=1 nclk2=1
        50ns monitor: clk=1 nclk1=1 nclk2=1
        52ns monitor: clk=1 nclk1=0 nclk2=1
        53ns monitor: clk=1 nclk1=0 nclk2=0
        60ns monitor: clk=0 nclk1=0 nclk2=0
        62ns monitor: clk=0 nclk1=1 nclk2=0
        63ns monitor: clk=0 nclk1=1 nclk2=1
        70ns monitor: clk=1 nclk1=1 nclk2=1
        72ns monitor: clk=1 nclk1=0 nclk2=1
        73ns monitor: clk=1 nclk1=0 nclk2=0
        80ns monitor: clk=0 nclk1=0 nclk2=0
        82ns monitor: clk=0 nclk1=1 nclk2=0
        83ns monitor: clk=0 nclk1=1 nclk2=1
        90ns monitor: clk=1 nclk1=1 nclk2=1
        92ns monitor: clk=1 nclk1=0 nclk2=1
        93ns monitor: clk=1 nclk1=0 nclk2=0
       100ns monitor: clk=0 nclk1=0 nclk2=0</code></pre>
<p>以上輸出的波形如下，您可以看到 nclk1 的延遲固定為 2 ，而 nclk2 的延遲則介於 1 到 5 之間。</p>
<div class="figure">
<img src="../img/delayGTKwave.jpg" alt="圖、delay.vcd 的顯示波型" /><p class="caption">圖、delay.vcd 的顯示波型</p>
</div>
<h2 id="利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd"><a href="#利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd">利用「閘級延遲」製作脈波變化偵測器 (Pulse Transition Detector, PTD)</a></h2>
<p>雖然延遲現象看起來像是個缺陷，但事實上如果好好的利用這種現象，有時反而可以達到很好的效果， 「脈波變化偵測器」電路就是利用這種現象所設計的一種電路，可以用來偵測「脈波的上升邊緣或下降邊緣」。</p>
<p>以下是「脈波變化偵測電路」的圖形，其中的關鍵是在 左邊的 not 閘身上，由於每個閘都會造成延遲，因此多了 not 閘的那條路徑所造成的延遲較多，這讓輸出部份會因為延遲而形成一個脈衝波形。</p>
<div class="figure">
<img src="../img/ptd.jpg" alt="圖、脈波變化偵測器" /><p class="caption">圖、脈波變化偵測器</p>
</div>
<p>以下是這個電路以 Verilog 實作的結果。</p>
<p>檔案：ptd.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span> <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span> <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
 <span class="dt">reg</span> clk;
 <span class="dt">wire</span> p;

 ptd ptd1(clk, p);

 <span class="kw">initial</span> <span class="kw">begin</span>
   clk = <span class="dv">0</span>;
   <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: clk=%b p=%d&quot;</span>, <span class="dt">$stime</span>, clk, p);
   <span class="dt">$dumpfile</span>(<span class="st">&quot;ptd.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
   <span class="dt">$dumpvars</span>;
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
   clk = clk + <span class="dv">1</span>;
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\pmag\201311\code&gt;iverilog -o ptd ptd.v

D:\Dropbox\Public\pmag\201311\code&gt;vvp ptd
VCD info: dumpfile ptd.vcd opened for output.
         0ns monitor: clk=0 p=z
         4ns monitor: clk=0 p=0
        50ns monitor: clk=1 p=0
        54ns monitor: clk=1 p=1
        56ns monitor: clk=1 p=0
       100ns monitor: clk=0 p=0
       150ns monitor: clk=1 p=0
       154ns monitor: clk=1 p=1
       156ns monitor: clk=1 p=0
       200ns monitor: clk=0 p=0
       250ns monitor: clk=1 p=0
       254ns monitor: clk=1 p=1
       256ns monitor: clk=1 p=0
       300ns monitor: clk=0 p=0
       350ns monitor: clk=1 p=0
       354ns monitor: clk=1 p=1
       356ns monitor: clk=1 p=0
       400ns monitor: clk=0 p=0
       450ns monitor: clk=1 p=0
       454ns monitor: clk=1 p=1
       456ns monitor: clk=1 p=0
       500ns monitor: clk=0 p=0</code></pre>
<div class="figure">
<img src="../img/ptdWave.jpg" alt="圖、ptd.vcd 的顯示圖形" /><p class="caption">圖、ptd.vcd 的顯示圖形</p>
</div>
<h2 id="使用脈衝偵測電路製作邊緣觸發正反器"><a href="#使用脈衝偵測電路製作邊緣觸發正反器">使用「脈衝偵測電路」製作「邊緣觸發正反器」</a></h2>
<p>有了「正反器」與「脈波變化偵測電路」之後，我們就可以組合出「邊緣觸發正反器」了，以下是其電路圖。</p>
<div class="figure">
<img src="../img/ptdLatch.jpg" alt="圖、邊緣觸發的正反器" /><p class="caption">圖、邊緣觸發的正反器</p>
</div>
<p>事實上，上述電路圖只是將「有 enable 的正反器」前面加上一個「脈波變化偵測電路」而已，其實做的 Verilog 程式如下。</p>
<p>檔案：ptdLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span>  <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span>  <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptdLatch(<span class="dt">input</span> clk, S, R, <span class="dt">output</span> Q, Qbar);
  ptd PTD(clk, ppulse);
  enLatch EL(ppulse, S, R, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, clk, R;
<span class="dt">wire</span> Q, Qbar;

ptdLatch ptdLatch1(clk, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d ppulse=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, clk, ptdLatch1.ppulse, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;ptdLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span>
  clk = ~clk;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o ptdLatch ptdLatch.v

D:\verilog&gt;vvp ptdLatch
VCD info: dumpfile ptdLatch.vcd opened for output.
   0ns monitor: clk=0 ppulse=z S=x R=x Q=x Qbar=x
   4ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  20ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  24ns monitor: clk=1 ppulse=1 S=x R=x Q=x Qbar=x
  26ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  40ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  50ns monitor: clk=0 ppulse=0 S=1 R=0 Q=x Qbar=x
  60ns monitor: clk=1 ppulse=0 S=1 R=0 Q=x Qbar=x
  64ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
  66ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
  80ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 100ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 104ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 106ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 120ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 140ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 144ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 146ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 150ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 160ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 180ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 184ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 186ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 200ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 220ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 224ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 226ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 240ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 250ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 260ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 264ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 266ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 280ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 300ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 304ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 306ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 320ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 340ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 344ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 346ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 350ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 360ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 380ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 384ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 386ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 400ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 420ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 424ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 426ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 440ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 450ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 460ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 464ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 466ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 480ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 500ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/ptdLatchWave.jpg" alt="圖、ptdLatch.vcd 的顯示圖形" /><p class="caption">圖、ptdLatch.vcd 的顯示圖形</p>
</div>
<h2 id="使用脈衝偵測電路設計邊緣觸發暫存器"><a href="#使用脈衝偵測電路設計邊緣觸發暫存器">使用「脈衝偵測電路」設計邊緣觸發暫存器</a></h2>
<p>有了「脈波變化偵測電路」，只要與任何需要偵測脈波變化的元件串接起來，就可以達到「邊緣觸發」的功能。</p>
<p>其實、像是 Verilog 當中的以下程式，其實都是利用類似的「脈波變化偵測電路」所完成的。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>
  ...
  <span class="kw">end</span></code></pre>
<p>如果我們真的不想使用 <code>posedge clock</code> 這種語法，我們也可以用前述的 「脈波變化偵測電路」(PTD) 來 製作這類的邊緣觸發功能，以下是我們用這種方式設計的一個邊緣觸發暫存器。</p>
<p>檔案： ptdRegister.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);

<span class="dt">not</span> <span class="bn">#2</span> g1(nclkd, clk);
<span class="dt">nand</span> <span class="bn">#2</span> g2(npulse, nclkd, clk);
<span class="dt">not</span> <span class="bn">#2</span> g3(ppulse, npulse);

<span class="kw">endmodule</span>

<span class="kw">module</span> register(<span class="dt">input</span> en, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] d, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r);
<span class="kw">always</span> @(en) <span class="kw">begin</span>
  <span class="kw">if</span> (en)
    r &lt;= d;
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] d;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] r;
<span class="dt">reg</span> clk;
<span class="dt">wire</span> en;

ptd ptd1(clk, en);
register register1(en, d, r);

<span class="kw">initial</span> <span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  d = <span class="dv">3</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d d=%d r=%d&quot;</span>, <span class="dt">$stime</span>, clk, en, d, r);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span>
  d = d + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o ptdRegister ptdRegister.v

D:\Dropbox\Public\web\oc\code&gt;vvp ptdRegister
   0ns monitor: clk=0 en=z d=         3 r=         x
   4ns monitor: clk=0 en=0 d=         3 r=         x
  10ns monitor: clk=1 en=0 d=         3 r=         x
  14ns monitor: clk=1 en=1 d=         3 r=         3
  16ns monitor: clk=1 en=0 d=         3 r=         3
  20ns monitor: clk=0 en=0 d=         4 r=         3
  30ns monitor: clk=1 en=0 d=         4 r=         3
  34ns monitor: clk=1 en=1 d=         4 r=         4
  36ns monitor: clk=1 en=0 d=         4 r=         4
  40ns monitor: clk=0 en=0 d=         5 r=         4
  50ns monitor: clk=1 en=0 d=         5 r=         4
  54ns monitor: clk=1 en=1 d=         5 r=         5
  56ns monitor: clk=1 en=0 d=         5 r=         5
  60ns monitor: clk=0 en=0 d=         6 r=         5
  70ns monitor: clk=1 en=0 d=         6 r=         5
  74ns monitor: clk=1 en=1 d=         6 r=         6
  76ns monitor: clk=1 en=0 d=         6 r=         6
  80ns monitor: clk=0 en=0 d=         7 r=         6
  90ns monitor: clk=1 en=0 d=         7 r=         6
  94ns monitor: clk=1 en=1 d=         7 r=         7
  96ns monitor: clk=1 en=0 d=         7 r=         7
 100ns monitor: clk=0 en=0 d=         8 r=         7</code></pre>
<p>其輸出的波型檔如下圖所示：</p>
<div class="figure">
<img src="../img/GTKWavePtdRegister.jpg" alt="圖、在 GTKWave 中顯示的 ptdRegister.vcd 波型檔" /><p class="caption">圖、在 GTKWave 中顯示的 ptdRegister.vcd 波型檔</p>
</div>
<h2 id="使用脈衝偵測電路製作計數電路"><a href="#使用脈衝偵測電路製作計數電路">使用「脈衝偵測電路」製作計數電路</a></h2>
<p>如果我們將暫存器的輸出在接到一個加法電路上，進行回饋性的累加的動作，如下圖所示，那麼整個電路就會變成 一個邊緣觸發的計數電路</p>
<div class="figure">
<img src="../img/ptdCounterCircuit.jpg" alt="圖、邊緣觸發的計數電路" /><p class="caption">圖、邊緣觸發的計數電路</p>
</div>
<p>以上這種電路可以做為「採用區塊方法設計 CPU 的基礎」，因為 CPU 當中的「程式計數器」 (Program Counter) 通常會採用 這種邊緣觸發的設計方式。</p>
<p>以下是上述電路的設計與實作測試結果。</p>
<p>檔案： ptdCounter.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> register(<span class="dt">input</span> en, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] d, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r);
<span class="kw">always</span> @(en) <span class="kw">begin</span>
  <span class="kw">if</span> (en)
    r &lt;= d;
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span>  <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span>  <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> inc(<span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] i, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] o);
  <span class="kw">assign</span> o = i + <span class="dv">4</span>;
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] r, ro;
<span class="dt">reg</span> clk;
<span class="dt">wire</span> en;

ptd ptd1(clk, en);
register r1(en, ro, r);
inc i1(r, ro);

<span class="kw">initial</span> <span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  r1.r = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d r=%d&quot;</span>, <span class="dt">$stime</span>, clk, en, r);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;ptdCounter.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o ptdCounter ptdCounter.v

D:\Dropbox\Public\web\oc\code&gt;vvp ptdCounter
VCD info: dumpfile ptdCounter.vcd opened for output.
   0ns monitor: clk=0 en=z r=         0
   4ns monitor: clk=0 en=0 r=         0
  10ns monitor: clk=1 en=0 r=         0
  14ns monitor: clk=1 en=1 r=         4
  16ns monitor: clk=1 en=0 r=         4
  20ns monitor: clk=0 en=0 r=         4
  30ns monitor: clk=1 en=0 r=         4
  34ns monitor: clk=1 en=1 r=         8
  36ns monitor: clk=1 en=0 r=         8
  40ns monitor: clk=0 en=0 r=         8
  50ns monitor: clk=1 en=0 r=         8
  54ns monitor: clk=1 en=1 r=        12
  56ns monitor: clk=1 en=0 r=        12
  60ns monitor: clk=0 en=0 r=        12
  70ns monitor: clk=1 en=0 r=        12
  74ns monitor: clk=1 en=1 r=        16
  76ns monitor: clk=1 en=0 r=        16
  80ns monitor: clk=0 en=0 r=        16
  90ns monitor: clk=1 en=0 r=        16
  94ns monitor: clk=1 en=1 r=        20
  96ns monitor: clk=1 en=0 r=        20
 100ns monitor: clk=0 en=0 r=        20</code></pre>
<p>其輸出的波型檔如下圖所示：</p>
<div class="figure">
<img src="../img/GTKWavePtdCounter.jpg" alt="圖、在 GTKWave 中顯示的 ptdCounter.vcd 波型檔" /><p class="caption">圖、在 GTKWave 中顯示的 ptdCounter.vcd 波型檔</p>
</div>
<h2 id="暫存器單元"><a href="#暫存器單元">暫存器單元</a></h2>
<p>檔案：regbank.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> regbank(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra1, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd1, 
               <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra2, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd2,
               <span class="dt">input</span> clk, <span class="dt">input</span> w_en, 
               <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] wa, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] wd);
 <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r[<span class="dv">15</span>:<span class="dv">0</span>]; <span class="co">// 宣告 16 個 32 位元的暫存器</span>
 <span class="kw">assign</span> rd1 = r[ra1]; <span class="co">// 讀取索引值為 ra1 的暫存器</span>
 <span class="kw">assign</span> rd2 = r[ra2]; <span class="co">// 讀取索引值為 ra2 的暫存器</span>
 <span class="kw">always</span> @(<span class="kw">posedge</span> clk)
 <span class="kw">begin</span>
  <span class="kw">if</span> (w_en) <span class="co">// w_en=1 時寫入到暫存器</span>
    r[wa] &lt;= wd; <span class="co">// 將 wd 寫入到索引值為 wa 的暫存器</span>
 <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra1, ra2, wa;
<span class="dt">reg</span> clk, w_en;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd1, rd2;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] wd;

regbank rb0(ra1, rd1, ra2, rd2, clk, w_en, wa, wd);

<span class="kw">initial</span>
<span class="kw">begin</span>
  wa = <span class="dv">0</span>;
  ra1 = <span class="dv">0</span>;
  ra2 = <span class="dv">0</span>;
  wd = <span class="dv">0</span>;
  clk = <span class="dv">0</span>;
  w_en = <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#200</span> ra1 = <span class="dv">0</span>;

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: ra1=%d rd1=%d ra2=%d rd2=%d wa=%d wd=%d&quot;</span>, 
           <span class="dt">$stime</span>, ra1, rd1, ra2, rd2, wa, wd);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#100</span> <span class="kw">begin</span>
  wa = wa + <span class="dv">1</span>;
  wd = wd + <span class="dv">2</span>;
  ra1 = ra1 + <span class="dv">1</span>;
  ra2 = ra2 - <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code\verilog&gt;iverilog -o regbank regbank.v

D:\Dropbox\Public\web\oc\code\verilog&gt;vvp regbank
  50ns monitor: ra1= 0 rd1=         0 ra2= 0 rd2=         0 wa= 0 wd=         0
 100ns monitor: ra1= 1 rd1=         x ra2=15 rd2=         x wa= 1 wd=         2
 150ns monitor: ra1= 1 rd1=         2 ra2=15 rd2=         x wa= 1 wd=         2
 200ns monitor: ra1= 1 rd1=         2 ra2=14 rd2=         x wa= 2 wd=         4
 250ns monitor: ra1= 1 rd1=         2 ra2=14 rd2=         x wa= 2 wd=         4
 300ns monitor: ra1= 2 rd1=         4 ra2=13 rd2=         x wa= 3 wd=         6
 350ns monitor: ra1= 2 rd1=         4 ra2=13 rd2=         x wa= 3 wd=         6
 400ns monitor: ra1= 3 rd1=         6 ra2=12 rd2=         x wa= 4 wd=         8
 450ns monitor: ra1= 3 rd1=         6 ra2=12 rd2=         x wa= 4 wd=         8
 500ns monitor: ra1= 4 rd1=         8 ra2=11 rd2=         x wa= 5 wd=        10
 550ns monitor: ra1= 4 rd1=         8 ra2=11 rd2=         x wa= 5 wd=        10
 600ns monitor: ra1= 5 rd1=        10 ra2=10 rd2=         x wa= 6 wd=        12
 650ns monitor: ra1= 5 rd1=        10 ra2=10 rd2=         x wa= 6 wd=        12
 700ns monitor: ra1= 6 rd1=        12 ra2= 9 rd2=         x wa= 7 wd=        14
 750ns monitor: ra1= 6 rd1=        12 ra2= 9 rd2=         x wa= 7 wd=        14
 800ns monitor: ra1= 7 rd1=        14 ra2= 8 rd2=         x wa= 8 wd=        16
 850ns monitor: ra1= 7 rd1=        14 ra2= 8 rd2=        16 wa= 8 wd=        16
 900ns monitor: ra1= 8 rd1=        16 ra2= 7 rd2=        14 wa= 9 wd=        18
 950ns monitor: ra1= 8 rd1=        16 ra2= 7 rd2=        14 wa= 9 wd=        18
1000ns monitor: ra1= 9 rd1=        18 ra2= 6 rd2=        12 wa=10 wd=        20</code></pre>
<h2 id="記憶體"><a href="#記憶體">記憶體</a></h2>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> memory(<span class="dt">input</span> clock, reset, en, rw, 
                <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] abus, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] dbus_in, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] dbus_out);
    <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">128</span>];
    <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] data;

    <span class="kw">always</span> @(clock <span class="dt">or</span> reset <span class="dt">or</span> abus <span class="dt">or</span> en <span class="dt">or</span> rw <span class="dt">or</span> dbus_in) 
    <span class="kw">begin</span>
        <span class="kw">if</span> (reset == <span class="dv">1</span>) <span class="kw">begin</span>
            {m[<span class="dv">0</span>],m[<span class="dv">1</span>],m[<span class="dv">2</span>],m[<span class="dv">3</span>]}     = <span class="bn">32&#39;h002F000C</span>; <span class="co">// 0000           LD   R2, K0</span>
            {m[<span class="dv">4</span>],m[<span class="dv">5</span>],m[<span class="dv">6</span>],m[<span class="dv">7</span>]}     = <span class="bn">32&#39;h001F000C</span>; <span class="co">// 0004           LD   R1, K1</span>
            {m[<span class="dv">8</span>],m[<span class="dv">9</span>],m[<span class="dv">10</span>],m[<span class="dv">11</span>]}   = <span class="bn">32&#39;h13221000</span>; <span class="co">// 0008 LOOP:     ADD  R2, R2, R1</span>
            {m[<span class="dv">12</span>],m[<span class="dv">13</span>],m[<span class="dv">14</span>],m[<span class="dv">15</span>]} = <span class="bn">32&#39;h26FFFFF8</span>; <span class="co">// 000C           JMP  LOOP</span>
            {m[<span class="dv">16</span>],m[<span class="dv">17</span>],m[<span class="dv">18</span>],m[<span class="dv">19</span>]} = <span class="bn">32&#39;h00000000</span>; <span class="co">// 0010 K0:        WORD 0</span>
            {m[<span class="dv">20</span>],m[<span class="dv">21</span>],m[<span class="dv">22</span>],m[<span class="dv">23</span>]} = <span class="bn">32&#39;h00000001</span>; <span class="co">// 0014 K1:        WORD 1</span>
            data = <span class="bn">32&#39;hZZZZZZZZ</span>; 
        <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span> (abus &gt;=<span class="dv">0</span> &amp;&amp; abus &lt; <span class="dv">128</span>) <span class="kw">begin</span>
            <span class="kw">if</span> (en == <span class="dv">1</span> &amp;&amp; rw == <span class="dv">0</span>) <span class="co">// r_w==0:write</span>
            <span class="kw">begin</span>
                data = dbus_in;
                {m[abus], m[abus<span class="dv">+1</span>], m[abus<span class="dv">+2</span>], m[abus<span class="dv">+3</span>]} = dbus_in;
            <span class="kw">end</span>
            <span class="kw">else</span> <span class="kw">if</span> (en == <span class="dv">1</span> &amp;&amp; rw == <span class="dv">1</span>) <span class="co">// r_w==1:read</span>
                data = {m[abus], m[abus<span class="dv">+1</span>], m[abus<span class="dv">+2</span>], m[abus<span class="dv">+3</span>]};
            <span class="kw">else</span>
                data = <span class="bn">32&#39;hZZZZZZZZ</span>;
        <span class="kw">end</span> <span class="kw">else</span>
            data = <span class="bn">32&#39;hZZZZZZZZ</span>;
    <span class="kw">end</span>
    <span class="kw">assign</span> dbus_out = data;
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> clock, reset, en, rw;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] addr;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] data_in;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] data_out;

memory DUT (.clock(clock), .reset(reset), .en(en), .rw(rw), 
   .abus(addr), .dbus_in(data_in), .dbus_out(data_out));

<span class="kw">initial</span> <span class="co">// reset：設定 memory 內容為 0,1,2,....,127</span>
<span class="kw">begin</span>
  clock = <span class="dv">0</span>;
  reset = <span class="dv">1</span>;
  en = <span class="dv">0</span>;
  rw = <span class="dv">1</span>; <span class="co">// rw=1:讀取模式</span>
  <span class="bn">#75</span>;
  en = <span class="dv">1</span>;
  reset = <span class="dv">0</span>;
  addr = <span class="dv">0</span>;
  <span class="bn">#500</span>;
  addr = <span class="dv">4</span>;
  rw = <span class="dv">0</span>; <span class="co">// 寫入模式</span>
  data_in = <span class="bn">8&#39;h3A</span>;
  <span class="bn">#100</span>;
  addr = <span class="dv">0</span>;
  rw = <span class="dv">1</span>; <span class="co">// 讀取模式</span>
  data_in = <span class="dv">0</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clock = clock + <span class="dv">1</span>; 
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d rw=%d, addr=%8h din=%8h dout=%8h&quot;</span>, 
           <span class="dt">$stime</span>, clock, en, rw, addr, data_in, data_out);  
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#200</span> 
<span class="kw">begin</span>
 addr=addr<span class="dv">+1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code\verilog&gt;iverilog -o memory32 memory32.v

D:\Dropbox\Public\web\oc\code\verilog&gt;vvp memory32
  50ns monitor: clk=1 en=0 rw=1, addr=xxxxxxxx din=xxxxxxxx dout=zzzzzzzz
  75ns monitor: clk=1 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 100ns monitor: clk=0 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 150ns monitor: clk=1 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 200ns monitor: clk=0 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 250ns monitor: clk=1 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 300ns monitor: clk=0 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 350ns monitor: clk=1 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 400ns monitor: clk=0 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 450ns monitor: clk=1 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 500ns monitor: clk=0 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 550ns monitor: clk=1 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 575ns monitor: clk=1 en=1 rw=0, addr=00000004 din=0000003a dout=0000003a
 600ns monitor: clk=0 en=1 rw=0, addr=00000005 din=0000003a dout=0000003a
 650ns monitor: clk=1 en=1 rw=0, addr=00000005 din=0000003a dout=0000003a
 675ns monitor: clk=1 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 700ns monitor: clk=0 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 750ns monitor: clk=1 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 800ns monitor: clk=0 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 850ns monitor: clk=1 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 900ns monitor: clk=0 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 950ns monitor: clk=1 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
1000ns monitor: clk=0 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1050ns monitor: clk=1 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1100ns monitor: clk=0 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1150ns monitor: clk=1 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1200ns monitor: clk=0 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1250ns monitor: clk=1 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1300ns monitor: clk=0 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1350ns monitor: clk=1 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1400ns monitor: clk=0 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1450ns monitor: clk=1 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1500ns monitor: clk=0 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1550ns monitor: clk=1 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1600ns monitor: clk=0 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1650ns monitor: clk=1 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1700ns monitor: clk=0 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1750ns monitor: clk=1 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1800ns monitor: clk=0 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1850ns monitor: clk=1 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1900ns monitor: clk=0 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1950ns monitor: clk=1 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
2000ns monitor: clk=0 en=1 rw=1, addr=00000007 din=00000000 dout=003a2210</code></pre>
<h2 id="結語"><a href="#結語">結語</a></h2>
<p>在本章中，我們介紹了正反器 (Flip-Flop, Latch, 栓鎖器) 等循序電路的概念，並且利用閘級延遲的現象， 設計出了「脈衝偵測電路」(Pause Transition Detector, PTD)，於是我們可以利用「脈衝偵測電路」 設計出像「邊緣觸發型」的電路，像是「邊緣觸發型」的正反器、暫存器、計數器等等電路， 這些電路是構成電腦當中的記憶線路的基礎。</p>
<p>一但理解這些基礎原理之後，我們就可以用 Verilog 的高階語法直接宣告「暫存器、一群暫存器與 一整塊記憶體」，這種高階寫法已經非常接近高階語言的寫法，只是由於是設計硬體，所以這些高階指令 最後都會被轉換為線路，燒錄到 FPGA 或內建於 ASIC 裡面而已，如此我們就不需要用一條一條的線路去 兜出暫存器或記憶體，可以輕鬆的透過 Verilog 設計出記憶單元了。</p>
</div>
<div id="footer">
<a href="http://ccckmit.wikidot.com">陳鍾誠</a>衍生自<a href="http://zh.wikipedia.org/">維基百科</a>之作品：採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> <a href="license.html">授權</a>
</div>
</body>
</html>
