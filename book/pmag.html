<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="2014 年 7 月出版" />
  <title>開放電腦計畫 -- 計算機硬體結構</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
  <h1><a href="book.htm">開放電腦計畫 -- 計算機硬體結構</a><BR/><sub>(使用 Verilog 實作)</sub></h1>
  <table id="bar" border="0" style="border:0;"><tr style="border:0;">
    <td style="text-align:left;border:0;"> <a href="book.html">目錄</a> | <a href="download.html">下載</a> | <a href="course.html">課程</a> | <a href="forum.html">討論</a> | <a href="exam.html">測驗</a></td>
    <td style="text-align:right;border:0;"><a href="http://ccckmit.wikidot.com/">陳鍾誠</a> 於 <a href="http://www.nqu.edu.tw/">金門大學</a></td>
  </tr></table>
</div>
<div id="content">
<div id="header">
<h1 class="title">開放電腦計畫 -- 計算機硬體結構</h1>
<h2 class="author">2014 年 7 月出版</h2>
<h3 class="date">作者：陳鍾誠 (創作共用：姓名標示、相同方式分享授權)</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#前言">前言</a><ul>
<li><a href="#序">序</a></li>
<li><a href="#授權聲明">授權聲明</a></li>
</ul></li>
<li><a href="#開放電腦計畫">開放電腦計畫</a><ul>
<li><a href="#簡介">簡介</a></li>
<li><a href="#硬體計算機結構">硬體：計算機結構</a></li>
<li><a href="#軟體系統程式">軟體：系統程式</a></li>
<li><a href="#結語">結語</a></li>
<li><a href="#參考文獻">參考文獻</a></li>
</ul></li>
<li><a href="#電腦硬體架構">電腦硬體架構</a><ul>
<li><a href="#電腦的結構">電腦的結構</a></li>
<li><a href="#cpu0-處理器">CPU0 處理器</a></li>
<li><a href="#cpu0-的指令集">CPU0 的指令集</a></li>
<li><a href="#cpu0-指令格式">CPU0 指令格式</a></li>
<li><a href="#狀態暫存器">狀態暫存器</a></li>
<li><a href="#位元組順序">位元組順序</a></li>
<li><a href="#中斷程序">中斷程序</a></li>
<li><a href="#cpu0-的組合語言與機器碼">CPU0 的組合語言與機器碼</a></li>
<li><a href="#參考文獻-1">參考文獻</a></li>
</ul></li>
<li><a href="#硬體描述語言----verilog">硬體描述語言 -- Verilog</a><ul>
<li><a href="#verilog-基礎">Verilog 基礎</a></li>
<li><a href="#區塊式設計">區塊式設計</a></li>
<li><a href="#流程式設計">流程式設計</a></li>
<li><a href="#結語-1">結語</a></li>
<li><a href="#參考文獻-2">參考文獻</a></li>
</ul></li>
<li><a href="#組合邏輯-combinatorial-logic">組合邏輯 (Combinatorial Logic)</a><ul>
<li><a href="#簡介-1">簡介</a></li>
<li><a href="#加法器">加法器</a></li>
<li><a href="#位元加法器">32 位元加法器</a></li>
<li><a href="#前瞻進位加法器-carry-lookahead-adder">前瞻進位加法器 (Carry Lookahead Adder)</a></li>
<li><a href="#結語-2">結語</a></li>
<li><a href="#參考文獻-3">參考文獻</a></li>
</ul></li>
<li><a href="#算術邏輯單元-alu-的設計">算術邏輯單元 ALU 的設計</a><ul>
<li><a href="#加減器">加減器</a></li>
<li><a href="#採用-case-語法設計-alu-模組">採用 CASE 語法設計 ALU 模組</a></li>
<li><a href="#完整的-alu-設計-含測試程式">完整的 ALU 設計 (含測試程式)</a></li>
<li><a href="#結語-3">結語</a></li>
<li><a href="#參考文獻-4">參考文獻</a></li>
</ul></li>
<li><a href="#記憶單元-memory-unit">記憶單元 (Memory Unit)</a><ul>
<li><a href="#時序邏輯-sequential-logic">時序邏輯 (Sequential Logic)</a></li>
<li><a href="#正反器-閂鎖器">正反器 (閂鎖器)</a></li>
<li><a href="#sr-正反器">SR 正反器</a></li>
<li><a href="#有-enable-的正反器">有 enable 的正反器</a></li>
<li><a href="#閘級延遲-gate-delay">閘級延遲 (Gate Delay)</a></li>
<li><a href="#利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd">利用「閘級延遲」製作脈波變化偵測器 (Pulse Transition Detector, PTD)</a></li>
<li><a href="#使用脈衝偵測電路製作邊緣觸發正反器">使用「脈衝偵測電路」製作「邊緣觸發正反器」</a></li>
<li><a href="#使用脈衝偵測電路設計邊緣觸發暫存器">使用「脈衝偵測電路」設計邊緣觸發暫存器</a></li>
<li><a href="#使用脈衝偵測電路製作計數電路">使用「脈衝偵測電路」製作計數電路</a></li>
<li><a href="#暫存器單元">暫存器單元</a></li>
<li><a href="#記憶體">記憶體</a></li>
<li><a href="#結語-4">結語</a></li>
</ul></li>
<li><a href="#控制單元">控制單元</a><ul>
<li><a href="#簡介-2">簡介</a></li>
<li><a href="#流程式設計-1">流程式設計</a></li>
<li><a href="#區塊式設計-1">區塊式設計</a></li>
</ul></li>
<li><a href="#微處理器-micro-processor">微處理器 (Micro Processor)</a><ul>
<li><a href="#mcu0-的迷你版----mcu0m">MCU0 的迷你版 -- mcu0m</a></li>
<li><a href="#mcu0-的區塊式設計----mcu0bm.v">MCU0 的區塊式設計 -- MCU0bm.v</a></li>
<li><a href="#mcu0-完整版">MCU0 完整版</a></li>
</ul></li>
<li><a href="#輸出入單元-io">輸出入單元 (I/O)</a><ul>
<li><a href="#前言-2">前言</a></li>
<li><a href="#bus-總線-匯流排">BUS (總線, 匯流排)</a></li>
<li><a href="#同步匯流排-synchronous-bus">同步匯流排 (Synchronous BUS)</a></li>
<li><a href="#異步匯流排-asynchronous-bus">異步匯流排 (Asynchronous BUS)</a></li>
<li><a href="#匯流排仲裁-bus-arbitery">匯流排仲裁 (BUS arbitery)</a></li>
<li><a href="#循序與平行輸出入-serial-vs.-parallel">循序與平行輸出入 (Serial vs. Parallel)</a></li>
<li><a href="#常見的輸出入協定">常見的輸出入協定</a></li>
<li><a href="#mcu0-的輸出入----輪詢篇">MCU0 的輸出入 -- 輪詢篇</a></li>
</ul></li>
<li><a href="#記憶系統-storage">記憶系統 (Storage)</a><ul>
<li><a href="#記憶體階層-memory-hierarchy">記憶體階層 (Memory Hierarchy)</a></li>
<li><a href="#快取記憶體-cache">快取記憶體 (Cache)</a></li>
</ul></li>
<li><a href="#高階處理器-processor">高階處理器 (Processor)</a><ul>
<li><a href="#哈佛架構-harvard-architecture">哈佛架構 (Harvard Architecture)</a></li>
<li><a href="#流水線架構-pipeline">流水線架構 (Pipeline)</a></li>
<li><a href="#cpu0-迷你版---cpu0m">CPU0 迷你版 - CPU0m</a></li>
<li><a href="#cpu0-完整版----cpu0s">CPU0 完整版 -- cpu0s</a></li>
</ul></li>
<li><a href="#速度議題">速度議題</a><ul>
<li><a href="#乘法與除法">乘法與除法</a></li>
<li><a href="#浮點數運算">浮點數運算</a></li>
<li><a href="#繪圖加速功能-graphics">繪圖加速功能 (Graphics)</a></li>
<li><a href="#平行處理-parallel">平行處理 (Parallel)</a></li>
<li><a href="#結語-10">結語</a></li>
</ul></li>
<li><a href="#附錄">附錄</a><ul>
<li><a href="#本書內容與相關資源">本書內容與相關資源</a></li>
</ul></li>
</ul>
</div>
<h1 id="前言"><a href="#前言">前言</a></h1>
<h2 id="序"><a href="#序">序</a></h2>
<p>本書是「開放電腦計畫的硬體部份」，描述如何設計電腦硬體的方法，透過這本書，我們希望讓「計算機結構」這門課程，變成是可以動手實作的。</p>
<p>我們相信，透過實作的訓練，您將對理論會有更深刻的體會，而這些體會，將會進一步讓您更瞭解「現代電腦工業的結構」是如何建構出來的。</p>
<h2 id="授權聲明"><a href="#授權聲明">授權聲明</a></h2>
<p>本書許多資料修改自維基百科，採用 創作共用：<a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 授權，若您想要修改本書產生衍生著作時，至少應該遵守下列授權條件：</p>
<ol style="list-style-type: decimal">
<li>標示原作者姓名 (包含該文章作者，若有來自維基百科的部份也請一併標示)。</li>
<li>採用 創作共用：<a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 的方式公開衍生著作。</li>
</ol>
<p>另外、當本書中有文章或素材並非採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">姓名標示、相同方式分享</a> 時，將會在該文章或素材後面標示其授權，此時該文章將以該標示的方式授權釋出，請修改者注意這些授權標示，以避免產生侵權糾紛。</p>
<p>例如有些文章可能不希望被作為「商業性使用」，此時就可能會採用創作共用：<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/tw/">姓名標示、非商業性、相同方式分享</a> 的授權，此時您就不應當將該文章用於商業用途上。</p>
<p>最後、若讀者有需要轉貼或修改這些文章使用，請遵守「創作共用」的精神，讓大家都可以在「開放原始碼」的基礎上逐步改進這些作品。</p>
<h1 id="開放電腦計畫"><a href="#開放電腦計畫">開放電腦計畫</a></h1>
<h2 id="簡介"><a href="#簡介">簡介</a></h2>
<p>如果您是資工系畢業的學生，必然會上過「計算機結構、編譯器、作業系統、系統程式」等等課程， 這些課程都是設計出一台電腦所必需的基本課程。但是如果有人問您「您是否會設計電腦呢？」，相信大部分人 的回答應該是：「我不會，也沒有設計過」。</p>
<p>光是設計一個作業系統，就得花上十年的工夫，遑論還要自己設計「CPU、匯流排、組譯器、編譯器、作業系統」 等等。因此，我們都曾經有過這樣的夢想，然後在年紀越大，越來越瞭解整個工業結構之後，我們就放棄了這樣 一個夢想，因為我們必須與現實妥協。</p>
<p>但是，身為一個大學教師，我有責任教導學生，告訴他們「電腦是怎麼做出來的」，因此我不自量力的提出了 這樣一個計畫，那就是「開放電腦計畫」，我們將以「千里之行、始於足下」的精神，設計出一台全世界最簡單 且清楚的「電腦」，包含「軟體與硬體」。</p>
<p>從 2007 年我開始寫「系統程式」這本書以來，就有一個想法逐漸在內心發酵， 這個想法就是：「我想從 CPU 設計、組譯器、虛擬機、編譯器到作業系統」，自己打造一台電腦，於是、「開放電腦計畫」就誕生了！</p>
<p>那麼、開放電腦計畫的「產品」會是什麼呢？</p>
<p>應該有些人會認為是一套自行編寫的軟硬體程式，當然、這部份是包含在「開放電腦計畫」當中的。</p>
<p>但是、更重要的事情是，我們希望透過「開放電腦計畫」讓學生能夠學會整個「電腦的軟硬體設計方式」，並且透過這個踏腳石瞭解整個「電腦軟硬體工業」，進而能夠達到「以理論指導實務、以實務驗證理論」的目標。</p>
<p>為了達成這個目標，我們將「開放電腦計畫」分成三個階段，也就是「簡單設計 (程式) =&gt; 理論闡述 (書籍) =&gt; 開源實作 (工業軟硬體與流程)」，整體的構想說明如下：</p>
<ol style="list-style-type: decimal">
<li>簡單設計(程式)： 採用 Verilog + C 設計「CPU、組譯器、編譯器、作業系統」等軟硬體，遵循 KISS (Keep It Simple and Stupid) 原則，不考慮「效能」 與「商業競爭力」等問題，甚至在實用性上進行了不少妥協，一律採用「容易理解」為最高指導原則，目的是清楚的展現整個「軟硬體系統」的架構。</li>
<li>理論闡述(書籍)： 但是、要瞭解像「處理器、系統軟體、編譯器、作業系統」這些領域，只有程式是不夠的。因為程式通常不容易懂，而且對於沒有背景知識的人而言，往往難如天書。所以我們將撰寫一系列書籍，用來說明上述簡單程式的設計原理，然後開始進入「計算機結構、編譯器、作業系統、系統程式」的理論體系中，導引出進一步的設計可能性與工業考量等議題。</li>
<li>開源實作(工業)：一但有了前述的理論與實作基礎之後，我們就會採用「開放原始碼」來進行案例研究。舉例而言、在「計算機結構」上我們會以 ARM 為實務核心、「編譯器」領域則以 gcc, LLVM 為研究標的，「作業系統」上則會對 FreeRTOS、Linux 等進行案例研究，「虛擬機」上則會以 QEMU、V8 等開源案例為研究對象。</li>
</ol>
<div class="figure">
<img src="../img/OpenComputerMap.jpg" alt="圖、開放電腦計畫地圖" /><p class="caption">圖、開放電腦計畫地圖</p>
</div>
<p>根據以上規劃，本書乃為一系列書籍中的一本，完整的書籍架構如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">開放電腦計畫書籍</th>
<th align="left">簡易程式</th>
<th align="left">工業實作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">系統程式</td>
<td align="left">as0, vm0, cc0, os0</td>
<td align="left">gcc/llvm</td>
</tr>
<tr class="even">
<td align="left">計算機結構</td>
<td align="left">mcu0, cpu0</td>
<td align="left">ARM/OpenRISC</td>
</tr>
<tr class="odd">
<td align="left">編譯器 c</td>
<td align="left">0c, j0c g</td>
<td align="left">cc/llvm</td>
</tr>
<tr class="even">
<td align="left">作業系統</td>
<td align="left">os0, XINU, MINIX</td>
<td align="left">FreeRTOS, Linux</td>
</tr>
</tbody>
</table>
<p>這些書籍分別描述不同的面向，其涵蓋範圍如下圖所示：</p>
<div class="figure">
<img src="../img/OpenComputerMap2.jpg" alt="圖、開放電腦計畫書籍圖" /><p class="caption">圖、開放電腦計畫書籍圖</p>
</div>
<h2 id="硬體計算機結構"><a href="#硬體計算機結構">硬體：計算機結構</a></h2>
<p>在硬體方面，我們將自行設計兩款處理器，一款是用來展示簡單「微處理器」設計原理的16 位元微控制器 MCU0，而另一款則是用來展示「高階處理器」設計原理的 32 位元處理器 CPU0。</p>
<p>透過 MCU0，我們希望展示一顆「最簡易微處理器」的設計方法，我們將採用「流程式」與「區塊式」的方法分別實作一遍，讓讀者可以分別從「硬體人」與「軟體人」的角度去體會處理器的設計方式。由於「流程式」的方法比較簡單，因此我們會先用此法進行設計，當讀者理解何謂「微處理器」之後，在將同樣的功能改用「區塊式的方法」實作一遍，這樣應該就能逐漸「由易至難、由淺入深」了。</p>
<p>在 MCU0 當中，我們採用「CPU 與記憶體」合一的設計方式，這種方式比較像「系統單晶片」(SOC) 的設計方法，其記憶體容量較小，因此可以直接用 Verilog 陣列宣告放入 FPGA 當中使用，不需考慮外部 DRAM 存取速度較慢的問題，也不用考慮「記憶階層」的速度問題，因此設計起來會相對容易許多。</p>
<p>接著，我們將再度設計一個 32 位元的處理器 -- CPU0。並透過 CPU0 來討論「當 CPU 速度比 DRAM 記憶體快上許多」的時候，如何能透過快取 (cache) 與記憶體管理單元 (MMU) 達到「又快又大」的目的，並且討論如何透過「流水線」架構 (Pipeline) 達到加速的目的，這些都屬於「高階處理器」所需要討論的問題。</p>
<h2 id="軟體系統程式"><a href="#軟體系統程式">軟體：系統程式</a></h2>
<p>有了 MCU0 與 CPU0 等硬體之後，我們就可以建構運作於這些硬體之上的軟體了，這些軟體包含「組譯器、虛擬機、編譯器、作業系統」等等。</p>
<p>我們已經分別用 C 與 JavaSript 建構出簡易的「組譯器、虛擬機、編譯器」工具了，讓我們先說明一下在 CPU0 上這些程式的使用方法，以下示範是採用 node.js+Javascript 實作的工具版本，因此必須安裝 node.js 才能執行。</p>
<h3 id="組合語言-assembly-language"><a href="#組合語言-assembly-language">組合語言 (Assembly Language)</a></h3>
<p>接著、讓我們從組合語言的角度，來看看 CPU0 處理器的設計，以下是一個可以計算 <code>1+2+...+10</code> 的程式， 計算完成之後會透過呼叫軟體中斷 SWI 程序 (類似 DOS 時代的 INT 中斷)，在螢幕上印出下列訊息。</p>
<pre><code>1+...+10=55</code></pre>
<p>以下的檔案 sum.as0 正是完成這樣功能的一個 CPU0 組合語言程式。</p>
<p>檔案：sum.as0</p>
<pre><code>        LD     R1, sum      ; R1 = sum = 0
        LD     R2, i        ; R2 = i = 1
        LDI    R3, 10       ; R3 = 10
FOR:    CMP    R2, R3       ; if (R2 &gt; R3)
        JGT    EXIT         ;   goto EXIT
        ADD    R1, R1, R2   ; R1 = R1 + R2 (sum = sum + i)
        ADDI   R2, R2, 1    ; R2 = R2 + 1  ( i  = i + 1)
        JMP    FOR          ; goto FOR
EXIT:   ST     R1, sum      ; sum = R1
        ST     R2, i        ; i = R2
        LD     R9, msgptr   ; R9= pointer(msg) = &amp;msg
        SWI    3            ; SWI 3 : 印出 R9 (=&amp;msg) 中的字串
        MOV    R9, R1       ; R9 = R1 = sum
        SWI    4            ; SWI 4 : 印出 R9 (=R1=sum) 中的整數
        RET                 ; return 返回上一層呼叫函數
i:      RESW   1            ; int i
sum:    WORD   0            ; int sum=0
msg:    BYTE   &quot;1+...+10=&quot;, 0   ; char *msg = &quot;sum=&quot;
msgptr: WORD   msg          ; char &amp;msgptr = &amp;msg</code></pre>
<h3 id="組譯器-assembler"><a href="#組譯器-assembler">組譯器 (Assembler)</a></h3>
<p>我們可以用以下指令呼叫「組譯器 AS0」對上述檔案進行組譯：</p>
<pre><code>node as0 sum.as0 sum.ob0</code></pre>
<p>上述的程式經過組譯之後，會輸出組譯報表，如下所示。</p>
<p>sum.as0 的組譯報表</p>
<pre><code>0000          LD       R1,sum           L 00 001F003C
0004          LD       R2,i             L 00 002F0034
0008          LDI      R3,10            L 08 0830000A
000C FOR      CMP      R2,R3            A 10 10230000
0010          JGT      EXIT             J 23 2300000C
0014          ADD      R1,R1,R2         A 13 13112000
0018          ADDI     R2,R2,1          A 1B 1B220001
001C          JMP      FOR              J 26 26FFFFEC
0020 EXIT     ST       R1,sum           L 01 011F001C
0024          ST       R2,i             L 01 012F0014
0028          LD       R9,msgptr        L 00 009F0022
002C          SWI      3                J 2A 2A000003
0030          MOV      R9,R1            A 12 12910000
0034          SWI      2                J 2A 2A000002
0038          RET                       J 2C 2C000000
003C i        RESW     1                D F0 00000000
0040 sum      WORD     0                D F2 00000000
0044 msg      BYTE     &quot;1+...+10=&quot;,0    D F3 312B2E2E2E2B31303D00
004E msgptr   WORD     msg              D F2 00000044</code></pre>
<p>最後「組譯器 AS0」會輸出機器碼到目的檔 sum.ob0 當中，其內容如下所示。</p>
<p>sum.as0 的機器碼 (以 16 進位顯示)</p>
<pre><code>001F003C 002F0034 0830000A 10230000
2300000C 13112000 1B220001 26FFFFEC
011F001C 012F0014 009F0022 2A000003
12910000 2A000002 2C000000 00000000
00000000 312B2E2E 2E2B3130 3D000000
0044</code></pre>
<h3 id="虛擬機-virtual-machine"><a href="#虛擬機-virtual-machine">虛擬機 (Virtual Machine)</a></h3>
<p>如果我們用「虛擬機 VM0」去執行上述的目的檔 sum.ob0，會看到程式的執行結果，是在 螢幕上列印出 <code>1+...+10=55</code>，以下是我們的操作過程。</p>
<pre><code>1+...+10=55</code></pre>
<h3 id="編譯器-compiler"><a href="#編譯器-compiler">編譯器 (Compiler)</a></h3>
<p>當然、一個完整的現代電腦應該包含比組譯器更高階的工具，不只支援組合語言，還要支援高階語言。</p>
<p>因此、我們設計了一個稱為 J0 的高階語言，語法有點像 JavaScript，但卻是經過簡化的版本。</p>
<p>然後、我們又設計了一個可以用來編譯 J0 語言的編譯器，稱為 J0C (J0 Compiler)，可以用來將 J0 語言編譯成中間碼， 也可以直接將中間碼轉換為 CPU0 的組合語言。</p>
<p>以下是一個 J0 語言的範例，</p>
<p>檔案：sum.j0</p>
<pre><code>s = sum(10);
return s;

function sum(n) {
  s = 0;
  i=1;
  while (i&lt;=10) {
    s = s + i;
    i++;
  }
  return s;
}
</code></pre>
<p>當我們使用 j0c 編譯器將上述程式編譯之後，會輸出兩個檔案，一個是 sum.ir，是編譯器中間格式 (Intermediate Representation, 虛擬碼 pcode) 的輸出檔， 其內容如下：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;node j0c sum
         arg      10
         call     T1       sum
         =        s        T1
         return   s
sum      function
         param    n
         =        s        0
         =        i        1
L1
         &lt;=       T2       i        10
         if0      T2       L2
         +        T3       s        i
         =        s        T3
         ++       i
         goto     L1
L2
         return   s
         endf</code></pre>
<p>另一個是將上述中間格式轉換成轉換成 CPU0 組合語言之後的結果，如下所示：</p>
<pre><code>sum
         POP      n
         LDI      R1       0
         ST       R1       s
         LDI      R1       1
         ST       R1       i
L1
         LD       R1       i
         LDI      R2       10
         LDI      R3       0
         CMP      R1       R2
         JLE      else1
         LDI      R3       1
else1
         ST       R3       T1
         LDI      R1       T1
         CMP      R1       0
         JEQ      L2
         LD       R1       s
         LD       R2       i
         ADD      R3       R1       R2
         ST       R3       T2
         LDI      R1       T2
         ST       R1       s
         LD       R1       i
         ADDI     R1       R1       1
         ST       R1       i
         JMP      L1
L2
         LD       R1       s
         RET
         LDI      R1       10
         PUSH     R1
         CALL     sum
         ST       R1       T3
         LDI      R1       T3
         ST       R1       s

s        WORD     0
i        WORD     0
T1       WORD     0
T2       WORD     0
T3       WORD     0</code></pre>
<p>上述由 j0c 所編譯產生的組合語言，感覺相對冗長，是因為這個編譯器是最簡版本，完全沒有做任何優化動作，甚至連暫存器都是 每次重新載入的，所以效率並不會很好。</p>
<h3 id="作業系統-operating-system"><a href="#作業系統-operating-system">作業系統 (Operating System)</a></h3>
<p>當然囉！一個完整的電腦還必須要有作業系統，不過如果是嵌入式系統的話，沒有作業系統也沒關係，只要將全部的程式連結在一起， 就可以形成一台電腦了，目前開放電腦計畫的「作業系統」還在研究開發當中，希望很快就能提供大家一個最簡單的作業系統版本。</p>
<p>目前我們已經寫了一個可以進行兩個行程切換 「Task Switching」 範例，接著我們將參考 UNIXv6, L4 等作業系統，以建構更 完整的簡易作業系統。</p>
<h2 id="結語"><a href="#結語">結語</a></h2>
<p>當然、即使我們從 CPU 硬體一路設計到組譯器、虛擬機、編譯器、作業系統等，未來仍然有更多領域等待我們去探索，例如「網路模組、TCP/IP、 Ethernet、無線 RF 的硬體模組、繪圖卡、OpenGL、.....」等等，希望我們能夠用最簡單的話語，將這些電腦的原理說明清楚，並用簡單的方式 實作得更完整。</p>
<h2 id="參考文獻"><a href="#參考文獻">參考文獻</a></h2>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:main">陳鍾誠的網站/免費電子書：Verilog 電路設計</a></li>
<li><a href="http://sp1.wikidot.com/main">系統程式</a> 陳鍾誠著, 旗標出版社.</li>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201306/htm/article2.html">JavaScript (6) – Node.js 命令列程式設計</a></li>
</ul>
<h1 id="電腦硬體架構"><a href="#電腦硬體架構">電腦硬體架構</a></h1>
<h2 id="電腦的結構"><a href="#電腦的結構">電腦的結構</a></h2>
<p>傳統的電腦架構，最經典的模型是由數學大師「馮紐曼」 (Von Neumann) 所描述的，因此稱為「馮紐曼架構」，如以下兩個圖片所示：</p>
<div class="figure">
<img src="../img/VonNeumannArchitecture1.jpg" alt="圖、馮紐曼架構 (1)圖片來源： http://en.wikipedia.org/wiki/File:Von_Neumann_Architecture.svg" /><p class="caption">圖、馮紐曼架構 (1)<br/>圖片來源： <a href="http://en.wikipedia.org/wiki/File:Von_Neumann_Architecture.svg">http://en.wikipedia.org/wiki/File:Von_Neumann_Architecture.svg</a></p>
</div>
<div class="figure">
<img src="../img/VonNeumannArchitecture2.jpg" alt="圖、馮紐曼架構 (2)圖片來源： http://en.wikipedia.org/wiki/File:Von_Neumann_architecture.svg" /><p class="caption">圖、馮紐曼架構 (2)<br/>圖片來源： <a href="http://en.wikipedia.org/wiki/File:Von_Neumann_architecture.svg">http://en.wikipedia.org/wiki/File:Von_Neumann_architecture.svg</a></p>
</div>
<p>在早期、晶片線路成本還算高的時候，最常見的馮紐曼架構電腦，是採用單匯流排的架構，如下圖所示：</p>
<div class="figure">
<img src="../img/SingleBusArchitecture.jpg" alt="圖、單一匯流排的馮紐曼架構圖片來源： http://en.wikipedia.org/wiki/File:Computer_system_bus.svg" /><p class="caption">圖、單一匯流排的馮紐曼架構<br/>圖片來源： <a href="http://en.wikipedia.org/wiki/File:Computer_system_bus.svg">http://en.wikipedia.org/wiki/File:Computer_system_bus.svg</a></p>
</div>
<p>但是、自從 RISC 精簡指令集電腦出現，由於 pipeline 必須讓指令與資料可以同時被存取，很多電腦改採以下指令與資料分開的哈佛架構 (Harvard Architecture)：</p>
<div class="figure">
<img src="../img/HarvardArchitecture.jpg" alt="圖、指令與資料匯流排分開的哈佛架構圖片來源： http://en.wikipedia.org/wiki/File:Harvard_architecture.svg" /><p class="caption">圖、指令與資料匯流排分開的哈佛架構<br/>圖片來源： <a href="http://en.wikipedia.org/wiki/File:Harvard_architecture.svg">http://en.wikipedia.org/wiki/File:Harvard_architecture.svg</a></p>
</div>
<p>必須注意的是，雖然哈佛架構當中的指令與資料是完全分開的，但是如果真的將指令與資料個記憶體整個分開的話，會需要兩套記憶體與匯流排， 這會讓 CPU 的接腳數大增，也會讓記憶體運用沒效率，因此在實務上，通常是將「快取記憶體」分成兩邊，一邊是指令快取，一邊是資料快取， 這樣就只有內部匯流排需要分開成兩套，而 CPU 對外則只要一套匯流排與記憶體，這種架構可以看成哈佛架構的一種變形。</p>
<h2 id="cpu0-處理器"><a href="#cpu0-處理器">CPU0 處理器</a></h2>
<p>CPU0 是一個簡易的 32 位元單匯流排處理器，其架構如下圖所示，包含R0..R15, IR, MAR, MDR 等暫存器，其中 IR是指令暫存器， R0 是一個永遠為常數 0 的唯讀暫存器，R15 是程式計數器 (Program Counter : PC)，R14 是連結暫存器 (Link Register : LR)， R13 是堆疊指標暫存器 (Stack Pointer : SP)，而 R12 是狀態暫存器 (Status Word : SW)。</p>
<div class="figure">
<img src="../img/cpu0architecture.jpg" alt="圖、CPU0 的架構圖" /><p class="caption">圖、CPU0 的架構圖</p>
</div>
<h2 id="cpu0-的指令集"><a href="#cpu0-的指令集">CPU0 的指令集</a></h2>
<p>CPU0 包含『載入儲存』、『運算指令』、『跳躍指令』、『堆疊指令』等四大類指令，以下表格是 CPU0 的指令編碼表，記載了 CPU0 的指令集與每個指令的編碼。</p>
<table>
<thead>
<tr class="header">
<th align="left">格式</th>
<th align="left">指令</th>
<th align="left">OP</th>
<th align="left">說明</th>
<th align="left">語法</th>
<th align="left">語意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">L</td>
<td align="left">LD</td>
<td align="left">00</td>
<td align="left">載入word</td>
<td align="left">LD Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">ST</td>
<td align="left">01</td>
<td align="left">儲存word</td>
<td align="left">ST Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="odd">
<td align="left">L</td>
<td align="left">LDB</td>
<td align="left">02</td>
<td align="left">載入 byte</td>
<td align="left">LDB Ra, [Rb+Cx]</td>
<td align="left">Ra=(byte)[Rb+Cx]</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">STB</td>
<td align="left">03</td>
<td align="left">儲存 byte</td>
<td align="left">STB Ra, [Rb+Cx]</td>
<td align="left">Ra=(byte)[Rb+Cx]</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">LDR</td>
<td align="left">04</td>
<td align="left">LD的暫存器版</td>
<td align="left">LDR Ra, [Rb+Rc]</td>
<td align="left">Ra=[Rb+Rc]</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">STR</td>
<td align="left">05</td>
<td align="left">ST的暫存器版</td>
<td align="left">STR Ra, [Rb+Rc]</td>
<td align="left">Ra=[Rb+Rc]</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">LBR</td>
<td align="left">06</td>
<td align="left">LDB的暫存器版</td>
<td align="left">LBR Ra, [Rb+Rc]</td>
<td align="left">Ra=(byte)[Rb+Rc]</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">SBR</td>
<td align="left">07</td>
<td align="left">STB的暫存器版</td>
<td align="left">SBR Ra, [Rb+Rc]</td>
<td align="left">Ra=(byte)[Rb+Rc]</td>
</tr>
<tr class="odd">
<td align="left">L</td>
<td align="left">LDI</td>
<td align="left">08</td>
<td align="left">載入常數</td>
<td align="left">LDI Ra, Cx</td>
<td align="left">Ra=Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">CMP</td>
<td align="left">10</td>
<td align="left">比較</td>
<td align="left">CMP Ra, Rb</td>
<td align="left">SW=Ra &gt;=&lt; Rb</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">MOV</td>
<td align="left">12</td>
<td align="left">移動</td>
<td align="left">MOV Ra, Rb</td>
<td align="left">Ra=Rb</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">ADD</td>
<td align="left">13</td>
<td align="left">加法</td>
<td align="left">ADD Ra, Rb, Rc</td>
<td align="left">Ra=Rb+Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">SUB</td>
<td align="left">14</td>
<td align="left">減法</td>
<td align="left">SUB Ra, Rb, Rc</td>
<td align="left">Ra=Rb-Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">MUL</td>
<td align="left">15</td>
<td align="left">乘法</td>
<td align="left">MUL Ra, Rb, Rc</td>
<td align="left">Ra=Rb*Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">DIV</td>
<td align="left">16</td>
<td align="left">除法</td>
<td align="left">DIV Ra, Rb, Rc</td>
<td align="left">Ra=Rb/Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">AND</td>
<td align="left">18</td>
<td align="left">邏輯 AND</td>
<td align="left">AND Ra, Rb, Rc</td>
<td align="left">Ra=Rb and Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">OR</td>
<td align="left">19</td>
<td align="left">邏輯 OR</td>
<td align="left">OR Ra, Rb, Rc</td>
<td align="left">Ra=Rb or Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">XOR</td>
<td align="left">1A</td>
<td align="left">邏輯 XOR</td>
<td align="left">XOR Ra, Rb, Rc</td>
<td align="left">Ra=Rb xor Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ADDI</td>
<td align="left">1B</td>
<td align="left">常數加法</td>
<td align="left">ADDI Ra, Rb, Cx</td>
<td align="left">Ra=Rb + Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">ROL</td>
<td align="left">1C</td>
<td align="left">向左旋轉</td>
<td align="left">ROL Ra, Rb, Cx</td>
<td align="left">Ra=Rb rol Cx</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ROR</td>
<td align="left">1D</td>
<td align="left">向右旋轉</td>
<td align="left">ROR Ra, Rb, Cx</td>
<td align="left">Ra=Rb ror Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">SHL</td>
<td align="left">1E</td>
<td align="left">向左移位</td>
<td align="left">SHL Ra, Rb, Cx</td>
<td align="left">Ra=Rb &lt;&lt; Cx</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">SHR</td>
<td align="left">1F</td>
<td align="left">向右移位</td>
<td align="left">SHR Ra, Rb, Cx</td>
<td align="left">Ra=Rb &gt;&gt; Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JEQ</td>
<td align="left">20</td>
<td align="left">跳躍 (相等)</td>
<td align="left">JEQ Cx</td>
<td align="left">if SW(=) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JNE</td>
<td align="left">21</td>
<td align="left">跳躍 (不相等)</td>
<td align="left">JNE Cx</td>
<td align="left">if SW(!=) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JLT</td>
<td align="left">22</td>
<td align="left">跳躍 (&lt;)</td>
<td align="left">JLT Cx</td>
<td align="left">if SW(&lt;) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JGT</td>
<td align="left">23</td>
<td align="left">跳躍 (&gt;)</td>
<td align="left">JGT Cx</td>
<td align="left">if SW(&gt;) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JLE</td>
<td align="left">24</td>
<td align="left">跳躍 (&lt;=)</td>
<td align="left">JLE Cx</td>
<td align="left">if SW(&lt;=) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JGE</td>
<td align="left">25</td>
<td align="left">跳躍 (&gt;=)</td>
<td align="left">JGE Cx</td>
<td align="left">if SW(&gt;=) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JMP</td>
<td align="left">26</td>
<td align="left">跳躍 (無條件)</td>
<td align="left">JMP Cx</td>
<td align="left">PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">SWI</td>
<td align="left">2A</td>
<td align="left">軟體中斷</td>
<td align="left">SWI Cx</td>
<td align="left">LR=PC; PC=Cx; INT=1</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">CALL</td>
<td align="left">2B</td>
<td align="left">跳到副程式</td>
<td align="left">CALL Cx</td>
<td align="left">LR=PC; PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">RET</td>
<td align="left">2C</td>
<td align="left">返回</td>
<td align="left">RET</td>
<td align="left">PC=LR</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">IRET</td>
<td align="left">2D</td>
<td align="left">中斷返回</td>
<td align="left">IRET</td>
<td align="left">PC=LR; INT=0</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">PUSH</td>
<td align="left">30</td>
<td align="left">推入word</td>
<td align="left">PUSH Ra</td>
<td align="left">SP-=4; [SP]=Ra;</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">POP</td>
<td align="left">31</td>
<td align="left">彈出 word</td>
<td align="left">POP Ra</td>
<td align="left">Ra=[SP]; SP+=4;</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">PUSHB</td>
<td align="left">32</td>
<td align="left">推入 byte</td>
<td align="left">PUSHB Ra</td>
<td align="left">SP--; [SP]=Ra; (byte)</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">POPB</td>
<td align="left">33</td>
<td align="left">彈出 byte</td>
<td align="left">POPB Ra</td>
<td align="left">Ra=[SP]; SP++; (byte)</td>
</tr>
</tbody>
</table>
<h2 id="cpu0-指令格式"><a href="#cpu0-指令格式">CPU0 指令格式</a></h2>
<p>CPU0 所有指令長度均為 32 位元，這些指令也可根據編碼方式分成三種不同的格式，分別是 A 型、J 型與 L 型。</p>
<p>大部分的運算指令屬於A (Arithmatic) 型，而載入儲存指令通常屬於 L (Load &amp; Store) 型，跳躍指令則通常屬於 J (Jump) 型， 這三種型態的指令格式如下圖所示。</p>
<div class="figure">
<img src="../img/cpu0format.jpg" alt="圖、CPU0的指令格式" /><p class="caption">圖、CPU0的指令格式</p>
</div>
<h2 id="狀態暫存器"><a href="#狀態暫存器">狀態暫存器</a></h2>
<p>R12 狀態暫存器 (Status Word : SW) 是用來儲存 CPU 的狀態值，這些狀態是許多旗標的組合。例如，零旗標 (Zero，簡寫為Z) 代表比較的結果為 0，負旗標 (Negative ，簡寫為N) 代表比較的結果為負值，另外常見的旗標還有進位旗標 (Carry ，簡寫為 C)， 溢位旗標 (Overflow，簡寫為 V) 等等。下圖顯示了 CPU0 的狀態暫存器格式，最前面的四個位元 N、Z、C、V所代表的， 正是上述的幾個旗標值。</p>
<div class="figure">
<img src="../img/cpu0sw.jpg" alt="圖、CPU0 中狀態暫存器 SW 的結構" /><p class="caption">圖、CPU0 中狀態暫存器 SW 的結構</p>
</div>
<p>條件旗標的 N、Z 旗標值可以用來代表比較結果是大於 (&gt;)、等於 (=) 還是小於 (&lt;)，當執行 CMP Ra, Rb 動作後，會有下列三種可能的情形。</p>
<ol style="list-style-type: decimal">
<li>若 Ra &gt; Rb，則 N=0, Z=0。</li>
<li>若 Ra &lt; Rb，則 N=1, Z=0。</li>
<li>若 Ra = Rb，則 N=0, Z=1。</li>
</ol>
<p>如此，用來進行條件跳躍的 JGT、JGE、JLT、JLE、JEQ、JNE指令，就可以根據 SW 暫存器當中的 N、Z 等旗標決定是否進行跳躍。</p>
<p>SW 中還包含中斷控制旗標 I (Interrupt) 與 T (Trap)，用以控制中斷的啟動與禁止等行為，假如將 I 旗標設定為 0，則CPU0將禁止所有種類的中斷，也就是對任何中斷都不會起反應。但如果只是將 T 旗標設定為0，則只會禁止軟體 中斷指令 SWI (Software Interrupt)，不會禁止由硬體觸發的中斷。</p>
<p>SW 中還儲存有『處理器模式』的欄位，M=0 時為『使用者模式』 (user mode) 與 M=1 時為『特權模式』(super mode) 等， 這在作業系統的設計上經常被用來製作安全保護功能。在使用者模式當中，任何設定狀態暫存器 R12 的動作都會被視為是非法的， 這是為了進行保護功能的緣故。但是在特權模式中，允許進行任何動作，包含設定中斷旗標與處理器模式等位元， 通常作業系統會使用特權模式 (M=1)，而一般程式只能處於使用者模式 (M=0)。</p>
<h2 id="位元組順序"><a href="#位元組順序">位元組順序</a></h2>
<p>CPU0 採用大者優先 (Big Endian) 的位元組順序 (Byte Ordering)，因此代表值越大的位元組會在記憶體的前面 (低位址處)，代表值小者會在高位址處。</p>
<p>由於 CPU0 是 32 位元的電腦，因此，一個字組 (Word) 占用 4 個位元組 (Byte)，因此，像 LD R1, [100] 這樣的指令，其實是將記憶體 100-103 中的字組取出，存入到暫存器 R1 當中。</p>
<p>LDB 與 STB 等指令，其中的 B 是指 Byte，因此，LDB R1, [100] 會將記憶體 100 中的 byte 取出，載入到 R1 當中。但是，由於 R1 的大小是 32 bits，相當於 4個 byte，此時，LDB 與 STB 指令到底是存取四個 byte 當中的哪一個byte呢？這個問題的答案是byte 3，也就是最後的一個 byte。</p>
<h2 id="中斷程序"><a href="#中斷程序">中斷程序</a></h2>
<p>CPU0 的中斷為不可重入式中斷，其中斷分為軟體中斷 SWI (Trap) 與硬體中斷 HWI (Interrupt) 兩類。</p>
<p>硬體中斷發生時，中段代號 INT_ADDR 會從中段線路傳入，此時執行下列動作：</p>
<ol style="list-style-type: decimal">
<li>LR=PC; INT=1</li>
<li>PC=INT_ADDR</li>
</ol>
<p>軟體中斷 SWI Cx 發生時，會執行下列動作：</p>
<ol style="list-style-type: decimal">
<li>LR=PC; INT=1</li>
<li>PC=Cx;</li>
</ol>
<p>中斷最後可以使用 IRET 返回，返回前會設定允許中斷狀態。</p>
<ol style="list-style-type: decimal">
<li>PC=LR; INT=0</li>
</ol>
<h2 id="cpu0-的組合語言與機器碼"><a href="#cpu0-的組合語言與機器碼">CPU0 的組合語言與機器碼</a></h2>
<p>接著、讓我們從組合語言的角度，來看看 CPU0 處理器的設計，以下是一個可以計算 <code>1+2+...+10</code> 的程式， 計算完成之後會透過呼叫軟體中斷 SWI 程序 (類似 DOS 時代的 INT 中斷)，在螢幕上印出下列訊息。</p>
<pre><code>1+...+10=55</code></pre>
<p>以下的檔案 sum.as0 正是完成這樣功能的一個 CPU0 組合語言程式。</p>
<p>檔案：sum.as0</p>
<pre><code>        LD     R1, sum      ; R1 = sum = 0
        LD     R2, i        ; R2 = i = 1
        LDI    R3, 10       ; R3 = 10
FOR:    CMP    R2, R3       ; if (R2 &gt; R3)
        JGT    EXIT         ;   goto EXIT
        ADD    R1, R1, R2   ; R1 = R1 + R2 (sum = sum + i)
        ADDI   R2, R2, 1    ; R2 = R2 + 1  ( i  = i + 1)
        JMP    FOR          ; goto FOR
EXIT:   ST     R1, sum      ; sum = R1
        ST     R2, i        ; i = R2
        LD     R9, msgptr   ; R9= pointer(msg) = &amp;msg
        SWI    3            ; SWI 3 : 印出 R9 (=&amp;msg) 中的字串
        MOV    R9, R1       ; R9 = R1 = sum
        SWI    4            ; SWI 4 : 印出 R9 (=R1=sum) 中的整數
        RET                 ; return 返回上一層呼叫函數
i:      RESW   1            ; int i
sum:    WORD   0            ; int sum=0
msg:    BYTE   &quot;1+...+10=&quot;, 0   ; char *msg = &quot;sum=&quot;
msgptr: WORD   msg          ; char &amp;msgptr = &amp;msg</code></pre>
<p>我們可以用以下指令呼叫「組譯器 AS0」對上述檔案進行組譯：</p>
<pre><code>node as0 sum.as0 sum.ob0</code></pre>
<p>上述的程式經過組譯之後，會輸出組譯報表，如下所示。</p>
<p>sum.as0 的組譯報表</p>
<pre><code>0000          LD       R1,sum           L 00 001F003C
0004          LD       R2,i             L 00 002F0034
0008          LDI      R3,10            L 08 0830000A
000C FOR      CMP      R2,R3            A 10 10230000
0010          JGT      EXIT             J 23 2300000C
0014          ADD      R1,R1,R2         A 13 13112000
0018          ADDI     R2,R2,1          A 1B 1B220001
001C          JMP      FOR              J 26 26FFFFEC
0020 EXIT     ST       R1,sum           L 01 011F001C
0024          ST       R2,i             L 01 012F0014
0028          LD       R9,msgptr        L 00 009F0022
002C          SWI      3                J 2A 2A000003
0030          MOV      R9,R1            A 12 12910000
0034          SWI      2                J 2A 2A000002
0038          RET                       J 2C 2C000000
003C i        RESW     1                D F0 00000000
0040 sum      WORD     0                D F2 00000000
0044 msg      BYTE     &quot;1+...+10=&quot;,0    D F3 312B2E2E2E2B31303D00
004E msgptr   WORD     msg              D F2 00000044</code></pre>
<p>最後「組譯器 AS0」會輸出機器碼到目的檔 sum.ob0 當中，其內容如下所示。</p>
<p>sum.as0 的機器碼 (以 16 進位顯示)</p>
<pre><code>001F003C 002F0034 0830000A 10230000
2300000C 13112000 1B220001 26FFFFEC
011F001C 012F0014 009F0022 2A000003
12910000 2A000002 2C000000 00000000
00000000 312B2E2E 2E2B3130 3D000000
0044</code></pre>
<p>如果我們用「虛擬機 VM0」去執行上述的目的檔 sum.ob0，會看到程式的執行結果，是在 螢幕上列印出 <code>1+...+10=55</code>，以下是我們的操作過程。</p>
<pre><code>1+...+10=55</code></pre>
<h2 id="參考文獻-1"><a href="#參考文獻-1">參考文獻</a></h2>
<ul>
<li>系統程式 (陳鍾誠著, 旗標出版社) -- <a href="http://sp1.wikidot.com/main">http://sp1.wikidot.com/main</a></li>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201306/htm/article2.html">JavaScript (6) – Node.js 命令列程式設計</a></li>
</ul>
<h1 id="硬體描述語言----verilog"><a href="#硬體描述語言----verilog">硬體描述語言 -- Verilog</a></h1>
<p>Verilog 與 VHDL 都是用來設計數位電路的硬體描述語言，但 VHDL 在1983年被提出後，1987　年被美國國防部和IEEE確定為標準的硬體描述語言。</p>
<p>Verilog 是由 Gateway Design Automation 公司於 1984 年開始發展的， Cadence Design Systems 公司於 1990 年購併了 Gateway 公司，Cadence 隨後將 Verilog 提交到 Open Verilog International 成為開放公用標準，1995 年 Verilog 被 IEEE 認可成為 IEEE 1364-1995 標準，簡稱為 Verilog-95。此一標準於 2001 年更新後成為 Verilog-2001。</p>
<p>相較於 VHDL 而言，Verilog 的語法較為簡潔，因此經常被專業的數位電路設計者採用，而 VHDL 的使用族群則有較多的初學者。當我們想學習數位電路設計時，經常會難以選擇要用哪一種語言，因為 VHDL 的書籍與教材似乎 比 Verilog 多一些，但是 Verilog 的高階設計電路（像是開放原始碼 CPU 等）則比 VHDL 多很多。</p>
<p>筆者是為了要設計 CPU 而學習數位電路設計的，因此決定學習 Verilog 語言，而非 VHDL 語言。雖然筆者也學過 VHDL 語言，但後來發現 Verilog 相當好，相對而言語法簡潔了許多，因此筆者比較偏好 Verilog 語言。</p>
<p>在本文中，我們將介紹 Verilog 的基本語法，並且採用 Icarus 作為主要開發測試工具，以便讓讀者能很快的進入 Verilog 硬體設計的領域。</p>
<h2 id="verilog-基礎"><a href="#verilog-基礎">Verilog 基礎</a></h2>
<h3 id="verilog-的基本型態"><a href="#verilog-的基本型態">Verilog 的基本型態</a></h3>
<p>在一般的程式語言當中，資料的最基本型態通常是「位元」(bit)，但是在 Verilog 這種「硬體描述語言」當中， 我們必須有「面向硬體」的思考方式，因此最基本的型態從「位元」轉換為「線路」(wire)。</p>
<p>一條線路的可能值，除了 0 與 1 之外，還有可能是未定值 X ，以及高阻抗 Z，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th align="left">值</th>
<th align="left">意義</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">低電位</td>
<td align="left">布林代數中的假值</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">高電位</td>
<td align="left">布林代數中的真值</td>
</tr>
<tr class="odd">
<td align="left">Z</td>
<td align="left">高阻抗</td>
<td align="left">三態緩衝器的輸出，高阻抗斷線</td>
</tr>
<tr class="even">
<td align="left">X</td>
<td align="left">未定值</td>
<td align="left">像是線路未初始化之前，以及有 0,1 兩者衝突的線路值，或者是輸入為 Z 的輸出值</td>
</tr>
</tbody>
</table>
<p>其中的 0 對應到低電位、 1 對應到高電位，這是比較容易理解的部分，但是未定值 X 與高阻抗 Z 各代表甚麼意義呢？</p>
<p>對於一條沒有阻抗的線路而言，假如我們在某點對該線路輸出 1, 另一點對該線路輸出 0，那麼這條線路到底應該是 高電位還是低電位呢？</p>
<div class="figure">
<img src="../img/VerilogWireX.jpg" alt="圖、造成未定值 X 的情況" /><p class="caption">圖、造成未定值 X 的情況</p>
</div>
<p>對於這種衝突的情況，Verilog 採用 X 來代表該線路的值。</p>
<p>而高阻抗，則基本上是代表斷線，您可以想像該線路如果是「非導體」，例如「塑膠、木頭、開關開路、或者是處於高阻抗 情況的半導體」等，就會使用者種 Z 值來代表。</p>
<p>根據這樣的四種線路狀態，一個原本簡易的 AND 閘，在數位邏輯中只要用 <code>2*2</code> 的真值表就能表示了，但在 Verilog 當中則有 <code>4*4</code> 種可能的情況，以下是 Verilog 中各種運算 (AND, OR, XOR, XNOR) 在這四種型態上的真值表定義：</p>
<table style="border:0;width:500px;">
<tr>
<td style="border:0;">

<table>
<thead>
<tr class="header">
<th align="left">AND (&amp;)</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">X</th>
<th align="left">Z</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="odd">
<td align="left">X</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">Z</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>
</td><td style="border:0;">

<table>
<thead>
<tr class="header">
<th align="left">OR (|)</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">X</th>
<th align="left">Z</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">X</td>
<td align="left">X</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">Z</td>
<td align="left">X</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td style="border:0;">

<table>
<thead>
<tr class="header">
<th align="left">XOR(^)</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">X</th>
<th align="left">Z</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="odd">
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">Z</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>
</td><td style="border:0;">

<table>
<thead>
<tr class="header">
<th align="left">XNOR(^~)</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">X</th>
<th align="left">Z</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="odd">
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">Z</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>
</td>
</tr>
</table>

<p>在 Verilog 當中，如果我們要宣告一條線路，只要用下列語法就可以了：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> w1;</code></pre>
<p>如果我們想一次宣告很多條線路，那麼我們可以用很多個變數描述：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> w, x, y, z;</code></pre>
<p>但是如果我們想宣告一整個排線 (例如匯流排)，那我們就可以用下列的陣列語法：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] bus;</code></pre>
<p>如果想要一次宣告很多組排線，那我們就可以用下列的陣列群語法：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] bus [<span class="dv">0</span>:<span class="dv">3</span>];</code></pre>
<p>當然、除了線路之外，Verilog 還有可以穩定儲存位元的型態，稱為 reg (暫存器)，reg 可以用來 儲存位元，而非像線路一樣只是「一種連接方式」而已，以下是一些 reg 的宣告方式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">reg</span> w;                 <span class="co">// 宣告一位元的暫存器變數 w</span>
<span class="dt">reg</span> x, y, z;           <span class="co">// 宣告三個一位元的暫存器變數 x, y, z</span>
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r1;         <span class="co">// 宣告 32 位元的暫存器 r1</span>
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] R [<span class="dv">0</span>:<span class="dv">15</span>];   <span class="co">// 宣告 16 個 32 位元的暫存器群組 R[0..15]</span></code></pre>
<p>在 Verilog 中，wire 與 reg 是比較常用的基本型態，另外還有一些較不常用的基本型態， 像是 tri (三態線路)、trireg (三態暫存器)、integer (整數) 等，在此我們先不進行介紹。</p>
<h3 id="icarus-verilog-的編譯執行工具"><a href="#icarus-verilog-的編譯執行工具">Icarus ： Verilog 的編譯執行工具</a></h3>
<p>Icarus 是由 Stephen Williams 所設計的 Verilog 開發工具，採用 GPL 授權協議，並且可以在 Linux, BSD, OS X, MS Windows 等環境下執行。</p>
<p>Icarus 支援 Verilog 的 IEEE 1995、IEEE 2001 和 IEEE 2005 三種標準語法，也支援部分的 SystemVerilog 語法，其官方網站網址如下：</p>
<ul>
<li><a href="http://iverilog.icarus.com/">http://iverilog.icarus.com/</a></li>
</ul>
<p>如果您是 MS Windows 的使用者，可以從以下網址中下載 Icarus 的 MS Windows 版本，其安裝非常容易：</p>
<ul>
<li><a href="http://bleyer.org/icarus/">http://bleyer.org/icarus/</a></li>
</ul>
<h3 id="範例-1xor3-的電路"><a href="#範例-1xor3-的電路">範例 1：XOR3 的電路</a></h3>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> xor3(<span class="dt">input</span> a, b, c, <span class="dt">output</span> abc);
<span class="dt">wire</span> ab;
<span class="dt">xor</span> g1(ab, a, b);
<span class="dt">xor</span> g2(abc, c, ab);
<span class="kw">endmodule</span>

<span class="kw">module</span> xor3test;
<span class="dt">reg</span> a, b, c;
<span class="dt">wire</span> abc;

xor3 g(a,b,c, abc);

<span class="kw">initial</span>
<span class="kw">begin</span>
  a = <span class="dv">0</span>;
  b = <span class="dv">0</span>;
  c = <span class="dv">0</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  a = a<span class="dv">+1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: a=%d b=%d c=%d a^b^c=%d&quot;</span>, <span class="dt">$stime</span>, a, b, c, abc);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#100</span> <span class="kw">begin</span>
  b = b<span class="dv">+1</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#200</span> <span class="kw">begin</span>
  c = c<span class="dv">+1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>Icarus 執行結果</p>
<pre><code>D:\ccc101\icarus\ccc&gt;iverilog -o xor3test xor3test.v

D:\ccc101\icarus\ccc&gt;vvp xor3test
  50ns monitor: a=1 b=0 c=0 a^b^c=1
 100ns monitor: a=0 b=1 c=0 a^b^c=1
 150ns monitor: a=1 b=1 c=0 a^b^c=0
 200ns monitor: a=0 b=0 c=1 a^b^c=1
 250ns monitor: a=1 b=0 c=1 a^b^c=0
 300ns monitor: a=0 b=1 c=1 a^b^c=0
 350ns monitor: a=1 b=1 c=1 a^b^c=1
 400ns monitor: a=0 b=0 c=0 a^b^c=0
 450ns monitor: a=1 b=0 c=0 a^b^c=1
 500ns monitor: a=0 b=1 c=0 a^b^c=1
 550ns monitor: a=1 b=1 c=0 a^b^c=0
 600ns monitor: a=0 b=0 c=1 a^b^c=1
 650ns monitor: a=1 b=0 c=1 a^b^c=0
 700ns monitor: a=0 b=1 c=1 a^b^c=0
 750ns monitor: a=1 b=1 c=1 a^b^c=1
 800ns monitor: a=0 b=0 c=0 a^b^c=0
 850ns monitor: a=1 b=0 c=0 a^b^c=1
 900ns monitor: a=0 b=1 c=0 a^b^c=1
 950ns monitor: a=1 b=1 c=0 a^b^c=0
1000ns monitor: a=0 b=0 c=1 a^b^c=1
1050ns monitor: a=1 b=0 c=1 a^b^c=0
1100ns monitor: a=0 b=1 c=1 a^b^c=0
1150ns monitor: a=1 b=1 c=1 a^b^c=1
1200ns monitor: a=0 b=0 c=0 a^b^c=0
1250ns monitor: a=1 b=0 c=0 a^b^c=1
1300ns monitor: a=0 b=1 c=0 a^b^c=1
1350ns monitor: a=1 b=1 c=0 a^b^c=0
1400ns monitor: a=0 b=0 c=1 a^b^c=1
1450ns monitor: a=1 b=0 c=1 a^b^c=0
1500ns monitor: a=0 b=1 c=1 a^b^c=0
1550ns monitor: a=1 b=1 c=1 a^b^c=1
1600ns monitor: a=0 b=0 c=0 a^b^c=0
1650ns monitor: a=1 b=0 c=0 a^b^c=1
1700ns monitor: a=0 b=1 c=0 a^b^c=1
1750ns monitor: a=1 b=1 c=0 a^b^c=0
1800ns monitor: a=0 b=0 c=1 a^b^c=1
1850ns monitor: a=1 b=0 c=1 a^b^c=0
1900ns monitor: a=0 b=1 c=1 a^b^c=0
1950ns monitor: a=1 b=1 c=1 a^b^c=1
2000ns monitor: a=0 b=0 c=0 a^b^c=0</code></pre>
<p>仔細觀察上述輸出結果，您會發現這個結果與真值表的內容完全一致，因此驗證了該設計的正確性！</p>
<p>透過這種方式，您就可以用 Verilog 設計電路的程式，然後用 Icarus 編譯並驗證電路是否正確。</p>
<h2 id="區塊式設計"><a href="#區塊式設計">區塊式設計</a></h2>
<h3 id="閘級的線路設計方法"><a href="#閘級的線路設計方法">閘級的線路設計方法</a></h3>
<p>Verilog 既然是硬體描述語言，那當然會有邏輯閘的表示法，Verilog 提供的邏輯閘有 and, nand, or, nor, xor, xnor, not 等元件，因此您可以用下列 Verilog 程式描述一個全加器：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">or</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span></code></pre>
<p>上述程式所對應的電路如下圖所示：</p>
<div class="figure">
<img src="../img/FullAdder.jpg" alt="全加器電路圖" /><p class="caption">全加器電路圖</p>
</div>
<p>這些邏輯閘並不受限於兩個輸入，也可以是多個輸入的，例如以下範例中的 g 閘，就一次將三個輸入 a, b, c_in 進行 xor 運算，產生輸出 sum 的結果。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">xor</span> g(sum, a, b, c_in);</code></pre>
<h3 id="範例-2全加器的閘級設計"><a href="#範例-2全加器的閘級設計">範例 2：全加器的閘級設計</a></h3>
<p>傳統的數位邏輯課程當中，我們通常會用「邏輯閘」的組合方式，來設計出所要的電路，以下我們就用「全加器」當範例， 說明如何用「閘級」的語法，在 Verilog 當中設計數位電路。</p>
<p>全加器總共有 3 個輸入 (a, b, c_in)，兩個輸出值 (sum, c_out)，其真值表如下所示：</p>
<table>
<thead>
<tr class="header">
<th align="left">a</th>
<th align="left">b</th>
<th align="left">c_in</th>
<th align="left">c_out</th>
<th align="center">sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="center">0</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="center">0</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>根據這個真值表，我們可以用卡諾圖得到化簡後的電路 (但必須注意的是，卡諾圖化簡出來的電路只有 AND, OR, NOT，沒有 XOR)， 然後根據化簡後的算式繪製電路圖。(在此範例中，c_out 可以採用卡諾圖化簡出來，但 sum 使用的並非化簡的結果，而是以經驗 得到的 XOR 組合式)</p>
<p>當您完成邏輯運算式設計之後，就可以用 TinyCAD 這個軟體，繪製出全加器的電路如下圖所示：</p>
<div class="figure">
<img src="../img/FullAdder.jpg" alt="用 TinyCAD 繪製的全加器電路圖" /><p class="caption">用 TinyCAD 繪製的全加器電路圖</p>
</div>
<p>接著我們可以按照以上的線路，根據 Verilog 的語法，設計出對應元件與測試程式如下所示：</p>
<p>程式：fulladder.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 以下為全加器模組的定義</span>
<span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">or</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span>

<span class="co">// 以下為測試程式</span>
<span class="kw">module</span> main;
<span class="dt">reg</span> a, b, c_in;
<span class="dt">wire</span> sum, c_out;

fulladder fa1(a, b, c_in, sum, c_out);

<span class="kw">initial</span> <span class="kw">begin</span>
  a = <span class="dv">0</span>;  b = <span class="dv">0</span>;  c_in = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%04dns monitor: a=%d b=%d c_in=%d c_out=%d sum=%d&quot;</span>, <span class="dt">$stime</span>, a, b, c_in, c_out, sum);
  <span class="bn">#1000</span> <span class="dt">$finish</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> c_in = c_in<span class="dv">+1</span>;

<span class="kw">always</span> <span class="bn">#100</span> b = b<span class="dv">+1</span>;

<span class="kw">always</span> <span class="bn">#200</span> a = a<span class="dv">+1</span>;

<span class="kw">endmodule</span></code></pre>
<p>然後我們就可以利用 Icarus 進行編譯與測試，看看 fulladder.v 的模擬執行結果是否正確。</p>
<p>編譯執行結果：</p>
<pre><code>D:\Dropbox\Public\pmag\201306\code&gt;iverilog -o fulladder fulladder.v

D:\Dropbox\Public\pmag\201306\code&gt;vvp fulladder
0000ns monitor: a=0 b=0 c_in=0 c_out=0 sum=0
0050ns monitor: a=0 b=0 c_in=1 c_out=0 sum=1
0100ns monitor: a=0 b=1 c_in=0 c_out=0 sum=1
0150ns monitor: a=0 b=1 c_in=1 c_out=1 sum=0
0200ns monitor: a=1 b=0 c_in=0 c_out=0 sum=1
0250ns monitor: a=1 b=0 c_in=1 c_out=1 sum=0
0300ns monitor: a=1 b=1 c_in=0 c_out=1 sum=0
0350ns monitor: a=1 b=1 c_in=1 c_out=1 sum=1
0400ns monitor: a=0 b=0 c_in=0 c_out=0 sum=0
0450ns monitor: a=0 b=0 c_in=1 c_out=0 sum=1
0500ns monitor: a=0 b=1 c_in=0 c_out=0 sum=1
0550ns monitor: a=0 b=1 c_in=1 c_out=1 sum=0
0600ns monitor: a=1 b=0 c_in=0 c_out=0 sum=1
0650ns monitor: a=1 b=0 c_in=1 c_out=1 sum=0
0700ns monitor: a=1 b=1 c_in=0 c_out=1 sum=0
0750ns monitor: a=1 b=1 c_in=1 c_out=1 sum=1
0800ns monitor: a=0 b=0 c_in=0 c_out=0 sum=0
0850ns monitor: a=0 b=0 c_in=1 c_out=0 sum=1
0900ns monitor: a=0 b=1 c_in=0 c_out=0 sum=1
0950ns monitor: a=0 b=1 c_in=1 c_out=1 sum=0
1000ns monitor: a=1 b=0 c_in=0 c_out=0 sum=1</code></pre>
<p>習題 1：請證明 nand 閘是全能的 (提示：只要用 nand 做出 and, or, not 就行了) 習題 2：請用卡諾圖去化簡全加器的 Cout 電路。 習題 3：請寫一個 Verilog 程式用 nand 兜出 or 電路，並測試之。</p>
<h3 id="區塊式設計的注意事項"><a href="#區塊式設計的注意事項">區塊式設計的注意事項</a></h3>
<p>當您採用區塊式設計時，有一些常見的初學者錯誤必須注意，列舉如下：</p>
<ol style="list-style-type: decimal">
<li>assign 的指定是針對線路，而暫存器的指定必須放在 always 或 initial 區塊裏。</li>
</ol>
<p>因此，下列程式中在 assign 指定 reg 型態的變數 o1 = i1 是錯的，必須將 reg 去掉，或者改放到 always 區塊裏。</p>
<div class="figure">
<img src="../img/error1.jpg" alt="圖、在 assign 裏只能指定 wire 型態的變數，不能指定 reg 型態的" /><p class="caption">圖、在 assign 裏只能指定 wire 型態的變數，不能指定 reg 型態的</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li>相反的，always 區塊裏的指定，只能針對 reg 型態的變數進行，不能套用在線路 (wire: 含 input, output, inout) 型態的變數上。</li>
</ol>
<p>因此、下列程式當中若沒有將 o1 加上 reg 型態，則會發生錯誤。</p>
<div class="figure">
<img src="../img/error2.jpg" alt="圖、在 always 裏才能指定 reg 型態的變數" /><p class="caption">圖、在 always 裏才能指定 reg 型態的變數</p>
</div>
<ol start="3" style="list-style-type: decimal">
<li>上述的參數 output reg o1 其實是一種將暫存器與線路同時宣告的縮寫，事實上我們可以將該宣告拆開成相同名稱的兩部份 (output o1, reg o1) 或者甚至乾脆使用不同的名稱來宣告暫存器，然後再透過 assign 將線路與暫存器綁在一起，這三種寫法的意義其實都是相同的，請參考下圖：</li>
</ol>
<div class="figure">
<img src="../img/regparameter3style.jpg" alt="圖、同時具備 wire + reg 的宣告方式" /><p class="caption">圖、同時具備 wire + reg 的宣告方式</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>assign 裏面除了 指定敘述 = 與基本運算 <code>(&amp;|!^...)</code> 之外，還可以用 (cond)?case1:case2; 的這種語法。舉例而言，以下是微控制器 mcu0 裏控制單元的範例，您可以看到類似層次性 <code>if else</code> 的語法也可用這種方式在 aluop 這個語句上實現。</li>
</ol>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> control(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] op, <span class="dt">input</span> z, <span class="dt">output</span> mw, aw, pcmux, sww, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop);
  <span class="kw">assign</span> mw=(op==mcu0.ST);
  <span class="kw">assign</span> aw=(op==mcu0.LD || op==mcu0.ADD);
  <span class="kw">assign</span> sww=(op==mcu0.CMP);
  <span class="kw">assign</span> pcmux=(op==mcu0.JMP || (op==mcu0.JEQ &amp;&amp; z));
  <span class="kw">assign</span> aluop=(op==mcu0.LD)?alu0.APASS:
                 (op==mcu0.CMP)?alu0.CMP:
                   (op==mcu0.ADD)?alu0.ADD:alu0.ZERO;
<span class="kw">endmodule</span></code></pre>
<h2 id="流程式設計"><a href="#流程式設計">流程式設計</a></h2>
<p>所謂 RTL 是 Register Transfer Language 的縮寫，也就是暫存器轉換語言，這種寫法與 C, Java 等高階語言非常相似， 因此讓「程式人」也有機會透過 Verilog 設計自己的硬體。</p>
<p>舉例而言，在數位邏輯當中，多工器是一個很有用的電路，假如我們想設計一個二選一的多工器，那麼我們可以很直覺得 用以下的 RTL 寫法，去完成這樣的電路設計。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux(f, a, b, sel);
<span class="dt">output</span> f;
<span class="dt">input</span> a, b, sel;
<span class="dt">reg</span> f; <span class="co">// reg 型態會記住某些值，直到被某個 assign 指定改變為止</span>

<span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> sel) <span class="co">// 當任何變數改變的時候，會執行內部區塊</span>
  <span class="kw">if</span> (sel) f = a; <span class="co">// Always 內部的區塊採用 imperative 程式語言的寫法。</span>
  <span class="kw">else</span> f = b;
<span class="kw">endmodule</span></code></pre>
<p>對於上述程式，您還可以進一步的將參數部分化簡，將型態寫入到參數中，成為以下的形式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux(<span class="dt">output</span> <span class="dt">reg</span> f, <span class="dt">input</span> a, b, sel);
<span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> sel) <span class="co">// 當任何變數改變的時候，會執行內部區塊</span>
  <span class="kw">if</span> (sel) f = a; <span class="co">// Always 內部的區塊採用 imperative 程式語言的寫法。</span>
  <span class="kw">else</span> f = b;
<span class="kw">endmodule</span></code></pre>
<p>在 verilog 當中，if, case 等陳述一定要放在 always 或 initial 的理面，always @(cond) 代表在 cond 的 條件之下要執行該區塊，例如上述的 always @(a or b or sel) 則是在 a, b, 或 sel 有改變的時後，就必須 執行裏面的動作。</p>
<p>有時我們只希望在波型的「正邊緣」或「負邊緣」時，才執行某些動作，這時候就可以用 posedge 或 negedge 這 兩個修飾詞，例如以下的程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 當 clock 時脈在正邊緣時才執行</span>
  f = a;
<span class="kw">end</span></code></pre>
<p>而 initial 則通常是在測試程式 test bench 當中使用的，在一開始初始化的時後，可以透過 initial 設定初值， 例如以下的程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="kw">begin</span>
  clock = <span class="dv">0</span>
<span class="kw">end</span></code></pre>
<p>Verilog 程式的許多地方，都可以用 #delay 指定時間延遲，例如 #50 就是延遲 50 單位的時間 (通常一單位時間 是一奈秒 ns)。舉例而言，假如我們想要每個 50 奈秒讓 clock 變化一次，那麼我們就可以用下列寫法達到目的：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clock = ~clock; <span class="co">// 將 clock 反相 (0 變 1 、1 變 0)</span>
<span class="kw">end</span></code></pre>
<p>以上的延遲也可以寫在裡面，而不是直接寫在 always 後面，例如改用以下寫法，也能得到相同的結果。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="kw">begin</span>
  <span class="bn">#50</span>; 
  clock = ~clock; <span class="co">// 將 clock 反相 (0 變 1 、1 變 0)</span>
<span class="kw">end</span></code></pre>
<h3 id="範例-3計數器的-rtl-設計"><a href="#範例-3計數器的-rtl-設計">範例 3：計數器的 RTL 設計</a></h3>
<p>接著、讓我們用一個整合的計數器範例，來示範這些語法的實際用途，以下是我們的程式內容。</p>
<p>檔案：counter.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="co">// 定義計數器模組 counter，包含重置 reset, 時脈 clock 與暫存器 count</span>
<span class="kw">module</span> counter(<span class="dt">input</span> reset, clock, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] count); 
  <span class="kw">always</span> @(reset)                   <span class="co">// 當 reset 有任何改變時</span>
    <span class="kw">if</span> (reset) count = <span class="dv">0</span>;           <span class="co">//   如果 reset 是 1 ，就將 count 重置為 0</span>
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>     <span class="co">// 在 clock 時脈的正邊緣時</span>
    count = count + <span class="dv">1</span>;              <span class="co">//   將 count 加 1</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main; <span class="co">// 測試主程式開始</span>
<span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>] i; <span class="co">// i:計數器的輸出值</span>
<span class="dt">reg</span> reset, clock; <span class="co">// reset:重置訊號, clock:時脈</span>

<span class="co">// 宣告一個 counter 模組 c0、計數器的值透過線路 i 輸出，以便觀察。</span>
counter c0(reset, clock, i); 

<span class="kw">initial</span> <span class="kw">begin</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出  0ns: reset=x clock=x i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">1</span>; clock=<span class="dv">0</span>; <span class="co">// 10ns 之後，將啟動重置訊號，並將 clock 初值設為 0</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 10ns: reset=1 clock=0 i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">0</span>;  <span class="co">// 又經過 10ns 之後，重置完畢，將 reset 歸零</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 20ns: reset=0 clock=0 i=  0</span>
  <span class="bn">#500</span> <span class="dt">$finish</span>; <span class="co">// 再經過 500ns 之後，結束程式</span>
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#40</span> <span class="kw">begin</span> <span class="co">// 延遲 40ns 之後，開始作下列動作</span>
  clock=~clock; <span class="co">// 將時脈反轉 (0 變 1 、1 變 0)</span>
  <span class="bn">#10</span>;          <span class="co">// 再延遲 10ns 之後</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 reset, clock 與 i 等變數值</span>
<span class="kw">end</span>

<span class="kw">endmodule</span></code></pre>
<p>在上述程式中，<code>$display()</code> 函數可以用來顯示變數的內容，其作用就像 C 語言的 printf() 一樣。不過、 由於 Verilog 設計的是硬體，因此像 <code>$display()</code> 這樣前面有錢字 <code>$</code> 符號的指令，其實是不會被合成為電路的， 只是方便除錯時使用而已。</p>
<p>以下是我們用 icarus 軟體編譯並執行上述程式的過程與輸出結果：</p>
<pre><code>D:\Dropbox\Public\pmag\201307\code&gt;iverilog -o counter counter.v

D:\Dropbox\Public\pmag\201307\code&gt;vvp counter
   0ns: reset=x clock=x i=  x
  10ns: reset=1 clock=0 i=  x
  20ns: reset=0 clock=0 i=  0
  50ns: reset=0 clock=1 i=  1
 100ns: reset=0 clock=0 i=  1
 150ns: reset=0 clock=1 i=  2
 200ns: reset=0 clock=0 i=  2
 250ns: reset=0 clock=1 i=  3
 300ns: reset=0 clock=0 i=  3
 350ns: reset=0 clock=1 i=  4
 400ns: reset=0 clock=0 i=  4
 450ns: reset=0 clock=1 i=  5
 500ns: reset=0 clock=0 i=  5</code></pre>
<p>您可以看到，在一開始的時候以下的 initial 區塊會被執行，但由於此時 reset, clock, i 都尚未被賦值， 所以第一個 <code>$display()</code> 印出了代表未定值的 x 符號。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="kw">begin</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出  0ns: reset=x clock=x i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">1</span>; clock=<span class="dv">0</span>; <span class="co">// 10ns 之後，將啟動重置訊號，並將 clock 初值設為 0</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 10ns: reset=1 clock=0 i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">0</span>;  <span class="co">// 又經過 10ns 之後，重置完畢，將 reset 歸零</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 20ns: reset=0 clock=0 i=  0</span>
  <span class="bn">#500</span> <span class="dt">$finish</span>; <span class="co">// 再經過 500ns 之後，結束程式</span>
<span class="kw">end</span></code></pre>
<p>接著 <code>#10 reset = 1; clock=0</code> 指令在延遲 10ns 後，執行 reset=1; clock=0，於是後來的 <code>$display()</code> 就印出了 <code>10ns: reset=1 clock=0 i=  x</code> 的結果。</p>
<p>但是就在 reset 被設為 1 的時候，由於 reset 的值有所改變，因此下列模組中的 <code>always @(reset)</code> 被觸發了， 於是開始執行 <code>if (reset) count = 0</code> 這個陳述，將 count 暫存器設定為 0。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> counter(<span class="dt">input</span> reset, clock, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] count); 
  <span class="kw">always</span> @(reset)                   <span class="co">// 當 reset 有任何改變時</span>
    <span class="kw">if</span> (reset) count = <span class="dv">0</span>;           <span class="co">//   如果 reset 是 1 ，就將 count 重置為 0</span>
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>     <span class="co">// 在 clock 時脈的正邊緣時</span>
    count = count + <span class="dv">1</span>;              <span class="co">//   將 count 加 1</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre>
<p>然後 <code>#10 reset = 0</code> 指令又在延遲 10ns 後執行了 reset = 0，之後再用 <code>$display()</code> 時，由於 count 已經 被設定為 0，所以此時印出的結果為 <code>20ns: reset=0 clock=0 i=  0</code>。</p>
<p>initial 區塊的最後一個陳述，<code>#500 $finish</code>，會在 520ns 的時候才執行，執行時 <code>$finish</code> 會將整個測試程式 結束。</p>
<p>但在程式結束之前，以下的程式會在延遲 40ns 之後，開始將 clock 反相，然後再等待 10ns 之後用 <code>$display()</code> 印出變數內容，因此整個區塊每 50ns (=40ns+10ns) 會被執行一次。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="bn">#40</span> <span class="kw">begin</span> <span class="co">// 延遲 40ns 之後，開始作下列動作</span>
  clock=~clock; <span class="co">// 將時脈反轉 (0 變 1 、1 變 0)</span>
  <span class="bn">#10</span>;          <span class="co">// 再延遲 10ns 之後</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 reset, clock 與 i 等變數值</span>
<span class="kw">end</span></code></pre>
<p>所以、您才會看到像下面的輸出結果，如果仔細觀察，會發現 clock 每 50ns 變換一次，符合上述的程式邏輯，而且每當 clock 從 0 變成 1 的正邊緣，就會觸發 counter 模組，讓 count 變數加 1 ，並且透過線路 i 的輸出被我們觀察到。</p>
<pre><code>  50ns: reset=0 clock=1 i=  1
 100ns: reset=0 clock=0 i=  1
 150ns: reset=0 clock=1 i=  2
 200ns: reset=0 clock=0 i=  2
 250ns: reset=0 clock=1 i=  3
 300ns: reset=0 clock=0 i=  3</code></pre>
<p>(註：或許您有注意到上期當中我們用 <code>$monitor()</code> 來觀察全加器的輸出，<code>$display()</code> 與 <code>$monitor()</code> 的語法 幾乎一模一樣，但是 <code>$display()</code> 是顯示該時間點的變數內容，而 <code>$monitor()</code> 則會在受觀察的變數有改變時就 列印變數內容，兩者的的功能有明顯的差異)。</p>
<h3 id="阻塞-vs.-非阻塞-blocking-vs.-nonblocking"><a href="#阻塞-vs.-非阻塞-blocking-vs.-nonblocking">阻塞 vs. 非阻塞 (Blocking vs. Nonblocking)</a></h3>
<p>您可能會注意到在 Verilog 當中有兩種指定方式，一種用 <code>=</code> 表示，另一種用 <code>&lt;=</code> 表示，這兩種指定方法看來很類似，但意義上卻有很細緻的差異，一般 Verilog 初學者往往分不清楚，因而造成很多程式上的錯誤。</p>
<p>基本上 <code>=</code> 指令是阻塞式的 (Blocking)，因此程式會按照「循序」的方式，一個指令接著一個指令執行，就像 C 語言裏的 a=b, b=c 這樣，b=c 會在 a=b 執行完之後才執行，以下是一個範例。</p>
<p>但是 <code>&lt;=</code> 指令卻是非阻塞式的 (Nonblocking)，所以程式會採用「平行」的方式執行。舉例而言，像是 a&lt;=b, b&lt;=c 會同時執行兩者，所以 a 會取得上一輪的 b 值，而 b 則會取得上一輪的 c 值。</p>
<p>Blocking 的語法 (<code>=</code>) 通常用在「組合電路」上，也就是 <code>always @(*)</code> 語句裏面，而 Nonblocking 的語法 (<code>&lt;=</code>) 通常用在採用邊緣觸發的「循序電路」上，也就是 <code>always @(posedge clock)</code> 的語句裏面。</p>
<p>且讓我們用幾個範例來說明 blocking <code>=</code> 與 Nonblocking <code>&lt;=</code> 的差別。</p>
<p>範例 1：</p>
<table>
<tr><th>
阻塞式 (Blocking <code>=</code>)
</th><th>
非阻塞式 (Nonblocking <code>&lt;=</code>)
</th></tr>
<tr><td>

<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> c) <span class="kw">begin</span>
  a=<span class="dv">0</span>;
  b=a;
  c=b;
<span class="kw">end</span></code></pre>
<p>結果： a=b=c=0;</p>
<p>合成電路：</p>
<div class="figure">
<img src="../img/blocking1.jpg" />
</div>
</td><td>

<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> @(<span class="kw">posedge</span> clock <span class="dt">or</span> reset) <span class="kw">begin</span>
  a&lt;=<span class="dv">0</span>;
  b&lt;=a;
  c&lt;=b;
<span class="kw">end</span></code></pre>
<p>結果：a=0; b=上一輪的 a 值； c=上一輪的 b 值。</p>
<p>合成電路：</p>
<img src="../img/nonblocking1.jpg" />
</td></tr>

<tr><td>
注意：通常 blocking assignment = 會用在 always @(*) 語句裏面。
</td>
<td>
注意：通常 nonblocking assignment <code>&lt;=</code> <BR/> 會用在 always @(posedge clock or reset) 語句裏面。
</td></tr>
</table>

<h2 id="結語-1"><a href="#結語-1">結語</a></h2>
<p>有些人說在設計 Verilog 程式的時候，必須先心中有電路，才能夠設計的出來。</p>
<p>但是、從我這樣一個「程式人」的角度看來，並非如此，採用流程式的寫法也可以設計得出 Verilog 程式，不需一定要有電路圖。</p>
<p>當然、採用「流程式」寫法的話，如果是用 blocking 的 = 方式，那麼可能會造成很長的鏈狀結構，這或許會讓電路效能變差。</p>
<p>但是由於「流程式」寫法簡單又清楚，因此程式碼往往比「區塊式寫法」短，而且更容易懂，這是流程式寫法的好處。</p>
<p>當然、如果兩種寫法都會，那是最好的了，我們將在後續的章節當中陸續用完整的案例示範如何用這兩種寫法分別撰寫「開放電腦計畫」中的處理器，以便讓讀者能深入體會兩種寫法的好處與缺點。</p>
<h2 id="參考文獻-2"><a href="#參考文獻-2">參考文獻</a></h2>
<ul>
<li><a href="http://www.cnblogs.com/oomusou/archive/2011/06/25/verilog_strobe.html">(筆記) dispaly()、strobe()、monitor() 、fwrite()與blocking / nonblocking的關係</a></li>
</ul>
<h1 id="組合邏輯-combinatorial-logic"><a href="#組合邏輯-combinatorial-logic">組合邏輯 (Combinatorial Logic)</a></h1>
<h2 id="簡介-1"><a href="#簡介-1">簡介</a></h2>
<p>在數位電路當中，邏輯電路通常被分為兩類，一類是沒有「回饋線路」(No feedback) 的組合邏輯電路 (Combinatorial Logic)， 另一類是有「回饋線路」的循序邏輯電路 (Sequential Logic)。</p>
<p>組合邏輯的線路只是將輸入訊號轉換成輸出訊號，像是加法器、多工器等都是組合邏輯電路的範例，由於中間不會暫存，因此無法記憶位元。 而循序邏輯由於有回饋線路，所以可以製作出像 Flip-Flop，Latch 等記憶單元，可以記憶位元。</p>
<p>在本文中，我們將先專注在組合邏輯上，看看如何用基本的閘級寫法，寫出像多工器、加法器、減法器等組成 CPU 的基礎 電路元件。</p>
<h2 id="加法器"><a href="#加法器">加法器</a></h2>
<p>接著、讓我們用先前已經示範過的全加器範例，一個一個連接成四位元的加法器，電路圖如下所示</p>
<div class="figure">
<img src="../img/adder4.png" alt="圖、用 4 個全加器組成 4 位元加法器" /><p class="caption">圖、用 4 個全加器組成 4 位元加法器</p>
</div>
<p>上圖寫成 Verilog 就變成以下 adder4 模組的程式內容。</p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> adder4(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] c;

fulladder fa1(a[<span class="dv">0</span>],b[<span class="dv">0</span>], c_in, sum[<span class="dv">0</span>], c[<span class="dv">1</span>]) ;
fulladder fa2(a[<span class="dv">1</span>],b[<span class="dv">1</span>], c[<span class="dv">1</span>], sum[<span class="dv">1</span>], c[<span class="dv">2</span>]) ;
fulladder fa3(a[<span class="dv">2</span>],b[<span class="dv">2</span>], c[<span class="dv">2</span>], sum[<span class="dv">2</span>], c[<span class="dv">3</span>]) ;
fulladder fa4(a[<span class="dv">3</span>],b[<span class="dv">3</span>], c[<span class="dv">3</span>], sum[<span class="dv">3</span>], c_out) ;

<span class="kw">endmodule</span></code></pre>
<p>以下是完整的 4 位元加法器之 Verilog 程式。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/adder4.v">adder4.v</a></p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">xor</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> adder4(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] c;

fulladder fa1(a[<span class="dv">0</span>],b[<span class="dv">0</span>], c_in, sum[<span class="dv">0</span>], c[<span class="dv">1</span>]) ;
fulladder fa2(a[<span class="dv">1</span>],b[<span class="dv">1</span>], c[<span class="dv">1</span>], sum[<span class="dv">1</span>], c[<span class="dv">2</span>]) ;
fulladder fa3(a[<span class="dv">2</span>],b[<span class="dv">2</span>], c[<span class="dv">2</span>], sum[<span class="dv">2</span>], c[<span class="dv">3</span>]) ;
fulladder fa4(a[<span class="dv">3</span>],b[<span class="dv">3</span>], c[<span class="dv">3</span>], sum[<span class="dv">3</span>], c_out) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b;
<span class="dt">wire</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum;
<span class="dt">wire</span> c_out;

adder4 DUT (a, b, <span class="bn">1&#39;b0</span>, sum, c_out);

<span class="kw">initial</span>
<span class="kw">begin</span>
  a = <span class="bn">4&#39;b0101</span>;
  b = <span class="bn">4&#39;b0000</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  b=b<span class="dv">+1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: a=%d b=%d sum=%d&quot;</span>, <span class="dt">$stime</span>, a, b, sum);
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\ccc101\icarus\ccc&gt;iverilog -o sadd4 sadd4.v

D:\ccc101\icarus\ccc&gt;vvp sadd4
        50ns monitor: a= 5 b= 1 sum= 6
       100ns monitor: a= 5 b= 2 sum= 7
       150ns monitor: a= 5 b= 3 sum=-8
       200ns monitor: a= 5 b= 4 sum=-7
       250ns monitor: a= 5 b= 5 sum=-6
       300ns monitor: a= 5 b= 6 sum=-5
       350ns monitor: a= 5 b= 7 sum=-4
       400ns monitor: a= 5 b=-8 sum=-3
       450ns monitor: a= 5 b=-7 sum=-2
       500ns monitor: a= 5 b=-6 sum=-1
       550ns monitor: a= 5 b=-5 sum= 0
       600ns monitor: a= 5 b=-4 sum= 1
       650ns monitor: a= 5 b=-3 sum= 2
       700ns monitor: a= 5 b=-2 sum= 3
       750ns monitor: a= 5 b=-1 sum= 4
       800ns monitor: a= 5 b= 0 sum= 5
       850ns monitor: a= 5 b= 1 sum= 6
       900ns monitor: a= 5 b= 2 sum= 7
       950ns monitor: a= 5 b= 3 sum=-8
      1000ns monitor: a= 5 b= 4 sum=-7
      1050ns monitor: a= 5 b= 5 sum=-6
      1100ns monitor: a= 5 b= 6 sum=-5
      1150ns monitor: a= 5 b= 7 sum=-4
      1200ns monitor: a= 5 b=-8 sum=-3
      1250ns monitor: a= 5 b=-7 sum=-2
      1300ns monitor: a= 5 b=-6 sum=-1
      1350ns monitor: a= 5 b=-5 sum= 0
      1400ns monitor: a= 5 b=-4 sum= 1
      1450ns monitor: a= 5 b=-3 sum= 2
      1500ns monitor: a= 5 b=-2 sum= 3
      1550ns monitor: a= 5 b=-1 sum= 4
      1600ns monitor: a= 5 b= 0 sum= 5
      1650ns monitor: a= 5 b= 1 sum= 6
      1700ns monitor: a= 5 b= 2 sum= 7
      1750ns monitor: a= 5 b= 3 sum=-8
      1800ns monitor: a= 5 b= 4 sum=-7
      1850ns monitor: a= 5 b= 5 sum=-6
      1900ns monitor: a= 5 b= 6 sum=-5
      1950ns monitor: a= 5 b= 7 sum=-4
      2000ns monitor: a= 5 b=-8 sum=-3</code></pre>
<p>在上述執行結果中，您可以看到在沒有溢位的情況下，sum = a+b，但是一但加總值超過 7 之後，那就會變成負值，這也正是有號二補數表示法 溢位時會產生的結果。</p>
<h2 id="位元加法器"><a href="#位元加法器">32 位元加法器</a></h2>
<p>當然、上述的四位元加法器的範圍，只能從 -8 到 +7，這個範圍實在太小了，並不具備任何實用性，但是萬事起頭難，只要您能夠做出 四位元加法器，那麼就可以利用這個元件進行串接，將 8 個四位元加法器串接起來，立刻得到了一組 32 位元的加法器，以下是 這個 32 位元加法器的模組定義。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> adder32(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>] c;

adder4 a0(a[<span class="dv">3</span>:<span class="dv">0</span>]  ,b[<span class="dv">3</span>:<span class="dv">0</span>],   c_in, sum[<span class="dv">3</span>:<span class="dv">0</span>],  c[<span class="dv">0</span>]) ;
adder4 a1(a[<span class="dv">7</span>:<span class="dv">4</span>]  ,b[<span class="dv">7</span>:<span class="dv">4</span>],   c[<span class="dv">0</span>], sum[<span class="dv">7</span>:<span class="dv">4</span>],  c[<span class="dv">1</span>]) ;
adder4 a2(a[<span class="dv">11</span>:<span class="dv">8</span>] ,b[<span class="dv">11</span>:<span class="dv">8</span>],  c[<span class="dv">1</span>], sum[<span class="dv">11</span>:<span class="dv">8</span>], c[<span class="dv">2</span>]) ;
adder4 a3(a[<span class="dv">15</span>:<span class="dv">12</span>],b[<span class="dv">15</span>:<span class="dv">12</span>], c[<span class="dv">2</span>], sum[<span class="dv">15</span>:<span class="dv">12</span>],c[<span class="dv">3</span>]) ;
adder4 a4(a[<span class="dv">19</span>:<span class="dv">16</span>],b[<span class="dv">19</span>:<span class="dv">16</span>], c[<span class="dv">3</span>], sum[<span class="dv">19</span>:<span class="dv">16</span>],c[<span class="dv">4</span>]) ;
adder4 a5(a[<span class="dv">23</span>:<span class="dv">20</span>],b[<span class="dv">23</span>:<span class="dv">20</span>], c[<span class="dv">4</span>], sum[<span class="dv">23</span>:<span class="dv">20</span>],c[<span class="dv">5</span>]) ;
adder4 a6(a[<span class="dv">27</span>:<span class="dv">24</span>],b[<span class="dv">27</span>:<span class="dv">24</span>], c[<span class="dv">5</span>], sum[<span class="dv">27</span>:<span class="dv">24</span>],c[<span class="dv">6</span>]) ;
adder4 a7(a[<span class="dv">31</span>:<span class="dv">28</span>],b[<span class="dv">31</span>:<span class="dv">28</span>], c[<span class="dv">6</span>], sum[<span class="dv">31</span>:<span class="dv">28</span>],c_out);

<span class="kw">endmodule</span></code></pre>
<p>有了這個模組之後，您就可以寫出下列完整的程式，以測試驗證該 32 位元加法器是否正確了。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">xor</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> adder4(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] c;

fulladder fa1(a[<span class="dv">0</span>],b[<span class="dv">0</span>], c_in, sum[<span class="dv">0</span>], c[<span class="dv">1</span>]) ;
fulladder fa2(a[<span class="dv">1</span>],b[<span class="dv">1</span>], c[<span class="dv">1</span>], sum[<span class="dv">1</span>], c[<span class="dv">2</span>]) ;
fulladder fa3(a[<span class="dv">2</span>],b[<span class="dv">2</span>], c[<span class="dv">2</span>], sum[<span class="dv">2</span>], c[<span class="dv">3</span>]) ;
fulladder fa4(a[<span class="dv">3</span>],b[<span class="dv">3</span>], c[<span class="dv">3</span>], sum[<span class="dv">3</span>], c_out) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> adder32(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>] c;

adder4 a0(a[<span class="dv">3</span>:<span class="dv">0</span>]  ,b[<span class="dv">3</span>:<span class="dv">0</span>],   c_in, sum[<span class="dv">3</span>:<span class="dv">0</span>],  c[<span class="dv">0</span>]) ;
adder4 a1(a[<span class="dv">7</span>:<span class="dv">4</span>]  ,b[<span class="dv">7</span>:<span class="dv">4</span>],   c[<span class="dv">0</span>], sum[<span class="dv">7</span>:<span class="dv">4</span>],  c[<span class="dv">1</span>]) ;
adder4 a2(a[<span class="dv">11</span>:<span class="dv">8</span>] ,b[<span class="dv">11</span>:<span class="dv">8</span>],  c[<span class="dv">1</span>], sum[<span class="dv">11</span>:<span class="dv">8</span>], c[<span class="dv">2</span>]) ;
adder4 a3(a[<span class="dv">15</span>:<span class="dv">12</span>],b[<span class="dv">15</span>:<span class="dv">12</span>], c[<span class="dv">2</span>], sum[<span class="dv">15</span>:<span class="dv">12</span>],c[<span class="dv">3</span>]) ;
adder4 a4(a[<span class="dv">19</span>:<span class="dv">16</span>],b[<span class="dv">19</span>:<span class="dv">16</span>], c[<span class="dv">3</span>], sum[<span class="dv">19</span>:<span class="dv">16</span>],c[<span class="dv">4</span>]) ;
adder4 a5(a[<span class="dv">23</span>:<span class="dv">20</span>],b[<span class="dv">23</span>:<span class="dv">20</span>], c[<span class="dv">4</span>], sum[<span class="dv">23</span>:<span class="dv">20</span>],c[<span class="dv">5</span>]) ;
adder4 a6(a[<span class="dv">27</span>:<span class="dv">24</span>],b[<span class="dv">27</span>:<span class="dv">24</span>], c[<span class="dv">5</span>], sum[<span class="dv">27</span>:<span class="dv">24</span>],c[<span class="dv">6</span>]) ;
adder4 a7(a[<span class="dv">31</span>:<span class="dv">28</span>],b[<span class="dv">31</span>:<span class="dv">28</span>], c[<span class="dv">6</span>], sum[<span class="dv">31</span>:<span class="dv">28</span>],c_out);

<span class="kw">endmodule</span>


<span class="kw">module</span> main;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] a;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] b;
<span class="dt">wire</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] sum;
<span class="dt">wire</span> c_out;

adder32 DUT (a, b, <span class="dv">0</span>, sum, c_out);

<span class="kw">initial</span>
<span class="kw">begin</span>
  a = <span class="dv">60000000</span>;
  b =  <span class="dv">3789621</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: a=%d b=%d sum=%d&quot;</span>, <span class="dt">$stime</span>, a, b, sum);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  b=b<span class="dv">-1000000</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>然後、我們就可以用 icarus 進行測試，以下是測試結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o adder32 adder32.v

D:\Dropbox\Public\web\oc\code&gt;vvp adder32
         0ns monitor: a=   60000000 b=    3789621 sum=   63789621
        50ns monitor: a=   60000000 b=    2789621 sum=   62789621
       100ns monitor: a=   60000000 b=    1789621 sum=   61789621
       150ns monitor: a=   60000000 b=     789621 sum=   60789621
       200ns monitor: a=   60000000 b=    -210379 sum=   59789621
       250ns monitor: a=   60000000 b=   -1210379 sum=   58789621
       300ns monitor: a=   60000000 b=   -2210379 sum=   57789621
       350ns monitor: a=   60000000 b=   -3210379 sum=   56789621
       400ns monitor: a=   60000000 b=   -4210379 sum=   55789621
       450ns monitor: a=   60000000 b=   -5210379 sum=   54789621
       500ns monitor: a=   60000000 b=   -6210379 sum=   53789621</code></pre>
<p>您可以看到 sum 的確是 a+b 的結果，因此這個 32 位元加法器的初步驗證是正確的。</p>
<h2 id="前瞻進位加法器-carry-lookahead-adder"><a href="#前瞻進位加法器-carry-lookahead-adder">前瞻進位加法器 (Carry Lookahead Adder)</a></h2>
<div class="figure">
<img src="../img/CarryLookaheadAdder.jpg" alt="圖、4 位元前瞻進位加法器圖片來源： http://en.wikipedia.org/wiki/File:4-bit_carry_lookahead_adder.svg" /><p class="caption">圖、4 位元前瞻進位加法器<br/>圖片來源： <a href="http://en.wikipedia.org/wiki/File:4-bit_carry_lookahead_adder.svg">http://en.wikipedia.org/wiki/File:4-bit_carry_lookahead_adder.svg</a></p>
</div>
<p>檔案：cladder4.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> cladder4(<span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] S, <span class="dt">output</span> Cout,PG,GG, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] A,B, <span class="dt">input</span> Cin);
  <span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] G,P,C;

  <span class="kw">assign</span> G = A &amp; B; <span class="co">//Generate</span>
  <span class="kw">assign</span> P = A ^ B; <span class="co">//Propagate</span>
  <span class="kw">assign</span> C[<span class="dv">0</span>] = Cin;
  <span class="kw">assign</span> C[<span class="dv">1</span>] = G[<span class="dv">0</span>] | (P[<span class="dv">0</span>]&amp;C[<span class="dv">0</span>]);
  <span class="kw">assign</span> C[<span class="dv">2</span>] = G[<span class="dv">1</span>] | (P[<span class="dv">1</span>]&amp;G[<span class="dv">0</span>]) | (P[<span class="dv">1</span>]&amp;P[<span class="dv">0</span>]&amp;C[<span class="dv">0</span>]);
  <span class="kw">assign</span> C[<span class="dv">3</span>] = G[<span class="dv">2</span>] | (P[<span class="dv">2</span>]&amp;G[<span class="dv">1</span>]) | (P[<span class="dv">2</span>]&amp;P[<span class="dv">1</span>]&amp;G[<span class="dv">0</span>]) | (P[<span class="dv">2</span>]&amp;P[<span class="dv">1</span>]&amp;P[<span class="dv">0</span>]&amp;C[<span class="dv">0</span>]);
  <span class="kw">assign</span> Cout = G[<span class="dv">3</span>] | (P[<span class="dv">3</span>]&amp;G[<span class="dv">2</span>]) | (P[<span class="dv">3</span>]&amp;P[<span class="dv">2</span>]&amp;G[<span class="dv">1</span>]) | (P[<span class="dv">3</span>]&amp;P[<span class="dv">2</span>]&amp;P[<span class="dv">1</span>]&amp;G[<span class="dv">0</span>]) |(P[<span class="dv">3</span>]&amp;P[<span class="dv">2</span>]&amp;P[<span class="dv">1</span>]&amp;P[<span class="dv">0</span>]&amp;C[<span class="dv">0</span>]);
  <span class="kw">assign</span> S = P ^ C;
  <span class="kw">assign</span> PG = P[<span class="dv">3</span>] &amp; P[<span class="dv">2</span>] &amp; P[<span class="dv">1</span>] &amp; P[<span class="dv">0</span>];
  <span class="kw">assign</span> GG = G[<span class="dv">3</span>] | (P[<span class="dv">3</span>]&amp;G[<span class="dv">2</span>]) | (P[<span class="dv">3</span>]&amp;P[<span class="dv">2</span>]&amp;G[<span class="dv">1</span>]) | (P[<span class="dv">3</span>]&amp;P[<span class="dv">2</span>]&amp;P[<span class="dv">1</span>]&amp;G[<span class="dv">0</span>]);
<span class="kw">endmodule</span>


<span class="kw">module</span> main;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b;
<span class="dt">wire</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum;
<span class="dt">wire</span> c_out;

cladder4 DUT (sum, cout, pg, gg, a, b, <span class="dv">0</span>);

<span class="kw">initial</span>
<span class="kw">begin</span>
  a = <span class="dv">5</span>;
  b = -<span class="dv">3</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: a=%d b=%d sum=%d&quot;</span>, <span class="dt">$stime</span>, a, b, sum);
<span class="kw">end</span>

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o cladder4 cladder4.v

D:\Dropbox\Public\web\oc\code&gt;vvp cladder4
         0ns monitor: a= 5 b=-3 sum= 2
</code></pre>
<h2 id="結語-2"><a href="#結語-2">結語</a></h2>
<p>在本文中，我們大致將 CPU 設計當中最重要的組合邏輯電路，也就是「多工器、加法器、減法器」的設計原理說明完畢了，希望透過 Verilog 的實作方式， 能讓讀者更瞭解數位電路的設計原理，並且為接下來所要介紹的「處理器設計」進行鋪路的工作。</p>
<h2 id="參考文獻-3"><a href="#參考文獻-3">參考文獻</a></h2>
<ul>
<li><a href="http://www.ece.lsu.edu/ee3755/2002/l07.html">LSU EE 3755 -- Spring 2002 -- Computer Organization : Verilog Notes 7 -- Integer Multiply and Divide</a></li>
<li><a href="http://ccckmit.wikidot.com/ve:mux">陳鍾誠的網站：Verilog 電路設計 -- 多工器</a></li>
<li><a href="http://ccckmit.wikidot.com/ve:adder4">陳鍾誠的網站：Verilog 電路設計 -- 4 位元加法器</a></li>
<li><a href="http://ccckmit.wikidot.com/ve:addsub4">陳鍾誠的網站：Verilog 電路設計 -- 加減器</a></li>
<li><a href="http://en.wikipedia.org/wiki/Adder_(electronics)">Wikipedia:Adder</a></li>
<li><a href="http://en.wikipedia.org/wiki/Adder%E2%80%93subtractor">Wikipedia:Adder–subtractor</a></li>
<li><a href="http://en.wikipedia.org/wiki/Multiplexer">Wikipedia:Multiplexer</a></li>
</ul>
<p>【本文由陳鍾誠取材 (主要為圖片) 並修改自維基百科】</p>
<h1 id="算術邏輯單元-alu-的設計"><a href="#算術邏輯單元-alu-的設計">算術邏輯單元 ALU 的設計</a></h1>
<p>在上一章中，我們探討了「組合邏輯電路」的設計方式，採用閘級的拉線方式設計了「多工器」與「加法器」等元件， 在本章當中，我們將從加法器再度往上，探討如何設計一個 ALU 單元。</p>
<h2 id="加減器"><a href="#加減器">加減器</a></h2>
<p>我們只要把加法器，加上一組控制的互斥或閘，並控制輸入進位與否，就可以成為加減器了，這是因為我們採用了二補數的關係。</p>
<p>二補數讓我們可以很容易的延伸加法器電路就能做出減法器。我們可以在運算元 B 之前加上 2 選 1 多工器或 XOR 閘來控制 B 是否應該取補數，並且 運用 OP 控制線路來進行控制，以下是採用 2 選 1 多工器的電路做法圖。</p>
<div class="figure">
<img src="../img/addsub4-mux.png" alt="圖、採用 2 選 1 多工器控制的加減器電路" /><p class="caption">圖、採用 2 選 1 多工器控制的加減器電路</p>
</div>
<p>另一種更簡單的做法是採用 XOR 閘去控制 B 是否要取補數，如下圖所示：</p>
<div class="figure">
<img src="../img/addsub4-xor.png" alt="圖、採用 XOR 控制的加減器電路" /><p class="caption">圖、採用 XOR 控制的加減器電路</p>
</div>
<p>清楚了電路圖的布局之後，讓我們來看看如何用 Verilog 實做加減器吧！關鍵部分的程式如下所示，這個模組就對應到上述的 「採用 XOR 控制的加減器電路」之圖形。</p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> addSub4(<span class="dt">input</span> op, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, 
               <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);

<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] bop;

xor4 x1(b, {op,op,op,op}, bop);
adder4 a1(a, bop, op, sum, c_out);

<span class="kw">endmodule</span></code></pre>
<p>接著讓我們來看看完整的加減器程式與測試結果。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/addsub4.v">addsub4.v</a></p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">xor</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> adder4(<span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, <span class="dt">input</span> c_in, 
              <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);
<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] c;

fulladder fa1(a[<span class="dv">0</span>],b[<span class="dv">0</span>], c_in, sum[<span class="dv">0</span>], c[<span class="dv">1</span>]) ;
fulladder fa2(a[<span class="dv">1</span>],b[<span class="dv">1</span>], c[<span class="dv">1</span>], sum[<span class="dv">1</span>], c[<span class="dv">2</span>]) ;
fulladder fa3(a[<span class="dv">2</span>],b[<span class="dv">2</span>], c[<span class="dv">2</span>], sum[<span class="dv">2</span>], c[<span class="dv">3</span>]) ;
fulladder fa4(a[<span class="dv">3</span>],b[<span class="dv">3</span>], c[<span class="dv">3</span>], sum[<span class="dv">3</span>], c_out) ;

<span class="kw">endmodule</span>

<span class="kw">module</span> xor4(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] y);
  <span class="kw">assign</span> y = a ^ b;
<span class="kw">endmodule</span>

<span class="kw">module</span> addSub4(<span class="dt">input</span> op, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b, 
               <span class="dt">output</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">output</span> c_out);

<span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] bop;

xor4 x1(b, {op,op,op,op}, bop);
adder4 a1(a, bop, op, sum, c_out);

<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] a;
<span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] b;
<span class="dt">wire</span> <span class="dt">signed</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum;
<span class="dt">reg</span> op;
<span class="dt">wire</span> c_out;

addSub4 DUT (op, a, b, sum, c_out);

<span class="kw">initial</span>
<span class="kw">begin</span>
  a = <span class="bn">4&#39;b0101</span>;
  b = <span class="bn">4&#39;b0000</span>;
  op = <span class="bn">1&#39;b0</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  op=op<span class="dv">+1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: op=%d a=%d b=%d sum=%d&quot;</span>, <span class="dt">$stime</span>, op, a, b, sum);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#100</span> <span class="kw">begin</span>
  b=b<span class="dv">+1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\ccc101\icarus\ccc&gt;iverilog -o addSub4 addSub4.v

D:\ccc101\icarus\ccc&gt;vvp addSub4
        50ns monitor: op=1 a= 5 b= 0 sum= 5
       100ns monitor: op=0 a= 5 b= 1 sum= 6
       150ns monitor: op=1 a= 5 b= 1 sum= 4
       200ns monitor: op=0 a= 5 b= 2 sum= 7
       250ns monitor: op=1 a= 5 b= 2 sum= 3
       300ns monitor: op=0 a= 5 b= 3 sum=-8
       350ns monitor: op=1 a= 5 b= 3 sum= 2
       400ns monitor: op=0 a= 5 b= 4 sum=-7
       450ns monitor: op=1 a= 5 b= 4 sum= 1
       500ns monitor: op=0 a= 5 b= 5 sum=-6
       550ns monitor: op=1 a= 5 b= 5 sum= 0
       600ns monitor: op=0 a= 5 b= 6 sum=-5
       650ns monitor: op=1 a= 5 b= 6 sum=-1
       700ns monitor: op=0 a= 5 b= 7 sum=-4
       750ns monitor: op=1 a= 5 b= 7 sum=-2
       800ns monitor: op=0 a= 5 b=-8 sum=-3
       850ns monitor: op=1 a= 5 b=-8 sum=-3
       900ns monitor: op=0 a= 5 b=-7 sum=-2
       950ns monitor: op=1 a= 5 b=-7 sum=-4
      1000ns monitor: op=0 a= 5 b=-6 sum=-1
      1050ns monitor: op=1 a= 5 b=-6 sum=-5
      1100ns monitor: op=0 a= 5 b=-5 sum= 0
      1150ns monitor: op=1 a= 5 b=-5 sum=-6
      1200ns monitor: op=0 a= 5 b=-4 sum= 1
      1250ns monitor: op=1 a= 5 b=-4 sum=-7
      1300ns monitor: op=0 a= 5 b=-3 sum= 2
      1350ns monitor: op=1 a= 5 b=-3 sum=-8
      1400ns monitor: op=0 a= 5 b=-2 sum= 3
      1450ns monitor: op=1 a= 5 b=-2 sum= 7
      1500ns monitor: op=0 a= 5 b=-1 sum= 4
      1550ns monitor: op=1 a= 5 b=-1 sum= 6
      1600ns monitor: op=0 a= 5 b= 0 sum= 5
      1650ns monitor: op=1 a= 5 b= 0 sum= 5
      1700ns monitor: op=0 a= 5 b= 1 sum= 6
      1750ns monitor: op=1 a= 5 b= 1 sum= 4
      1800ns monitor: op=0 a= 5 b= 2 sum= 7
      1850ns monitor: op=1 a= 5 b= 2 sum= 3
      1900ns monitor: op=0 a= 5 b= 3 sum=-8
      1950ns monitor: op=1 a= 5 b= 3 sum= 2
      2000ns monitor: op=0 a= 5 b= 4 sum=-7</code></pre>
<p>在上述結果中，您可以看到當 op=0 時，電路所作的是加法運算，例如：200ns monitor: op=0 a= 5 b= 2 sum= 7。而當 op=1 時， 電路所做的是減法運算，例如：250ns monitor: op=1 a= 5 b= 2 sum= 3。</p>
<h2 id="採用-case-語法設計-alu-模組"><a href="#採用-case-語法設計-alu-模組">採用 CASE 語法設計 ALU 模組</a></h2>
<p>其實、在 Verilog 當中，我們並不需要自行設計加法器，因為 Verilog 提供了高階的 「+, -, *, /」等基本運算，可以讓我們 直接使用，更方便的是，只要搭配 case 語句，我們就可以很輕易的設計出一個 ALU 單元了。</p>
<p>以下是一個簡易的 ALU 單元之程式碼，</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 輸入 a, b 後會執行 op 所指定的運算，然後將結果放在暫存器 y 當中</span>
<span class="kw">module</span> alu(<span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] b, <span class="dt">input</span> [<span class="dv">2</span>:<span class="dv">0</span>] op, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] y);
always@(a <span class="dt">or</span> b <span class="dt">or</span> op) <span class="kw">begin</span> <span class="co">// 當 a, b 或 op 有改變時，就進入此區塊執行。</span>
  <span class="kw">case</span>(op)                  <span class="co">// 根據 op 決定要執行何種運算</span>
    <span class="bn">3&#39;b000</span>: y = a + b;      <span class="co">// op=000, 執行加法</span>
    <span class="bn">3&#39;b001</span>: y = a - b;      <span class="co">// op=000, 執行減法</span>
    <span class="bn">3&#39;b010</span>: y = a * b;      <span class="co">// op=000, 執行乘法</span>
    <span class="bn">3&#39;b011</span>: y = a / b;      <span class="co">// op=000, 執行除法</span>
    <span class="bn">3&#39;b100</span>: y = a &amp; b;      <span class="co">// op=000, 執行 AND</span>
    <span class="bn">3&#39;b101</span>: y = a | b;      <span class="co">// op=000, 執行 OR</span>
    <span class="bn">3&#39;b110</span>: y = ~a;         <span class="co">// op=000, 執行 NOT</span>
    <span class="bn">3&#39;b111</span>: y = a ^ b;      <span class="co">// op=000, 執行 XOR</span>
  <span class="kw">endcase</span>
<span class="kw">end</span>
<span class="kw">endmodule</span></code></pre>
<h3 id="verilog-語法的注意事項"><a href="#verilog-語法的注意事項">Verilog 語法的注意事項</a></h3>
<p>上述這種寫法感覺就好像在用高階寫程式一樣，這讓 ALU 的設計變得非常簡單。但是仍然需要注意以下幾點與高階語言不同之處：</p>
<h3 id="注意事項-1.-always-語句的用法"><a href="#注意事項-1.-always-語句的用法">注意事項 1. always 語句的用法</a></h3>
<p>case 等陳述句的外面一定要有 always 或 initial 語句，因為這是硬體線路，所以是採用連線 wiring 的方式，always 語句 只有在 @(trigger) 中間的 trigger 觸發條件符合時才會被觸發。</p>
<p>當 trigger 中的變數有任何改變的時候，always 語句就會被觸發，像是 always@(a or b or op) 就代表當 (a, b, op) 當中任何一個 有改變的時候，該語句就會被觸發。</p>
<p>有時我們可以在 always 語句當中加上 posedge 的條件，指定只有在「正邊緣」(上昇邊緣) 時觸發。或者加上 negedge 的條件，指定 只有在「負邊緣」(下降邊緣) 的時候觸發，例如我們可以常常在 Verilog 當中看到下列語句：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>
....
<span class="kw">end</span></code></pre>
<p>上述語句就只有在 clock 這一條線路的電波上昇邊緣會被觸發，如此我們就能更精細的控制觸發的動作，採用正邊緣或負邊緣觸發的方式。</p>
<h3 id="注意事項-2.-指定陳述的左項之限制"><a href="#注意事項-2.-指定陳述的左項之限制">注意事項 2. 指定陳述的左項之限制</a></h3>
<p>在上述程式中，a, b, op 被宣告為 input (輸入線路), 而 y 則宣告為 output reg (輸出暫存器), 在這裏必須注意的是 y 不能只宣告為 output 而不加上 reg，因為只有 reg 型態的變數才能被放在 always 區塊裡的等號左方，進行指定的動作。</p>
<p>事實上、在 Verilog 當中，像 <code>output reg [7:0] y</code> 這樣的宣告，其實也可以用比較繁雜的兩次宣告方式，一次宣告 output， 另一次則宣告 reg，如下所示：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> alu(<span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] b, <span class="dt">input</span> [<span class="dv">2</span>:<span class="dv">0</span>] op, <span class="dt">output</span> [<span class="dv">7</span>:<span class="dv">0</span>] y);
<span class="dt">reg</span> y;
always@(a <span class="dt">or</span> b <span class="dt">or</span> op) <span class="kw">begin</span>
....</code></pre>
<p>甚至，您也可以將該變數分開為兩個不同名稱，然後再利用 assign 的方式指定，如下所示：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 輸入 a, b 後會執行 op 所指定的運算，然後將結果放在暫存器 y 當中</span>
<span class="kw">module</span> alu(<span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] b, <span class="dt">input</span> [<span class="dv">2</span>:<span class="dv">0</span>] op, <span class="dt">output</span> [<span class="dv">7</span>:<span class="dv">0</span>] y);
<span class="dt">reg</span> ty;
always@(a <span class="dt">or</span> b <span class="dt">or</span> op) <span class="kw">begin</span> <span class="co">// 當 a, b 或 op 有改變時，就進入此區塊執行。</span>
  <span class="kw">case</span>(op)                  <span class="co">// 根據 op 決定要執行何種運算</span>
    <span class="bn">3&#39;b000</span>: ty = a + b;      <span class="co">// op=000, 執行加法</span>
    <span class="bn">3&#39;b001</span>: ty = a - b;      <span class="co">// op=000, 執行減法</span>
    <span class="bn">3&#39;b010</span>: ty = a * b;      <span class="co">// op=000, 執行乘法</span>
    <span class="bn">3&#39;b011</span>: ty = a / b;      <span class="co">// op=000, 執行除法</span>
    <span class="bn">3&#39;b100</span>: ty = a &amp; b;      <span class="co">// op=000, 執行 AND</span>
    <span class="bn">3&#39;b101</span>: ty = a | b;      <span class="co">// op=000, 執行 OR</span>
    <span class="bn">3&#39;b110</span>: ty = ~a;         <span class="co">// op=000, 執行 NOT</span>
    <span class="bn">3&#39;b111</span>: ty = a ^ b;      <span class="co">// op=000, 執行 XOR</span>
  <span class="kw">endcase</span>
  <span class="dt">$display</span>(<span class="st">&quot;base 10 : %dns : op=%d a=%d b=%d y=%d&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的 10 進位值。</span>
  <span class="dt">$display</span>(<span class="st">&quot;base  2 : %dns : op=%b a=%b b=%b y=%b&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的  2 進位值。</span>
<span class="kw">end</span>
<span class="kw">assign</span> y=ty;
<span class="kw">endmodule</span></code></pre>
<p>在上述程式中，由於只有 reg 型態的變數可以放在 always 區塊內的等號左邊，因此我們必須用 reg 型態的 ty 去儲存 運算結果。</p>
<p>但是在 assign 指令的等號左邊，則不需要是暫存器型態的變數，也可以是線路型態的變數，因此我們可以用 assign y=ty 這樣一個指令去將 ty 的暫存器內容輸出。</p>
<p>事實上，assign 語句代表的是一種「不需儲存的立即輸出接線」，因此我們才能將 output 型態的變數寫在等號左邊啊！</p>
<h2 id="完整的-alu-設計-含測試程式"><a href="#完整的-alu-設計-含測試程式">完整的 ALU 設計 (含測試程式)</a></h2>
<p>瞭解了這些 Verilog 語法特性之後，我們就可以搭配測試程式，對這個　ALU 模組進行測試，以下是完整的程式碼：</p>
<p>檔案：<a href="../code/alu.v">alu.v</a></p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 輸入 a, b 後會執行 op 所指定的運算，然後將結果放在暫存器 y 當中</span>
<span class="kw">module</span> alu(<span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">7</span>:<span class="dv">0</span>] b, <span class="dt">input</span> [<span class="dv">2</span>:<span class="dv">0</span>] op, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] y);
always@(a <span class="dt">or</span> b <span class="dt">or</span> op) <span class="kw">begin</span> <span class="co">// 當 a, b 或 op 有改變時，就進入此區塊執行。</span>
  <span class="kw">case</span>(op)                  <span class="co">// 根據 op 決定要執行何種運算</span>
    <span class="bn">3&#39;b000</span>: y = a + b;      <span class="co">// op=000, 執行加法</span>
    <span class="bn">3&#39;b001</span>: y = a - b;      <span class="co">// op=000, 執行減法</span>
    <span class="bn">3&#39;b010</span>: y = a * b;      <span class="co">// op=000, 執行乘法</span>
    <span class="bn">3&#39;b011</span>: y = a / b;      <span class="co">// op=000, 執行除法</span>
    <span class="bn">3&#39;b100</span>: y = a &amp; b;      <span class="co">// op=000, 執行 AND</span>
    <span class="bn">3&#39;b101</span>: y = a | b;      <span class="co">// op=000, 執行 OR</span>
    <span class="bn">3&#39;b110</span>: y = ~a;         <span class="co">// op=000, 執行 NOT</span>
    <span class="bn">3&#39;b111</span>: y = a ^ b;      <span class="co">// op=000, 執行 XOR</span>
  <span class="kw">endcase</span>
  <span class="dt">$display</span>(<span class="st">&quot;base 10 : %dns : op=%d a=%d b=%d y=%d&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的 10 進位值。</span>
  <span class="dt">$display</span>(<span class="st">&quot;base  2 : %dns : op=%b a=%b b=%b y=%b&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的  2 進位值。</span>
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
 <span class="dt">reg</span>  [<span class="dv">7</span>:<span class="dv">0</span>] a, b;           <span class="co">// 宣告 a, b 為 8 位元暫存器</span>
 <span class="dt">wire</span>  [<span class="dv">7</span>:<span class="dv">0</span>] y;             <span class="co">// 宣告 y 為 8 位元線路</span>
 <span class="dt">reg</span>  [<span class="dv">2</span>:<span class="dv">0</span>] op;             <span class="co">// 宣告 op 為 3 位元暫存器</span>

 alu alu1(a, b, op, y);     <span class="co">// 建立一個 alu 單元，名稱為 alu1</span>

 <span class="kw">initial</span> <span class="kw">begin</span>              <span class="co">// 測試程式的初始化動作</span>
  a = <span class="bn">8&#39;h07</span>;                <span class="co">// 設定 a 為數值 7</span>
  b = <span class="bn">8&#39;h03</span>;                <span class="co">// 設定 b 為數值 3</span>
  op = <span class="bn">3&#39;b000</span>;              <span class="co">// 設定 op 的初始值為 000</span>
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>           <span class="co">// 每個 50 奈秒就作下列動作</span>
   op = op + <span class="dv">1</span>;             <span class="co">// 讓 op 的值加 1</span>
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;      <span class="co">// 時間到 1000 奈秒就結束</span>

<span class="kw">endmodule</span></code></pre>
<p>在上述程式中，為了更清楚的印出 ALU 的輸出結果，我們在 ALU 模組的結尾放入以下的兩行 <code>$display()</code> 指令， 以便同時顯示 (op, a, b, y) 等變數的 10 進位與 2 進位結果值，方便讀者觀察。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">  <span class="dt">$display</span>(<span class="st">&quot;base 10 : %dns : op=%d a=%d b=%d y=%d&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的 10 進位值。</span>
  <span class="dt">$display</span>(<span class="st">&quot;base  2 : %dns : op=%b a=%b b=%b y=%b&quot;</span>, <span class="dt">$stime</span>, op, a, b, y); <span class="co">// 印出 op, a, b, y 的  2 進位值。</span></code></pre>
<h3 id="測試執行結果"><a href="#測試執行結果">測試執行結果</a></h3>
<p>上述程式的執行測試結果如下：</p>
<pre><code>D:\Dropbox\Public\pmag\201310\code&gt;iverilog -o alu alu.v

D:\Dropbox\Public\pmag\201310\code&gt;vvp alu
base 10 :          0ns : op=0 a=  7 b=  3 y= 10
base  2 :          0ns : op=000 a=00000111 b=00000011 y=00001010
base 10 :         50ns : op=1 a=  7 b=  3 y=  4
base  2 :         50ns : op=001 a=00000111 b=00000011 y=00000100
base 10 :        100ns : op=2 a=  7 b=  3 y= 21
base  2 :        100ns : op=010 a=00000111 b=00000011 y=00010101
base 10 :        150ns : op=3 a=  7 b=  3 y=  2
base  2 :        150ns : op=011 a=00000111 b=00000011 y=00000010
base 10 :        200ns : op=4 a=  7 b=  3 y=  3
base  2 :        200ns : op=100 a=00000111 b=00000011 y=00000011
base 10 :        250ns : op=5 a=  7 b=  3 y=  7
base  2 :        250ns : op=101 a=00000111 b=00000011 y=00000111
base 10 :        300ns : op=6 a=  7 b=  3 y=248
base  2 :        300ns : op=110 a=00000111 b=00000011 y=11111000
base 10 :        350ns : op=7 a=  7 b=  3 y=  4
base  2 :        350ns : op=111 a=00000111 b=00000011 y=00000100
base 10 :        400ns : op=0 a=  7 b=  3 y= 10
base  2 :        400ns : op=000 a=00000111 b=00000011 y=00001010
base 10 :        450ns : op=1 a=  7 b=  3 y=  4
base  2 :        450ns : op=001 a=00000111 b=00000011 y=00000100
base 10 :        500ns : op=2 a=  7 b=  3 y= 21
base  2 :        500ns : op=010 a=00000111 b=00000011 y=00010101
base 10 :        550ns : op=3 a=  7 b=  3 y=  2
base  2 :        550ns : op=011 a=00000111 b=00000011 y=00000010
base 10 :        600ns : op=4 a=  7 b=  3 y=  3
base  2 :        600ns : op=100 a=00000111 b=00000011 y=00000011
base 10 :        650ns : op=5 a=  7 b=  3 y=  7
base  2 :        650ns : op=101 a=00000111 b=00000011 y=00000111
base 10 :        700ns : op=6 a=  7 b=  3 y=248
base  2 :        700ns : op=110 a=00000111 b=00000011 y=11111000
base 10 :        750ns : op=7 a=  7 b=  3 y=  4
base  2 :        750ns : op=111 a=00000111 b=00000011 y=00000100
base 10 :        800ns : op=0 a=  7 b=  3 y= 10
base  2 :        800ns : op=000 a=00000111 b=00000011 y=00001010
base 10 :        850ns : op=1 a=  7 b=  3 y=  4
base  2 :        850ns : op=001 a=00000111 b=00000011 y=00000100
base 10 :        900ns : op=2 a=  7 b=  3 y= 21
base  2 :        900ns : op=010 a=00000111 b=00000011 y=00010101
base 10 :        950ns : op=3 a=  7 b=  3 y=  2
base  2 :        950ns : op=011 a=00000111 b=00000011 y=00000010
base 10 :       1000ns : op=4 a=  7 b=  3 y=  3</code></pre>
<h3 id="執行結果分析"><a href="#執行結果分析">執行結果分析</a></h3>
<p>您可以看到一開始 0ns 時，op=0，所以執行加法，得到 y=a+b=7+3=10，然後 50ns 時 op=1，所以執行減法， 以下是整個執行結果的簡化列表：</p>
<table>
<thead>
<tr class="header">
<th align="left">a</th>
<th align="left">b</th>
<th align="left">op</th>
<th align="left">y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">7</td>
<td align="left">3</td>
<td align="left">0 (+)</td>
<td align="left">10</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">3</td>
<td align="left">1 (-)</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left">3</td>
<td align="left">2 (*)</td>
<td align="left">21</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">3</td>
<td align="left">3 (/)</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">00000111</td>
<td align="left">00000011</td>
<td align="left">4 (AND)</td>
<td align="left">00000011</td>
</tr>
<tr class="even">
<td align="left">00000111</td>
<td align="left">00000011</td>
<td align="left">5 (OR)</td>
<td align="left">00000111</td>
</tr>
<tr class="odd">
<td align="left">00000111</td>
<td align="left">00000011</td>
<td align="left">6 (NOT)</td>
<td align="left">11111000</td>
</tr>
<tr class="even">
<td align="left">00000111</td>
<td align="left">00000011</td>
<td align="left">6 (XOR)</td>
<td align="left">00000100</td>
</tr>
</tbody>
</table>
<p>透過上述的測試，我們知道整個 ALU 的設計方式是正確的。</p>
<h2 id="結語-3"><a href="#結語-3">結語</a></h2>
<p>對於沒有學過「硬體描述語言」的人來說，通常會認為要設計一個 ALU 單元，應該是很複雜的。但是從上述的程式當中，您可以看到 在 Verilog 當中設計 ALU 其實是很簡單的，只要用 10 行左右的程式碼，甚至不需要自己設計「加法器」就能完成。</p>
<p>這是因為 Verilog 將 <code>「+, -, *, /」</code> 等運算內建在語言當中了，所以讓整個程式的撰寫只要透過一個 case 語句就能做完了， 這種設計方式非常的像「高階語言」，讓硬體的設計變得更加的容易了。</p>
<p>事實上，在使用 Verilog 設計像 CPU 這樣的複雜元件時，ALU 或暫存器等單元都變得非常的容易。真正複雜的其實是控制單元， 而這也是 CPU 設計的精髓之所在，我們會在「開放電腦計劃」系列的文章中，完成 CPU 與控制單元的設計。</p>
<h2 id="參考文獻-4"><a href="#參考文獻-4">參考文獻</a></h2>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:alu">陳鍾誠的網站：用 Verilog 設計 ALU</a></li>
</ul>
<h1 id="記憶單元-memory-unit"><a href="#記憶單元-memory-unit">記憶單元 (Memory Unit)</a></h1>
<h2 id="時序邏輯-sequential-logic"><a href="#時序邏輯-sequential-logic">時序邏輯 (Sequential Logic)</a></h2>
<p>組合邏輯 (Combinatorial Logic) 是一種沒有回饋線路的數位電路系統，而循序邏輯 (時序邏輯, Sequential Logic) 則是一種包含回饋線路的系統。</p>
<p>舉例而言，在下圖 (a) 的全加器的電路裏，您可以看到從輸入線路一路輸入接向輸出，這種稱為組合邏輯電路。而在下圖 (b) 的 栓鎖器 (正反器) 線路裏，線路從輸出 Q 又拉回 S 做為輸入，這種有倒勾的線路就稱為循序邏輯電路。</p>
<div class="figure">
<img src="../img/CombSeqCircuitCompare.jpg" />
</div>
<p>暫存器、靜態記憶體等記憶單元，都是由這種有反饋電路的時序邏輯所構成的，因此要瞭解記憶單元之前，先瞭解時序邏輯的 電路結構會是有幫助的。</p>
<h2 id="正反器-閂鎖器"><a href="#正反器-閂鎖器">正反器 (閂鎖器)</a></h2>
<p>正反器有很多種型式，以下是來自維基百科的一些正反器說明與範例。</p>
<ul>
<li>參考：<a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics)">http://en.wikipedia.org/wiki/Flip-flop_(electronics)</a></li>
</ul>
<blockquote>
<p>摘自維基百科：正反器（英語：Flip-flop, FF，中國大陸譯作觸發器，港澳譯作），學名雙穩態多諧振盪器（Bistable Multivibrator）， 是一種應用在數位電路上具有記憶功能的循序邏輯元件，可記錄二進位制數位訊號「1」和「0」。 正反器是構成序向邏輯電路以及各種複雜數位系統的基本邏輯單元。</p>
</blockquote>
<div class="figure">
<img src="../img/flop_flop.png" alt="圖、各種正反器" /><p class="caption">圖、各種正反器</p>
</div>
<h2 id="sr-正反器"><a href="#sr-正反器">SR 正反器</a></h2>
<p>正反器是可以用來儲存位元，是循序電路的基礎，以下是一個用 NAND 閘構成的正反器。</p>
<div class="figure">
<img src="../img/nandLatch.png" alt="圖、NAND 閘構成的正反器" /><p class="caption">圖、NAND 閘構成的正反器</p>
</div>
<p>我們可以根據上圖實作出對應的 Verilog 程式如下：</p>
<p>檔案：latch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> Sbar, Rbar;
<span class="dt">wire</span> Q, Qbar;

latch latch1(Sbar, Rbar, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: Sbar=%d Rbar=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, Sbar, Rbar, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;latch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  Sbar = <span class="dv">0</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  Sbar = <span class="dv">1</span>; Rbar = <span class="dv">0</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\verilog&gt;iverilog -o latch latch.v

D:\verilog&gt;vvp latch
VCD info: dumpfile latch.vcd opened for output.
   0ns monitor: Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 100ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 150ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 250ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 300ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0
 350ns monitor: Sbar=1 Rbar=0 Q=0 Qbar=1
 450ns monitor: Sbar=0 Rbar=1 Q=1 Qbar=0
 500ns monitor: Sbar=1 Rbar=1 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/latchWave.jpg" alt="圖、latch.vcd 的顯示圖形" /><p class="caption">圖、latch.vcd 的顯示圖形</p>
</div>
<h2 id="有-enable-的正反器"><a href="#有-enable-的正反器">有 enable 的正反器</a></h2>
<p>如果我們在上述正反器前面再加上兩個 NAND 閘進行控制，就可以形成一組有 enable 的正反器，以下是該正反器的圖形。</p>
<div class="figure">
<img src="../img/enLatch.jpg" alt="圖、有 enable 的正反器" /><p class="caption">圖、有 enable 的正反器</p>
</div>
<p>根據上述圖形我們可以設計出以下的 Verilog 程式。</p>
<p>檔案：enLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, en, R;
<span class="dt">wire</span> Q, Qbar;

enLatch enLatch1(en, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: en=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, en, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;enLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  en = <span class="dv">1</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>
  en = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o enLatch enLatch.v

D:\verilog&gt;vvp enLatch
VCD info: dumpfile enLatch.vcd opened for output.
   0ns monitor: en=x Sbar=x Rbar=x Q=x Qbar=x
  50ns monitor: en=1 Sbar=x Rbar=x Q=x Qbar=x
 100ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 150ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 200ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 250ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 300ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 350ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 400ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 450ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 500ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 550ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
 600ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 650ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 700ns monitor: en=0 Sbar=1 Rbar=0 Q=0 Qbar=1
 750ns monitor: en=0 Sbar=0 Rbar=0 Q=0 Qbar=1
 800ns monitor: en=0 Sbar=0 Rbar=1 Q=0 Qbar=1
 850ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1
 900ns monitor: en=1 Sbar=1 Rbar=0 Q=1 Qbar=0
 950ns monitor: en=1 Sbar=0 Rbar=0 Q=1 Qbar=0
1000ns monitor: en=1 Sbar=0 Rbar=1 Q=0 Qbar=1</code></pre>
<div class="figure">
<img src="../img/enLatchWave.jpg" alt="圖、enLatch.vcd 的顯示圖形" /><p class="caption">圖、enLatch.vcd 的顯示圖形</p>
</div>
<h2 id="閘級延遲-gate-delay"><a href="#閘級延遲-gate-delay">閘級延遲 (Gate Delay)</a></h2>
<p>在 Verilog 模型下，邏輯閘預設是沒有任何延遲的，因此呈現出來永遠是即時的結果，但現實世界的電路 總是有少許延遲的，每經過一個閘就會延遲一點點的時間，經過的閘數越多，延遲也就會越久。</p>
<ul>
<li>參考： <a href="http://www.asic-world.com/verilog/gate3.html">http://www.asic-world.com/verilog/gate3.html</a></li>
</ul>
<p>為了模擬這種延遲，Verilog 允許你在閘上面附加延遲時間的語法，您可以分別指定最小延遲 min，典型延遲 typical 與最大延遲 max。</p>
<p>舉例而言，以下的語法宣告了一個 not 閘，其中的 <code>#(1:3:5)</code> 語法指定了最小延遲 min=1, 典型延遲 typical=3, 最大延遲 max=5。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="dt">not</span> #(<span class="dv">1</span>:<span class="dv">3</span>:<span class="dv">5</span>) n2(nclk2, clk);</code></pre>
<p>假如您不想分別指定這三種延遲，也可以只指定一個延遲參數，這樣 min, typical, max 三者都會設定為該數值， 舉例而言，以下是一個宣告延遲固定為 2 的 not 閘。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="dt">not</span> <span class="bn">#2</span> n1(nclk1, clk);</code></pre>
<p>為了說明這種延遲狀況，我們寫了一個範例程式 delay.v 來示範設定了閘級延遲的效果，請參考下列程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> main;
 <span class="dt">reg</span> clk;

 <span class="dt">not</span> <span class="bn">#2</span> n1(nclk1, clk);
 <span class="dt">not</span> #(<span class="dv">1</span>:<span class="dv">3</span>:<span class="dv">5</span>) n2(nclk2, clk);

 <span class="kw">initial</span> <span class="kw">begin</span>
   clk = <span class="dv">0</span>;
   <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: clk=%b nclk1=%d nclk2=%d&quot;</span>, <span class="dt">$stime</span>, clk, nclk1, nclk2);
   <span class="dt">$dumpfile</span>(<span class="st">&quot;delay.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
   <span class="dt">$dumpvars</span>;
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
   clk = clk + <span class="dv">1</span>;
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o delay delay.v
delay.v:5: warning: choosing typ expression.

D:\Dropbox\Public\web\oc\code&gt;vvp delay
VCD info: dumpfile delay.vcd opened for output.
         0ns monitor: clk=0 nclk1=z nclk2=z
         2ns monitor: clk=0 nclk1=1 nclk2=z
         3ns monitor: clk=0 nclk1=1 nclk2=1
        10ns monitor: clk=1 nclk1=1 nclk2=1
        12ns monitor: clk=1 nclk1=0 nclk2=1
        13ns monitor: clk=1 nclk1=0 nclk2=0
        20ns monitor: clk=0 nclk1=0 nclk2=0
        22ns monitor: clk=0 nclk1=1 nclk2=0
        23ns monitor: clk=0 nclk1=1 nclk2=1
        30ns monitor: clk=1 nclk1=1 nclk2=1
        32ns monitor: clk=1 nclk1=0 nclk2=1
        33ns monitor: clk=1 nclk1=0 nclk2=0
        40ns monitor: clk=0 nclk1=0 nclk2=0
        42ns monitor: clk=0 nclk1=1 nclk2=0
        43ns monitor: clk=0 nclk1=1 nclk2=1
        50ns monitor: clk=1 nclk1=1 nclk2=1
        52ns monitor: clk=1 nclk1=0 nclk2=1
        53ns monitor: clk=1 nclk1=0 nclk2=0
        60ns monitor: clk=0 nclk1=0 nclk2=0
        62ns monitor: clk=0 nclk1=1 nclk2=0
        63ns monitor: clk=0 nclk1=1 nclk2=1
        70ns monitor: clk=1 nclk1=1 nclk2=1
        72ns monitor: clk=1 nclk1=0 nclk2=1
        73ns monitor: clk=1 nclk1=0 nclk2=0
        80ns monitor: clk=0 nclk1=0 nclk2=0
        82ns monitor: clk=0 nclk1=1 nclk2=0
        83ns monitor: clk=0 nclk1=1 nclk2=1
        90ns monitor: clk=1 nclk1=1 nclk2=1
        92ns monitor: clk=1 nclk1=0 nclk2=1
        93ns monitor: clk=1 nclk1=0 nclk2=0
       100ns monitor: clk=0 nclk1=0 nclk2=0</code></pre>
<p>以上輸出的波形如下，您可以看到 nclk1 的延遲固定為 2 ，而 nclk2 的延遲則介於 1 到 5 之間。</p>
<div class="figure">
<img src="../img/delayGTKwave.jpg" alt="圖、delay.vcd 的顯示波型" /><p class="caption">圖、delay.vcd 的顯示波型</p>
</div>
<h2 id="利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd"><a href="#利用閘級延遲製作脈波變化偵測器-pulse-transition-detector-ptd">利用「閘級延遲」製作脈波變化偵測器 (Pulse Transition Detector, PTD)</a></h2>
<p>雖然延遲現象看起來像是個缺陷，但事實上如果好好的利用這種現象，有時反而可以達到很好的效果， 「脈波變化偵測器」電路就是利用這種現象所設計的一種電路，可以用來偵測「脈波的上升邊緣或下降邊緣」。</p>
<p>以下是「脈波變化偵測電路」的圖形，其中的關鍵是在 左邊的 not 閘身上，由於每個閘都會造成延遲，因此多了 not 閘的那條路徑所造成的延遲較多，這讓輸出部份會因為延遲而形成一個脈衝波形。</p>
<div class="figure">
<img src="../img/ptd.jpg" alt="圖、脈波變化偵測器" /><p class="caption">圖、脈波變化偵測器</p>
</div>
<p>以下是這個電路以 Verilog 實作的結果。</p>
<p>檔案：ptd.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span> <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span> <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
 <span class="dt">reg</span> clk;
 <span class="dt">wire</span> p;

 ptd ptd1(clk, p);

 <span class="kw">initial</span> <span class="kw">begin</span>
   clk = <span class="dv">0</span>;
   <span class="dt">$monitor</span>(<span class="st">&quot;%dns monitor: clk=%b p=%d&quot;</span>, <span class="dt">$stime</span>, clk, p);
   <span class="dt">$dumpfile</span>(<span class="st">&quot;ptd.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
   <span class="dt">$dumpvars</span>;
 <span class="kw">end</span>

 <span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
   clk = clk + <span class="dv">1</span>;
 <span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\pmag\201311\code&gt;iverilog -o ptd ptd.v

D:\Dropbox\Public\pmag\201311\code&gt;vvp ptd
VCD info: dumpfile ptd.vcd opened for output.
         0ns monitor: clk=0 p=z
         4ns monitor: clk=0 p=0
        50ns monitor: clk=1 p=0
        54ns monitor: clk=1 p=1
        56ns monitor: clk=1 p=0
       100ns monitor: clk=0 p=0
       150ns monitor: clk=1 p=0
       154ns monitor: clk=1 p=1
       156ns monitor: clk=1 p=0
       200ns monitor: clk=0 p=0
       250ns monitor: clk=1 p=0
       254ns monitor: clk=1 p=1
       256ns monitor: clk=1 p=0
       300ns monitor: clk=0 p=0
       350ns monitor: clk=1 p=0
       354ns monitor: clk=1 p=1
       356ns monitor: clk=1 p=0
       400ns monitor: clk=0 p=0
       450ns monitor: clk=1 p=0
       454ns monitor: clk=1 p=1
       456ns monitor: clk=1 p=0
       500ns monitor: clk=0 p=0</code></pre>
<div class="figure">
<img src="../img/ptdWave.jpg" alt="圖、ptd.vcd 的顯示圖形" /><p class="caption">圖、ptd.vcd 的顯示圖形</p>
</div>
<h2 id="使用脈衝偵測電路製作邊緣觸發正反器"><a href="#使用脈衝偵測電路製作邊緣觸發正反器">使用「脈衝偵測電路」製作「邊緣觸發正反器」</a></h2>
<p>有了「正反器」與「脈波變化偵測電路」之後，我們就可以組合出「邊緣觸發正反器」了，以下是其電路圖。</p>
<div class="figure">
<img src="../img/ptdLatch.jpg" alt="圖、邊緣觸發的正反器" /><p class="caption">圖、邊緣觸發的正反器</p>
</div>
<p>事實上，上述電路圖只是將「有 enable 的正反器」前面加上一個「脈波變化偵測電路」而已，其實做的 Verilog 程式如下。</p>
<p>檔案：ptdLatch.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> latch(<span class="dt">input</span> Sbar, Rbar, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> LS(Q, Sbar, Qbar);
  <span class="dt">nand</span> LR(Qbar, Rbar, Q);
<span class="kw">endmodule</span>

<span class="kw">module</span> enLatch(<span class="dt">input</span> en, S, R, <span class="dt">output</span> Q, Qbar);
  <span class="dt">nand</span> ES(Senbar, en, S);
  <span class="dt">nand</span> ER(Renbar, en, R);
  latch L1(Senbar, Renbar, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span>  <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span>  <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> ptdLatch(<span class="dt">input</span> clk, S, R, <span class="dt">output</span> Q, Qbar);
  ptd PTD(clk, ppulse);
  enLatch EL(ppulse, S, R, Q, Qbar);
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> S, clk, R;
<span class="dt">wire</span> Q, Qbar;

ptdLatch ptdLatch1(clk, S, R, Q, Qbar);

<span class="kw">initial</span>
<span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d ppulse=%d S=%d R=%d Q=%d Qbar=%d&quot;</span>, <span class="dt">$stime</span>, clk, ptdLatch1.ppulse, S, R, Q, Qbar);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;ptdLatch.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span>
  clk = ~clk;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  S = <span class="dv">1</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">0</span>;
  <span class="bn">#50</span>;
  S = <span class="dv">0</span>; R = <span class="dv">1</span>;
  <span class="bn">#50</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#500</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\verilog&gt;iverilog -o ptdLatch ptdLatch.v

D:\verilog&gt;vvp ptdLatch
VCD info: dumpfile ptdLatch.vcd opened for output.
   0ns monitor: clk=0 ppulse=z S=x R=x Q=x Qbar=x
   4ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  20ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  24ns monitor: clk=1 ppulse=1 S=x R=x Q=x Qbar=x
  26ns monitor: clk=1 ppulse=0 S=x R=x Q=x Qbar=x
  40ns monitor: clk=0 ppulse=0 S=x R=x Q=x Qbar=x
  50ns monitor: clk=0 ppulse=0 S=1 R=0 Q=x Qbar=x
  60ns monitor: clk=1 ppulse=0 S=1 R=0 Q=x Qbar=x
  64ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
  66ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
  80ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 100ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 104ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 106ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 120ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 140ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 144ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 146ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 150ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 160ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 180ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 184ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 186ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 200ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 220ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 224ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 226ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 240ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 250ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 260ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 264ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 266ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 280ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 300ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 304ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 306ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 320ns monitor: clk=0 ppulse=0 S=0 R=0 Q=1 Qbar=0
 340ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 344ns monitor: clk=1 ppulse=1 S=0 R=0 Q=1 Qbar=0
 346ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0
 350ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 360ns monitor: clk=0 ppulse=0 S=0 R=1 Q=1 Qbar=0
 380ns monitor: clk=1 ppulse=0 S=0 R=1 Q=1 Qbar=0
 384ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 386ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 400ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 420ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 424ns monitor: clk=1 ppulse=1 S=0 R=1 Q=0 Qbar=1
 426ns monitor: clk=1 ppulse=0 S=0 R=1 Q=0 Qbar=1
 440ns monitor: clk=0 ppulse=0 S=0 R=1 Q=0 Qbar=1
 450ns monitor: clk=0 ppulse=0 S=1 R=0 Q=0 Qbar=1
 460ns monitor: clk=1 ppulse=0 S=1 R=0 Q=0 Qbar=1
 464ns monitor: clk=1 ppulse=1 S=1 R=0 Q=1 Qbar=0
 466ns monitor: clk=1 ppulse=0 S=1 R=0 Q=1 Qbar=0
 480ns monitor: clk=0 ppulse=0 S=1 R=0 Q=1 Qbar=0
 500ns monitor: clk=1 ppulse=0 S=0 R=0 Q=1 Qbar=0</code></pre>
<div class="figure">
<img src="../img/ptdLatchWave.jpg" alt="圖、ptdLatch.vcd 的顯示圖形" /><p class="caption">圖、ptdLatch.vcd 的顯示圖形</p>
</div>
<h2 id="使用脈衝偵測電路設計邊緣觸發暫存器"><a href="#使用脈衝偵測電路設計邊緣觸發暫存器">使用「脈衝偵測電路」設計邊緣觸發暫存器</a></h2>
<p>有了「脈波變化偵測電路」，只要與任何需要偵測脈波變化的元件串接起來，就可以達到「邊緣觸發」的功能。</p>
<p>其實、像是 Verilog 當中的以下程式，其實都是利用類似的「脈波變化偵測電路」所完成的。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>
  ...
  <span class="kw">end</span></code></pre>
<p>如果我們真的不想使用 <code>posedge clock</code> 這種語法，我們也可以用前述的 「脈波變化偵測電路」(PTD) 來 製作這類的邊緣觸發功能，以下是我們用這種方式設計的一個邊緣觸發暫存器。</p>
<p>檔案： ptdRegister.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);

<span class="dt">not</span> <span class="bn">#2</span> g1(nclkd, clk);
<span class="dt">nand</span> <span class="bn">#2</span> g2(npulse, nclkd, clk);
<span class="dt">not</span> <span class="bn">#2</span> g3(ppulse, npulse);

<span class="kw">endmodule</span>

<span class="kw">module</span> register(<span class="dt">input</span> en, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] d, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r);
<span class="kw">always</span> @(en) <span class="kw">begin</span>
  <span class="kw">if</span> (en)
    r &lt;= d;
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] d;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] r;
<span class="dt">reg</span> clk;
<span class="dt">wire</span> en;

ptd ptd1(clk, en);
register register1(en, d, r);

<span class="kw">initial</span> <span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  d = <span class="dv">3</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d d=%d r=%d&quot;</span>, <span class="dt">$stime</span>, clk, en, d, r);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span>
  d = d + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o ptdRegister ptdRegister.v

D:\Dropbox\Public\web\oc\code&gt;vvp ptdRegister
   0ns monitor: clk=0 en=z d=         3 r=         x
   4ns monitor: clk=0 en=0 d=         3 r=         x
  10ns monitor: clk=1 en=0 d=         3 r=         x
  14ns monitor: clk=1 en=1 d=         3 r=         3
  16ns monitor: clk=1 en=0 d=         3 r=         3
  20ns monitor: clk=0 en=0 d=         4 r=         3
  30ns monitor: clk=1 en=0 d=         4 r=         3
  34ns monitor: clk=1 en=1 d=         4 r=         4
  36ns monitor: clk=1 en=0 d=         4 r=         4
  40ns monitor: clk=0 en=0 d=         5 r=         4
  50ns monitor: clk=1 en=0 d=         5 r=         4
  54ns monitor: clk=1 en=1 d=         5 r=         5
  56ns monitor: clk=1 en=0 d=         5 r=         5
  60ns monitor: clk=0 en=0 d=         6 r=         5
  70ns monitor: clk=1 en=0 d=         6 r=         5
  74ns monitor: clk=1 en=1 d=         6 r=         6
  76ns monitor: clk=1 en=0 d=         6 r=         6
  80ns monitor: clk=0 en=0 d=         7 r=         6
  90ns monitor: clk=1 en=0 d=         7 r=         6
  94ns monitor: clk=1 en=1 d=         7 r=         7
  96ns monitor: clk=1 en=0 d=         7 r=         7
 100ns monitor: clk=0 en=0 d=         8 r=         7</code></pre>
<p>其輸出的波型檔如下圖所示：</p>
<div class="figure">
<img src="../img/GTKWavePtdRegister.jpg" alt="圖、在 GTKWave 中顯示的 ptdRegister.vcd 波型檔" /><p class="caption">圖、在 GTKWave 中顯示的 ptdRegister.vcd 波型檔</p>
</div>
<h2 id="使用脈衝偵測電路製作計數電路"><a href="#使用脈衝偵測電路製作計數電路">使用「脈衝偵測電路」製作計數電路</a></h2>
<p>如果我們將暫存器的輸出在接到一個加法電路上，進行回饋性的累加的動作，如下圖所示，那麼整個電路就會變成 一個邊緣觸發的計數電路</p>
<div class="figure">
<img src="../img/ptdCounterCircuit.jpg" alt="圖、邊緣觸發的計數電路" /><p class="caption">圖、邊緣觸發的計數電路</p>
</div>
<p>以上這種電路可以做為「採用區塊方法設計 CPU 的基礎」，因為 CPU 當中的「程式計數器」 (Program Counter) 通常會採用 這種邊緣觸發的設計方式。</p>
<p>以下是上述電路的設計與實作測試結果。</p>
<p>檔案： ptdCounter.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> register(<span class="dt">input</span> en, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] d, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r);
<span class="kw">always</span> @(en) <span class="kw">begin</span>
  <span class="kw">if</span> (en)
    r &lt;= d;
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> ptd(<span class="dt">input</span> clk, <span class="dt">output</span> ppulse);
  <span class="dt">not</span>  <span class="bn">#2</span> P1(nclkd, clk);
  <span class="dt">nand</span> <span class="bn">#2</span> P2(npulse, nclkd, clk);
  <span class="dt">not</span>  <span class="bn">#2</span> P3(ppulse, npulse);
<span class="kw">endmodule</span>

<span class="kw">module</span> inc(<span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] i, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] o);
  <span class="kw">assign</span> o = i + <span class="dv">4</span>;
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] r, ro;
<span class="dt">reg</span> clk;
<span class="dt">wire</span> en;

ptd ptd1(clk, en);
register r1(en, ro, r);
inc i1(r, ro);

<span class="kw">initial</span> <span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  r1.r = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d r=%d&quot;</span>, <span class="dt">$stime</span>, clk, en, r);
  <span class="dt">$dumpfile</span>(<span class="st">&quot;ptdCounter.vcd&quot;</span>); <span class="co">// 輸出給 GTK wave 顯示波型</span>
  <span class="dt">$dumpvars</span>;    
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#100</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o ptdCounter ptdCounter.v

D:\Dropbox\Public\web\oc\code&gt;vvp ptdCounter
VCD info: dumpfile ptdCounter.vcd opened for output.
   0ns monitor: clk=0 en=z r=         0
   4ns monitor: clk=0 en=0 r=         0
  10ns monitor: clk=1 en=0 r=         0
  14ns monitor: clk=1 en=1 r=         4
  16ns monitor: clk=1 en=0 r=         4
  20ns monitor: clk=0 en=0 r=         4
  30ns monitor: clk=1 en=0 r=         4
  34ns monitor: clk=1 en=1 r=         8
  36ns monitor: clk=1 en=0 r=         8
  40ns monitor: clk=0 en=0 r=         8
  50ns monitor: clk=1 en=0 r=         8
  54ns monitor: clk=1 en=1 r=        12
  56ns monitor: clk=1 en=0 r=        12
  60ns monitor: clk=0 en=0 r=        12
  70ns monitor: clk=1 en=0 r=        12
  74ns monitor: clk=1 en=1 r=        16
  76ns monitor: clk=1 en=0 r=        16
  80ns monitor: clk=0 en=0 r=        16
  90ns monitor: clk=1 en=0 r=        16
  94ns monitor: clk=1 en=1 r=        20
  96ns monitor: clk=1 en=0 r=        20
 100ns monitor: clk=0 en=0 r=        20</code></pre>
<p>其輸出的波型檔如下圖所示：</p>
<div class="figure">
<img src="../img/GTKWavePtdCounter.jpg" alt="圖、在 GTKWave 中顯示的 ptdCounter.vcd 波型檔" /><p class="caption">圖、在 GTKWave 中顯示的 ptdCounter.vcd 波型檔</p>
</div>
<h2 id="暫存器單元"><a href="#暫存器單元">暫存器單元</a></h2>
<p>檔案：regbank.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> regbank(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra1, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd1, 
               <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra2, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd2,
               <span class="dt">input</span> clk, <span class="dt">input</span> w_en, 
               <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] wa, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] wd);
 <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r[<span class="dv">15</span>:<span class="dv">0</span>]; <span class="co">// 宣告 16 個 32 位元的暫存器</span>
 <span class="kw">assign</span> rd1 = r[ra1]; <span class="co">// 讀取索引值為 ra1 的暫存器</span>
 <span class="kw">assign</span> rd2 = r[ra2]; <span class="co">// 讀取索引值為 ra2 的暫存器</span>
 <span class="kw">always</span> @(<span class="kw">posedge</span> clk)
 <span class="kw">begin</span>
  <span class="kw">if</span> (w_en) <span class="co">// w_en=1 時寫入到暫存器</span>
    r[wa] &lt;= wd; <span class="co">// 將 wd 寫入到索引值為 wa 的暫存器</span>
 <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra1, ra2, wa;
<span class="dt">reg</span> clk, w_en;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] rd1, rd2;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] wd;

regbank rb0(ra1, rd1, ra2, rd2, clk, w_en, wa, wd);

<span class="kw">initial</span>
<span class="kw">begin</span>
  wa = <span class="dv">0</span>;
  ra1 = <span class="dv">0</span>;
  ra2 = <span class="dv">0</span>;
  wd = <span class="dv">0</span>;
  clk = <span class="dv">0</span>;
  w_en = <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#200</span> ra1 = <span class="dv">0</span>;

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clk = clk + <span class="dv">1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: ra1=%d rd1=%d ra2=%d rd2=%d wa=%d wd=%d&quot;</span>, 
           <span class="dt">$stime</span>, ra1, rd1, ra2, rd2, wa, wd);
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#100</span> <span class="kw">begin</span>
  wa = wa + <span class="dv">1</span>;
  wd = wd + <span class="dv">2</span>;
  ra1 = ra1 + <span class="dv">1</span>;
  ra2 = ra2 - <span class="dv">1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code\verilog&gt;iverilog -o regbank regbank.v

D:\Dropbox\Public\web\oc\code\verilog&gt;vvp regbank
  50ns monitor: ra1= 0 rd1=         0 ra2= 0 rd2=         0 wa= 0 wd=         0
 100ns monitor: ra1= 1 rd1=         x ra2=15 rd2=         x wa= 1 wd=         2
 150ns monitor: ra1= 1 rd1=         2 ra2=15 rd2=         x wa= 1 wd=         2
 200ns monitor: ra1= 1 rd1=         2 ra2=14 rd2=         x wa= 2 wd=         4
 250ns monitor: ra1= 1 rd1=         2 ra2=14 rd2=         x wa= 2 wd=         4
 300ns monitor: ra1= 2 rd1=         4 ra2=13 rd2=         x wa= 3 wd=         6
 350ns monitor: ra1= 2 rd1=         4 ra2=13 rd2=         x wa= 3 wd=         6
 400ns monitor: ra1= 3 rd1=         6 ra2=12 rd2=         x wa= 4 wd=         8
 450ns monitor: ra1= 3 rd1=         6 ra2=12 rd2=         x wa= 4 wd=         8
 500ns monitor: ra1= 4 rd1=         8 ra2=11 rd2=         x wa= 5 wd=        10
 550ns monitor: ra1= 4 rd1=         8 ra2=11 rd2=         x wa= 5 wd=        10
 600ns monitor: ra1= 5 rd1=        10 ra2=10 rd2=         x wa= 6 wd=        12
 650ns monitor: ra1= 5 rd1=        10 ra2=10 rd2=         x wa= 6 wd=        12
 700ns monitor: ra1= 6 rd1=        12 ra2= 9 rd2=         x wa= 7 wd=        14
 750ns monitor: ra1= 6 rd1=        12 ra2= 9 rd2=         x wa= 7 wd=        14
 800ns monitor: ra1= 7 rd1=        14 ra2= 8 rd2=         x wa= 8 wd=        16
 850ns monitor: ra1= 7 rd1=        14 ra2= 8 rd2=        16 wa= 8 wd=        16
 900ns monitor: ra1= 8 rd1=        16 ra2= 7 rd2=        14 wa= 9 wd=        18
 950ns monitor: ra1= 8 rd1=        16 ra2= 7 rd2=        14 wa= 9 wd=        18
1000ns monitor: ra1= 9 rd1=        18 ra2= 6 rd2=        12 wa=10 wd=        20</code></pre>
<h2 id="記憶體"><a href="#記憶體">記憶體</a></h2>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> memory(<span class="dt">input</span> clock, reset, en, rw, 
                <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] abus, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] dbus_in, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] dbus_out);
    <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">128</span>];
    <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] data;

    <span class="kw">always</span> @(clock <span class="dt">or</span> reset <span class="dt">or</span> abus <span class="dt">or</span> en <span class="dt">or</span> rw <span class="dt">or</span> dbus_in) 
    <span class="kw">begin</span>
        <span class="kw">if</span> (reset == <span class="dv">1</span>) <span class="kw">begin</span>
            {m[<span class="dv">0</span>],m[<span class="dv">1</span>],m[<span class="dv">2</span>],m[<span class="dv">3</span>]}     = <span class="bn">32&#39;h002F000C</span>; <span class="co">// 0000           LD   R2, K0</span>
            {m[<span class="dv">4</span>],m[<span class="dv">5</span>],m[<span class="dv">6</span>],m[<span class="dv">7</span>]}     = <span class="bn">32&#39;h001F000C</span>; <span class="co">// 0004           LD   R1, K1</span>
            {m[<span class="dv">8</span>],m[<span class="dv">9</span>],m[<span class="dv">10</span>],m[<span class="dv">11</span>]}   = <span class="bn">32&#39;h13221000</span>; <span class="co">// 0008 LOOP:     ADD  R2, R2, R1</span>
            {m[<span class="dv">12</span>],m[<span class="dv">13</span>],m[<span class="dv">14</span>],m[<span class="dv">15</span>]} = <span class="bn">32&#39;h26FFFFF8</span>; <span class="co">// 000C           JMP  LOOP</span>
            {m[<span class="dv">16</span>],m[<span class="dv">17</span>],m[<span class="dv">18</span>],m[<span class="dv">19</span>]} = <span class="bn">32&#39;h00000000</span>; <span class="co">// 0010 K0:        WORD 0</span>
            {m[<span class="dv">20</span>],m[<span class="dv">21</span>],m[<span class="dv">22</span>],m[<span class="dv">23</span>]} = <span class="bn">32&#39;h00000001</span>; <span class="co">// 0014 K1:        WORD 1</span>
            data = <span class="bn">32&#39;hZZZZZZZZ</span>; 
        <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span> (abus &gt;=<span class="dv">0</span> &amp;&amp; abus &lt; <span class="dv">128</span>) <span class="kw">begin</span>
            <span class="kw">if</span> (en == <span class="dv">1</span> &amp;&amp; rw == <span class="dv">0</span>) <span class="co">// r_w==0:write</span>
            <span class="kw">begin</span>
                data = dbus_in;
                {m[abus], m[abus<span class="dv">+1</span>], m[abus<span class="dv">+2</span>], m[abus<span class="dv">+3</span>]} = dbus_in;
            <span class="kw">end</span>
            <span class="kw">else</span> <span class="kw">if</span> (en == <span class="dv">1</span> &amp;&amp; rw == <span class="dv">1</span>) <span class="co">// r_w==1:read</span>
                data = {m[abus], m[abus<span class="dv">+1</span>], m[abus<span class="dv">+2</span>], m[abus<span class="dv">+3</span>]};
            <span class="kw">else</span>
                data = <span class="bn">32&#39;hZZZZZZZZ</span>;
        <span class="kw">end</span> <span class="kw">else</span>
            data = <span class="bn">32&#39;hZZZZZZZZ</span>;
    <span class="kw">end</span>
    <span class="kw">assign</span> dbus_out = data;
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> clock, reset, en, rw;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] addr;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] data_in;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] data_out;

memory DUT (.clock(clock), .reset(reset), .en(en), .rw(rw), 
   .abus(addr), .dbus_in(data_in), .dbus_out(data_out));

<span class="kw">initial</span> <span class="co">// reset：設定 memory 內容為 0,1,2,....,127</span>
<span class="kw">begin</span>
  clock = <span class="dv">0</span>;
  reset = <span class="dv">1</span>;
  en = <span class="dv">0</span>;
  rw = <span class="dv">1</span>; <span class="co">// rw=1:讀取模式</span>
  <span class="bn">#75</span>;
  en = <span class="dv">1</span>;
  reset = <span class="dv">0</span>;
  addr = <span class="dv">0</span>;
  <span class="bn">#500</span>;
  addr = <span class="dv">4</span>;
  rw = <span class="dv">0</span>; <span class="co">// 寫入模式</span>
  data_in = <span class="bn">8&#39;h3A</span>;
  <span class="bn">#100</span>;
  addr = <span class="dv">0</span>;
  rw = <span class="dv">1</span>; <span class="co">// 讀取模式</span>
  data_in = <span class="dv">0</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clock = clock + <span class="dv">1</span>; 
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: clk=%d en=%d rw=%d, addr=%8h din=%8h dout=%8h&quot;</span>, 
           <span class="dt">$stime</span>, clock, en, rw, addr, data_in, data_out);  
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#200</span> 
<span class="kw">begin</span>
 addr=addr<span class="dv">+1</span>;
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code\verilog&gt;iverilog -o memory32 memory32.v

D:\Dropbox\Public\web\oc\code\verilog&gt;vvp memory32
  50ns monitor: clk=1 en=0 rw=1, addr=xxxxxxxx din=xxxxxxxx dout=zzzzzzzz
  75ns monitor: clk=1 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 100ns monitor: clk=0 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 150ns monitor: clk=1 en=1 rw=1, addr=00000000 din=xxxxxxxx dout=002f000c
 200ns monitor: clk=0 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 250ns monitor: clk=1 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 300ns monitor: clk=0 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 350ns monitor: clk=1 en=1 rw=1, addr=00000001 din=xxxxxxxx dout=2f000c00
 400ns monitor: clk=0 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 450ns monitor: clk=1 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 500ns monitor: clk=0 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 550ns monitor: clk=1 en=1 rw=1, addr=00000002 din=xxxxxxxx dout=000c001f
 575ns monitor: clk=1 en=1 rw=0, addr=00000004 din=0000003a dout=0000003a
 600ns monitor: clk=0 en=1 rw=0, addr=00000005 din=0000003a dout=0000003a
 650ns monitor: clk=1 en=1 rw=0, addr=00000005 din=0000003a dout=0000003a
 675ns monitor: clk=1 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 700ns monitor: clk=0 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 750ns monitor: clk=1 en=1 rw=1, addr=00000000 din=00000000 dout=002f000c
 800ns monitor: clk=0 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 850ns monitor: clk=1 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 900ns monitor: clk=0 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
 950ns monitor: clk=1 en=1 rw=1, addr=00000001 din=00000000 dout=2f000c00
1000ns monitor: clk=0 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1050ns monitor: clk=1 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1100ns monitor: clk=0 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1150ns monitor: clk=1 en=1 rw=1, addr=00000002 din=00000000 dout=000c0000
1200ns monitor: clk=0 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1250ns monitor: clk=1 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1300ns monitor: clk=0 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1350ns monitor: clk=1 en=1 rw=1, addr=00000003 din=00000000 dout=0c000000
1400ns monitor: clk=0 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1450ns monitor: clk=1 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1500ns monitor: clk=0 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1550ns monitor: clk=1 en=1 rw=1, addr=00000004 din=00000000 dout=00000000
1600ns monitor: clk=0 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1650ns monitor: clk=1 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1700ns monitor: clk=0 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1750ns monitor: clk=1 en=1 rw=1, addr=00000005 din=00000000 dout=0000003a
1800ns monitor: clk=0 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1850ns monitor: clk=1 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1900ns monitor: clk=0 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
1950ns monitor: clk=1 en=1 rw=1, addr=00000006 din=00000000 dout=00003a22
2000ns monitor: clk=0 en=1 rw=1, addr=00000007 din=00000000 dout=003a2210</code></pre>
<h2 id="結語-4"><a href="#結語-4">結語</a></h2>
<p>在本章中，我們介紹了正反器 (Flip-Flop, Latch, 栓鎖器) 等循序電路的概念，並且利用閘級延遲的現象， 設計出了「脈衝偵測電路」(Pause Transition Detector, PTD)，於是我們可以利用「脈衝偵測電路」 設計出像「邊緣觸發型」的電路，像是「邊緣觸發型」的正反器、暫存器、計數器等等電路， 這些電路是構成電腦當中的記憶線路的基礎。</p>
<p>一但理解這些基礎原理之後，我們就可以用 Verilog 的高階語法直接宣告「暫存器、一群暫存器與 一整塊記憶體」，這種高階寫法已經非常接近高階語言的寫法，只是由於是設計硬體，所以這些高階指令 最後都會被轉換為線路，燒錄到 FPGA 或內建於 ASIC 裡面而已，如此我們就不需要用一條一條的線路去 兜出暫存器或記憶體，可以輕鬆的透過 Verilog 設計出記憶單元了。</p>
<h1 id="控制單元"><a href="#控制單元">控制單元</a></h1>
<h2 id="簡介-2"><a href="#簡介-2">簡介</a></h2>
<p>如果您曾經用硬接線的方式設計過 CPU，那就會發現「控制單元」主要就是一堆「開關」與「多工器」的接線。</p>
<p>開關可以用來控制某些資料是否要流過，而多工器則可以從很多組輸入資料中選擇一組輸出，以下是一個四選一多工器的方塊圖。</p>
<div class="figure">
<img src="../img/mux.png" alt="圖、4 選 1 多工器" /><p class="caption">圖、4 選 1 多工器</p>
</div>
<p>4 選 1 多工器的內部電路結構如下：</p>
<div class="figure">
<img src="../img/mux4to1.png" alt="圖、4 選 1 多工器的內部電路" /><p class="caption">圖、4 選 1 多工器的內部電路</p>
</div>
<p>接著、就讓我們來看一個完整的 Verilog 的 4 選 1 的多工器程式，由於 Verilog 支援像 Case 這樣的高階語法，因此在實作時 可以不需要採用細部的接線方式，只要使用 case 語句就可以輕易完成多工器的設計。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/mux.v">mux4.v</a></p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux4(<span class="dt">input</span>[<span class="dv">1</span>:<span class="dv">0</span>]  select, <span class="dt">input</span>[<span class="dv">3</span>:<span class="dv">0</span>] d, <span class="dt">output</span> <span class="dt">reg</span> q );
<span class="kw">always</span> @( select <span class="dt">or</span> d )
<span class="kw">begin</span>
   <span class="kw">case</span>( select )
       <span class="dv">0</span> : q = d[<span class="dv">0</span>];
       <span class="dv">1</span> : q = d[<span class="dv">1</span>];
       <span class="dv">2</span> : q = d[<span class="dv">2</span>];
       <span class="dv">3</span> : q = d[<span class="dv">3</span>];
   <span class="kw">endcase</span>
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] d;
<span class="dt">reg</span> [<span class="dv">1</span>:<span class="dv">0</span>] s;
<span class="dt">wire</span> q;

mux4 DUT (s, d, q);

<span class="kw">initial</span>
<span class="kw">begin</span>
  s = <span class="dv">0</span>;
  d = <span class="bn">4&#39;b0110</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  s=s<span class="dv">+1</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns monitor: s=%d d=%d q=%d&quot;</span>, <span class="dt">$stime</span>, s, d, q);
<span class="kw">end</span>

<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\ccc101\icarus&gt;iverilog mux4.v -o mux4

D:\ccc101\icarus&gt;vvp mux4
  50ns monitor: s=1 d= 6 q=1
 100ns monitor: s=2 d= 6 q=1
 150ns monitor: s=3 d= 6 q=0
 200ns monitor: s=0 d= 6 q=0
 250ns monitor: s=1 d= 6 q=1
 300ns monitor: s=2 d= 6 q=1
 350ns monitor: s=3 d= 6 q=0
 400ns monitor: s=0 d= 6 q=0
 450ns monitor: s=1 d= 6 q=1
 500ns monitor: s=2 d= 6 q=1
 550ns monitor: s=3 d= 6 q=0
 600ns monitor: s=0 d= 6 q=0
 650ns monitor: s=1 d= 6 q=1
 700ns monitor: s=2 d= 6 q=1
 750ns monitor: s=3 d= 6 q=0
 800ns monitor: s=0 d= 6 q=0
 850ns monitor: s=1 d= 6 q=1
 900ns monitor: s=2 d= 6 q=1
 950ns monitor: s=3 d= 6 q=0
1000ns monitor: s=0 d= 6 q=0</code></pre>
<p>您可以看到在上述範例中，輸入資料 6 的二進位是 0110，如下所示：</p>
<pre><code>       位置 s  3 2 1 0
       位元 d  0 1 1 0</code></pre>
<p>因此當 s=0 時會輸出 0, s=1 時會輸出 1, s=2 時會輸出 1, s=3 時會輸出 0，這就是上述輸出結果的意義。</p>
<p>但是、這種採用多工器硬的接線方式，必須搭配區塊式的設計，才能建構出 CPU，但是這種方式較為困難，因此 我們留待後續章節再來介紹。為了簡單起見，我們會先採用流程式的設計方法。</p>
<h2 id="流程式設計-1"><a href="#流程式設計-1">流程式設計</a></h2>
<p>傳統上、當您設計出「ALU、暫存器」等基本元件之後，就可以設計控制單元，去控制這些「基本元件」，形成一顆 CPU。</p>
<p>但是、在 Verilog 當中， 「+, -, *, /, 暫存器」等都是基本語法，因此整個 CPU 的設計其實就是一個控制單元的設計而已，我們只要在適當的時候呼叫 「+, -, *, /」運算與「暫存器讀取寫入」功能，就能設計完一顆 CPU 了。</p>
<p>換句話說，只要在 Verilog 中設計出控制單元，基本上就已經設計完成整顆 CPU 了，因為「+, -, *, /, 暫存器」等元件都已經內建了。</p>
<p>以下是我們用流程法設計 mcu0 微處理器的重要程式片段，您可以看到在這種作法上，整個處理器就僅僅是一個「控制單元」，而這個「控制單元」的責任就是根據「擷取、解碼、執行」的流程，操控暫存器的流向與運算。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> cpu(<span class="dt">input</span> clock);
  ...
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
      IR = {m[PC], m[PC<span class="dv">+1</span>]};  <span class="co">// 指令擷取階段：IR=m[PC], 2 個 Byte 的記憶體</span>
      pc0= PC;                <span class="co">// 儲存舊的 PC 值在 pc0 中。</span>
      PC = PC<span class="dv">+2</span>;              <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
      <span class="kw">case</span> (<span class="ot">`OP</span>)              <span class="co">// 解碼、根據 OP 執行動作</span>
        <span class="dv">LD:</span> A = <span class="ot">`M</span>;           <span class="co">// LD C</span>
        <span class="dv">ST:</span> <span class="ot">`M</span> = A;           <span class="co">// ST C</span>
        <span class="dv">CMP:</span> <span class="kw">begin</span> <span class="ot">`N</span>=(A &lt; <span class="ot">`M</span>); <span class="ot">`Z</span>=(A==<span class="ot">`M</span>); <span class="kw">end</span> <span class="co">// CMP C</span>
        <span class="dv">ADD:</span> A = A + <span class="ot">`M</span>;      <span class="co">// ADD C</span>
        <span class="dv">JMP:</span> PC = <span class="ot">`C</span>;         <span class="co">// JMP C</span>
        <span class="dv">JEQ:</span> <span class="kw">if</span> (<span class="ot">`Z</span>) PC=<span class="ot">`C</span>;   <span class="co">// JEQ C</span>
        ...
      <span class="kw">endcase</span>
      <span class="co">// 印出 PC, IR, SW, A 等暫存器值以供觀察</span>
      <span class="dt">$display</span>(<span class="st">&quot;%4dns PC=%x IR=%x, SW=%x, A=%d&quot;</span>, <span class="dt">$stime</span>, pc0, IR, SW, A); 
  <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre>
<h2 id="區塊式設計-1"><a href="#區塊式設計-1">區塊式設計</a></h2>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mcu(<span class="dt">input</span> clock);
  ...
  register#(.W(<span class="dv">12</span>)) PC(clock, <span class="dv">1</span>, pci, pco);
  adder#(.W(<span class="dv">12</span>)) adder0(<span class="dv">2</span>, pco, pcnext);
  memory mem(mw, <span class="ot">`C</span>, ao, pco, ir, <span class="ot">`C</span>, mo);
  register#(.W(<span class="dv">16</span>)) A(~clock, aw, aluout, ao);
  register#(.W(<span class="dv">16</span>)) SW(~clock, sww, aluout, swo);
  alu alu0(aluop, mo, ao, aluout);
  mux#(.W(<span class="dv">12</span>)) muxpc(pcmux, pcnext, <span class="ot">`C</span>, pci);
  control cu(<span class="ot">`OP</span>, <span class="ot">`Z</span>, mw, aw, pcmux, sww, aluop);
  ...
<span class="kw">endmodule</span></code></pre>
<h3 id="以流程法設計控制單元"><a href="#以流程法設計控制單元">以流程法設計控制單元</a></h3>
<p>然而、當指令愈來愈多，系統愈來愈複雜時，區塊式的設計方法就會愈來愈困難，此時有兩種解決方式，一種是採用流程式的設計法來撰寫控制單元，操控各種「開關與多工器」。這種設計方法混合了「區塊式與流程式」的設計方法，算是一種折衷性的方法。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> control(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] op, <span class="dt">input</span> z, <span class="dt">output</span> mw, aw, pcmux, sww, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop);
  <span class="dt">reg</span> mw, aw, pcmux, sww;
  <span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop;
  <span class="kw">always</span> @(op) <span class="kw">begin</span>
    mw = <span class="dv">0</span>;
    aw = <span class="dv">0</span>;
    sww = <span class="dv">0</span>;
    pcmux = <span class="dv">0</span>;
    aluop = alu0.ZERO;
    <span class="kw">case</span> (op)
      mcu0.LD: <span class="kw">begin</span> aw=<span class="dv">1</span>; aluop=alu0.APASS; <span class="kw">end</span>     <span class="co">// LD C</span>
      mcu0.ST: mw=<span class="dv">1</span>;                                 <span class="co">// ST C</span>
      mcu0.JMP: pcmux=<span class="dv">1</span>;                             <span class="co">// JMP C</span>
      mcu0.JEQ: <span class="kw">if</span> (<span class="ot">`Z</span>) pcmux=<span class="dv">1</span>;                     <span class="co">// JEQ C</span>
      mcu0.CMP: <span class="kw">begin</span> sww=<span class="dv">1</span>; aluop = alu0.CMP; <span class="kw">end</span>   <span class="co">// CMP C</span>
      mcu0.ADD: <span class="kw">begin</span> aw=<span class="dv">1</span>; aluop=alu0.ADD; <span class="kw">end</span>      <span class="co">// ADD C</span>
    <span class="kw">endcase</span>
  <span class="kw">end</span>  
<span class="kw">endmodule</span></code></pre>
<h3 id="以區塊法設計控制單元"><a href="#以區塊法設計控制單元">以區塊法設計控制單元</a></h3>
<p>當然、我們也可以將上述的控制訊號硬是用 and, or, not 等方式寫下來，這樣就能將整個設計完全「區塊化」，而去掉「流程式」的寫法了。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> control(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] op, <span class="dt">input</span> z, <span class="dt">output</span> mw, aw, pcmux, sww, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop);
  <span class="kw">assign</span> mw=(op==mcu0.ST);
  <span class="kw">assign</span> aw=(op==mcu0.LD || op==mcu0.ADD);
  <span class="kw">assign</span> sww=(op==mcu0.CMP);
  <span class="kw">assign</span> pcmux=(op==mcu0.JMP || (op==mcu0.JEQ &amp;&amp; z));
  <span class="kw">assign</span> aluop=(op==mcu0.LD)?alu0.APASS:(op==mcu0.CMP)?alu0.CMP:(op==mcu0.ADD)?alu0.ADD:alu0.ZERO;
<span class="kw">endmodule</span></code></pre>
<h3 id="以微指令設計控制單元"><a href="#以微指令設計控制單元">以微指令設計控制單元</a></h3>
<p>另一種可以克服區塊式複雜度問題的方法，是採用「微指令」(microcode or microprogram) 的設計方法，這種方法將指令的「擷取 (fetch)、解碼 (decode)、執行 (execute) 與寫回 (write-back)」等分成 T1, T2, T3, T4, ... 等子步驟，然後用一個微型計數器 mPC 控制這些子步驟的執行，如下圖所示。</p>
<div class="figure">
<img src="../img/microcode.jpg" />
</div>
<p>由於 T1, T2, T3, T4 代表「擷取 (fetch)、解碼 (decode)、執行 (execute) 與寫回 (write-back)」，每個步驟各佔用一個 Clock，於是一個指令需要四個 Clock 才能完成，因此我們可以用以下方法將各個「開關與多工器」的控制編為一個表格。</p>
<pre><code>       C1 C2 C3 .... Ck
T1
T2
T3
T4</code></pre>
<p>這樣就可以很有系統的運用「區塊建構法」將控制單元也區塊化了，於是我們就不需要採用「流程式的寫法」，也能透過「按表操課」的方法完成「處理器的區塊式建構」了。</p>
<h1 id="微處理器-micro-processor"><a href="#微處理器-micro-processor">微處理器 (Micro Processor)</a></h1>
<p>現代的處理器通常會被分為「微處理器」與「高階處理器」兩類。</p>
<p>微處理器指的是能力較弱，通常指令長度較短，以 8 位於為主，少數為 16 位元，像是 8051、AVR8 或 PIC 等處理器，這些處理器通常不會搭配外部記憶體，因此常用在「單晶片」或者「嵌入式系統」當中。</p>
<p>而高階處理器則是能力較強，通常指令寬度較大 (32 位元以上)，像是 Intel 的 x86 等等，高階的 ARM11、ARM Cortex 處理器等等，這些處理器的定址空間很大，可以搭配容量很大的記憶體 (ex: 4GB)，而且速度很快，因此需要內建「記憶體管理單元」(Memory Management Unit, MMU) 與多層快取機制 (cache) ，以便能夠充分發揮處理器的效能。</p>
<p>在本章當中，我們將透過 mcu0 這個簡易的架構，說明「微處理器」的設計方法。</p>
<p>當然、「微處理器」的設計方法有很多種，在本章中我們將展示兩種設計方法，一種是「流程式」的設計法，這種方法比較符合「軟體程式人」的設計習慣，寫起來有點類似 C 語言的寫法。</p>
<p>另一種是「區塊式」的設計法，這種方法是傳統「硬體人」的設計方法，採用像積木一樣的方式由下往上拼接出來，然後再透過線路連接各個區塊形成一個更大的區塊。</p>
<h2 id="mcu0-的迷你版----mcu0m"><a href="#mcu0-的迷你版----mcu0m">MCU0 的迷你版 -- mcu0m</a></h2>
<h3 id="mcu0-處理器"><a href="#mcu0-處理器">MCU0 處理器</a></h3>
<p>MCU0 為一個 16 位元處理器，包含指令暫存器 IR，程式計數器 PC ，狀態佔存器 SW 與累積器 A 等四個暫存器。</p>
<h3 id="指令表"><a href="#指令表">指令表</a></h3>
<table>
<thead>
<tr class="header">
<th align="left">OP</th>
<th align="left">name</th>
<th align="left">格式 意</th>
<th align="left">義</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">LD</td>
<td align="left">LD C</td>
<td align="left">A = [C]</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">ADD</td>
<td align="left">ADD C</td>
<td align="left">A = A + [C]</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">JMP</td>
<td align="left">JMP C</td>
<td align="left">PC = C</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">ST</td>
<td align="left">ST C</td>
<td align="left">[C] = A</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">CMP</td>
<td align="left">CMP C</td>
<td align="left">SW = A CMP [C]</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">JEQ</td>
<td align="left">JEQ C</td>
<td align="left">if SW[30]=Z=1 then PC = C</td>
</tr>
</tbody>
</table>
<h3 id="組合語言與機器碼"><a href="#組合語言與機器碼">組合語言與機器碼</a></h3>
<pre><code>00  LOOP:   LD  I       0016
02          CMP K10     401A
04          JEQ EXIT    5012
06          ADD K1      1018
08          ST  I       3016
0A          LD  SUM     0014
0C          ADD I       1016
0E          ST  SUM     3014
10          JMP LOOP    2000
12  EXIT:   JMP EXIT    2012
14  SUM:    WORD 0      0000
16  I:      WORD 0      0000
18  K1:     WORD 1      0001
1A  K10:    WORD 10     000A</code></pre>
<p>轉成 Hex 輸入檔格式：</p>
<p>檔案： mcu0m.hex</p>
<pre><code>00 16  // 00    LOOP:   LD    I    
40 1A  // 02            CMP   K10  
50 12  // 04            JEQ   EXIT實作
10 18  // 06            ADD   K1   
30 16  // 08            ST    I    
00 14  // 0A            LD    SUM  
10 16  // 0C            ADD   I    
30 14  // 0E            ST    SUM  
20 00  // 10            JMP   LOOP
20 12  // 12    EXIT:   JMP   EXIT
00 00  // 14    SUM:    WORD  0    
00 00  // 16    I:      WORD  0    
00 01  // 18    K1:     WORD  1    
00 0A  // 1A    K10:    WORD  10   </code></pre>
<h3 id="verilog-程式實作"><a href="#verilog-程式實作">Verilog 程式實作</a></h3>
<p>檔案： mcu0m.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define N    SW[15] </span><span class="co">// 負號旗標</span>
<span class="ot">`define Z    SW[14] </span><span class="co">// 零旗標</span>
<span class="ot">`define OP   IR[15:12] </span><span class="co">// 運算碼</span>
<span class="ot">`define C    IR[11:0]  </span><span class="co">// 常數欄位</span>
<span class="ot">`define M    {m[`C], m[`C+1]}</span>

<span class="kw">module</span> cpu(<span class="dt">input</span> clock); <span class="co">// CPU0-Mini 的快取版：cpu0mc 模組</span>
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LD=<span class="bn">4&#39;h0</span>,ADD=<span class="bn">4&#39;h1</span>,JMP=<span class="bn">4&#39;h2</span>,ST=<span class="bn">4&#39;h3</span>,CMP=<span class="bn">4&#39;h4</span>,JEQ=<span class="bn">4&#39;h5</span>;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] A;   <span class="co">// 宣告暫存器 R[0..15] 等 16 個 32 位元暫存器</span>
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] IR;  <span class="co">// 指令暫存器 IR</span>
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] SW;  <span class="co">// 指令暫存器 IR</span>
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] PC;  <span class="co">// 程式計數器</span>
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] pc0;
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>]  m [<span class="dv">0</span>:<span class="dv">32</span>];    <span class="co">// 內部的快取記憶體</span>
  <span class="dt">integer</span> i;  
  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    PC = <span class="dv">0</span>; <span class="co">// 將 PC 設為起動位址 0</span>
    SW = <span class="dv">0</span>;
    <span class="dt">$readmemh</span>(<span class="st">&quot;mcu0m.hex&quot;</span>, m);
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; <span class="dv">32</span>; i=i<span class="dv">+2</span>) <span class="kw">begin</span>
       <span class="dt">$display</span>(<span class="st">&quot;%8x: %8x&quot;</span>, i, {m[i], m[i<span class="dv">+1</span>]});
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
      IR = {m[PC], m[PC<span class="dv">+1</span>]};  <span class="co">// 指令擷取階段：IR=m[PC], 2 個 Byte 的記憶體</span>
      pc0= PC;                <span class="co">// 儲存舊的 PC 值在 pc0 中。</span>
      PC = PC<span class="dv">+2</span>;              <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
      <span class="kw">case</span> (<span class="ot">`OP</span>)              <span class="co">// 解碼、根據 OP 執行動作</span>
        <span class="dv">LD:</span> A = <span class="ot">`M</span>;           <span class="co">// LD C</span>
        <span class="dv">ST:</span> <span class="ot">`M</span> = A;           <span class="co">// ST C</span>
        <span class="dv">CMP:</span> <span class="kw">begin</span> <span class="ot">`N</span>=(A &lt; <span class="ot">`M</span>); <span class="ot">`Z</span>=(A==<span class="ot">`M</span>); <span class="kw">end</span> <span class="co">// CMP C</span>
        <span class="dv">ADD:</span> A = A + <span class="ot">`M</span>;      <span class="co">// ADD C</span>
        <span class="dv">JMP:</span> PC = <span class="ot">`C</span>;         <span class="co">// JMP C</span>
        <span class="dv">JEQ:</span> <span class="kw">if</span> (<span class="ot">`Z</span>) PC=<span class="ot">`C</span>;   <span class="co">// JEQ C</span>
      <span class="kw">endcase</span>
      <span class="co">// 印出 PC, IR, SW, A 等暫存器值以供觀察</span>
      <span class="dt">$display</span>(<span class="st">&quot;%4dns PC=%x IR=%x, SW=%x, A=%d&quot;</span>, <span class="dt">$stime</span>, pc0, IR, SW, A); 
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>

cpu cpux(clock);            <span class="co">// 宣告 cpu0mc 處理器</span>

<span class="kw">initial</span> clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
<span class="kw">always</span> <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10ns 反相，時脈週期為 20ns</span>
<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;      <span class="co">// 在 2000 奈秒的時候停止測試。</span>
<span class="kw">endmodule</span></code></pre>
<h3 id="執行結果"><a href="#執行結果">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o mcu0m mcu0m.v

D:\Dropbox\Public\web\oc\code&gt;vvp cpu16m
WARNING: cpu16m.v:20: $readmemh(cpu16m.hex): Not enough words in the file for th
e requested range [0:32].
00000000:     0016
00000002:     401a
00000004:     5012
00000006:     1018
00000008:     3016
0000000a:     0014
0000000c:     1016
0000000e:     3014
00000010:     2000
00000012:     2012
00000014:     0000
00000016:     0000
00000018:     0001
0000001a:     000a
0000001c:     xxxx
0000001e:     xxxx
  10ns PC=0000 IR=0016, SW=0000, A=     0
  30ns PC=0002 IR=401a, SW=8000, A=     0
  50ns PC=0004 IR=5012, SW=8000, A=     0
  70ns PC=0006 IR=1018, SW=8000, A=     1
  90ns PC=0008 IR=3016, SW=8000, A=     1
 110ns PC=000a IR=0014, SW=8000, A=     0
 130ns PC=000c IR=1016, SW=8000, A=     1
 150ns PC=000e IR=3014, SW=8000, A=     1
 170ns PC=0010 IR=2000, SW=8000, A=     1
 190ns PC=0000 IR=0016, SW=8000, A=     1
 210ns PC=0002 IR=401a, SW=8000, A=     1
 230ns PC=0004 IR=5012, SW=8000, A=     1
 250ns PC=0006 IR=1018, SW=8000, A=     2
 270ns PC=0008 IR=3016, SW=8000, A=     2
 290ns PC=000a IR=0014, SW=8000, A=     1
 310ns PC=000c IR=1016, SW=8000, A=     3
 330ns PC=000e IR=3014, SW=8000, A=     3
 350ns PC=0010 IR=2000, SW=8000, A=     3
 370ns PC=0000 IR=0016, SW=8000, A=     2
 390ns PC=0002 IR=401a, SW=8000, A=     2
 410ns PC=0004 IR=5012, SW=8000, A=     2
 430ns PC=0006 IR=1018, SW=8000, A=     3
 450ns PC=0008 IR=3016, SW=8000, A=     3
 470ns PC=000a IR=0014, SW=8000, A=     3
 490ns PC=000c IR=1016, SW=8000, A=     6
 510ns PC=000e IR=3014, SW=8000, A=     6
 530ns PC=0010 IR=2000, SW=8000, A=     6
 550ns PC=0000 IR=0016, SW=8000, A=     3
 570ns PC=0002 IR=401a, SW=8000, A=     3
 590ns PC=0004 IR=5012, SW=8000, A=     3
 610ns PC=0006 IR=1018, SW=8000, A=     4
 630ns PC=0008 IR=3016, SW=8000, A=     4
 650ns PC=000a IR=0014, SW=8000, A=     6
 670ns PC=000c IR=1016, SW=8000, A=    10
 690ns PC=000e IR=3014, SW=8000, A=    10
 710ns PC=0010 IR=2000, SW=8000, A=    10
 730ns PC=0000 IR=0016, SW=8000, A=     4
 750ns PC=0002 IR=401a, SW=8000, A=     4
 770ns PC=0004 IR=5012, SW=8000, A=     4
 790ns PC=0006 IR=1018, SW=8000, A=     5
 810ns PC=0008 IR=3016, SW=8000, A=     5
 830ns PC=000a IR=0014, SW=8000, A=    10
 850ns PC=000c IR=1016, SW=8000, A=    15
 870ns PC=000e IR=3014, SW=8000, A=    15
 890ns PC=0010 IR=2000, SW=8000, A=    15
 910ns PC=0000 IR=0016, SW=8000, A=     5
 930ns PC=0002 IR=401a, SW=8000, A=     5
 950ns PC=0004 IR=5012, SW=8000, A=     5
 970ns PC=0006 IR=1018, SW=8000, A=     6
 990ns PC=0008 IR=3016, SW=8000, A=     6
1010ns PC=000a IR=0014, SW=8000, A=    15
1030ns PC=000c IR=1016, SW=8000, A=    21
1050ns PC=000e IR=3014, SW=8000, A=    21
1070ns PC=0010 IR=2000, SW=8000, A=    21
1090ns PC=0000 IR=0016, SW=8000, A=     6
1110ns PC=0002 IR=401a, SW=8000, A=     6
1130ns PC=0004 IR=5012, SW=8000, A=     6
1150ns PC=0006 IR=1018, SW=8000, A=     7
1170ns PC=0008 IR=3016, SW=8000, A=     7
1190ns PC=000a IR=0014, SW=8000, A=    21
1210ns PC=000c IR=1016, SW=8000, A=    28
1230ns PC=000e IR=3014, SW=8000, A=    28
1250ns PC=0010 IR=2000, SW=8000, A=    28
1270ns PC=0000 IR=0016, SW=8000, A=     7
1290ns PC=0002 IR=401a, SW=8000, A=     7
1310ns PC=0004 IR=5012, SW=8000, A=     7
1330ns PC=0006 IR=1018, SW=8000, A=     8
1350ns PC=0008 IR=3016, SW=8000, A=     8
1370ns PC=000a IR=0014, SW=8000, A=    28
1390ns PC=000c IR=1016, SW=8000, A=    36
1410ns PC=000e IR=3014, SW=8000, A=    36
1430ns PC=0010 IR=2000, SW=8000, A=    36
1450ns PC=0000 IR=0016, SW=8000, A=     8
1470ns PC=0002 IR=401a, SW=8000, A=     8
1490ns PC=0004 IR=5012, SW=8000, A=     8
1510ns PC=0006 IR=1018, SW=8000, A=     9
1530ns PC=0008 IR=3016, SW=8000, A=     9
1550ns PC=000a IR=0014, SW=8000, A=    36
1570ns PC=000c IR=1016, SW=8000, A=    45
1590ns PC=000e IR=3014, SW=8000, A=    45
1610ns PC=0010 IR=2000, SW=8000, A=    45
1630ns PC=0000 IR=0016, SW=8000, A=     9
1650ns PC=0002 IR=401a, SW=8000, A=     9
1670ns PC=0004 IR=5012, SW=8000, A=     9
1690ns PC=0006 IR=1018, SW=8000, A=    10
1710ns PC=0008 IR=3016, SW=8000, A=    10
1730ns PC=000a IR=0014, SW=8000, A=    45
1750ns PC=000c IR=1016, SW=8000, A=    55
1770ns PC=000e IR=3014, SW=8000, A=    55
1790ns PC=0010 IR=2000, SW=8000, A=    55
1810ns PC=0000 IR=0016, SW=8000, A=    10
1830ns PC=0002 IR=401a, SW=4000, A=    10
1850ns PC=0004 IR=5012, SW=4000, A=    10
1870ns PC=0012 IR=2012, SW=4000, A=    10
1890ns PC=0012 IR=2012, SW=4000, A=    10
1910ns PC=0012 IR=2012, SW=4000, A=    10
1930ns PC=0012 IR=2012, SW=4000, A=    10
1950ns PC=0012 IR=2012, SW=4000, A=    10
1970ns PC=0012 IR=2012, SW=4000, A=    10
1990ns PC=0012 IR=2012, SW=4000, A=    10</code></pre>
<h2 id="mcu0-的區塊式設計----mcu0bm.v"><a href="#mcu0-的區塊式設計----mcu0bm.v">MCU0 的區塊式設計 -- MCU0bm.v</a></h2>
<h3 id="前言-1"><a href="#前言-1">前言</a></h3>
<p>我們曾經在下列文章中設計出了 MCU0 迷你版這個只有六個指令的微控制器，整個實作只有 51 行。</p>
<ul>
<li><a href="http://programmermagazine.github.io/201312/htm/article5.html">開放電腦計畫 (6) – 一顆只有 51 行 Verilog 程式碼的 16 位元處理器 MCU0</a></li>
</ul>
<p>但是、上述程式雖然簡單，但卻是採用流程式的寫法。雖然、筆者不覺得流程式的寫法有甚麼特別的缺陷，但是對那些習慣採用硬體角度設計 Verilog 程式的人而言，似乎採用「區塊式的設計方式」才是正統，所以、筆者將於本文中採用「區塊式的方式重新設計」MCU0 迷你版，以便能學習「硬體設計者」的思考方式。</p>
<h3 id="mcu0-迷你版的指令表"><a href="#mcu0-迷你版的指令表">MCU0 迷你版的指令表</a></h3>
<p>為了方便讀者閱讀，不需要查閱前文，我們再次列出了 MCU0 迷你版的指令表如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">OP</th>
<th align="left">name</th>
<th align="left">格式 意</th>
<th align="left">義</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">LD</td>
<td align="left">LD C</td>
<td align="left">A = [C]</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">ADD</td>
<td align="left">ADD C</td>
<td align="left">A = A + [C]</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">JMP</td>
<td align="left">JMP C</td>
<td align="left">PC = C</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">ST</td>
<td align="left">ST C</td>
<td align="left">[C] = A</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">CMP</td>
<td align="left">CMP C</td>
<td align="left">SW = A CMP [C]</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">JEQ</td>
<td align="left">JEQ C</td>
<td align="left">if SW[30]=Z=1 then PC = C</td>
</tr>
</tbody>
</table>
<h3 id="mcu0-迷你版的區塊設計圖"><a href="#mcu0-迷你版的區塊設計圖">MCU0 迷你版的區塊設計圖</a></h3>
<p>在MCU0 迷你版裏，總共有三個暫存器，分別是 A, PC 與 SW，一個具有兩組讀取 (i1/d1, i2/d2) 與一組寫入的記憶體 (wi/wd)，還有一個算術邏輯單元 ALU，這個電路的設計圖如下。</p>
<div class="figure">
<img src="../img/mcu0bm.jpg" alt="圖、MCU0bm 的區塊設計圖" /><p class="caption">圖、MCU0bm 的區塊設計圖</p>
</div>
<p>由於筆者不熟悉數位電路設計的繪圖軟體，因此就簡單的用 LibreOffice 的 Impress 繪製了上圖，純粹採用區塊表達法，並沒有使用標準的數位電路設計圖示。</p>
<h3 id="原始碼"><a href="#原始碼">原始碼</a></h3>
<p>根據上圖，我們設計出了下列 Verilog 程式，您應該可以很清楚的找出程式與圖形之間的對應關係。</p>
<pre class="sourceCode Verilog"><code class="sourceCode verilog"><span class="kw">module</span> memory(<span class="dt">input</span> w, <span class="dt">input</span> [<span class="dv">11</span>:<span class="dv">0</span>] wi, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] wd, <span class="dt">input</span> [<span class="dv">11</span>:<span class="dv">0</span>] i1, <span class="dt">output</span> [<span class="dv">15</span>:<span class="dv">0</span>] d1, <span class="dt">input</span> [<span class="dv">11</span>:<span class="dv">0</span>] i2, <span class="dt">output</span> [<span class="dv">15</span>:<span class="dv">0</span>] d2);
  <span class="dt">integer</span> i;  
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m[<span class="dv">0</span>:<span class="dv">2</span>**<span class="dv">12-1</span>];
  <span class="kw">initial</span> <span class="kw">begin</span>
    <span class="dt">$readmemh</span>(<span class="st">&quot;mcu0m.hex&quot;</span>, m);
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; <span class="dv">32</span>; i=i<span class="dv">+2</span>) <span class="kw">begin</span>
      <span class="dt">$display</span>(<span class="st">&quot;%x: %x&quot;</span>, i, {m[i], m[i<span class="dv">+1</span>]});
    <span class="kw">end</span>
  <span class="kw">end</span>
  <span class="kw">assign</span> d1 = {m[i1], m[i1<span class="dv">+1</span>]};
  <span class="kw">assign</span> d2 = {m[i2], m[i2<span class="dv">+1</span>]};
  <span class="kw">always</span> @(w) <span class="kw">begin</span>
    <span class="kw">if</span> (w) {m[wi], m[wi<span class="dv">+1</span>]} = wd;
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> adder#(<span class="dt">parameter</span> W=<span class="dv">16</span>)(<span class="dt">input</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] b, <span class="dt">output</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] c);
  <span class="kw">assign</span> c = a + b;
<span class="kw">endmodule</span>

<span class="kw">module</span> register#(<span class="dt">parameter</span> W=<span class="dv">16</span>)(<span class="dt">input</span> clock, w, <span class="dt">input</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] ri, <span class="dt">output</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] ro);
<span class="dt">reg</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] r;
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>
    <span class="kw">if</span> (w) r = ri;
  <span class="kw">end</span>
  <span class="kw">assign</span> ro=r;
<span class="kw">endmodule</span>

<span class="kw">module</span> alu(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] op, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] b, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] c);
<span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] ZERO=<span class="bn">4&#39;h0</span>, ADD=<span class="bn">4&#39;h1</span>, CMP=<span class="bn">4&#39;he</span>, APASS=<span class="bn">4&#39;hf</span>;
  <span class="kw">always</span> @(*) <span class="kw">begin</span>
    <span class="kw">case</span> (op)
      <span class="dv">ADD:</span> c = a+b;
      <span class="dv">CMP:</span> <span class="kw">begin</span> c[<span class="dv">15</span>]=(a &lt; b); c[<span class="dv">14</span>]=(a==b); c[<span class="dv">13</span>:<span class="dv">0</span>]=<span class="bn">14&#39;h0</span>; <span class="kw">end</span>
      <span class="dv">APASS:</span> c = a;
      <span class="kw">default</span>: c = <span class="dv">0</span>;
    <span class="kw">endcase</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> mux#(<span class="dt">parameter</span> W=<span class="dv">16</span>)(<span class="dt">input</span> sel, <span class="dt">input</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] i0, i1, <span class="dt">output</span> [W<span class="dv">-1</span>:<span class="dv">0</span>] o);
  <span class="kw">assign</span> o=(sel)?i1:i0;
<span class="kw">endmodule</span>

<span class="ot">`define OP ir[15:12]</span>
<span class="ot">`define C  ir[11:0]</span>
<span class="ot">`define N  SW.r[15]</span>
<span class="ot">`define Z  SW.r[14]</span>

<span class="kw">module</span> control(<span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] op, <span class="dt">input</span> z, <span class="dt">output</span> mw, aw, pcmux, sww, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop);
  <span class="kw">assign</span> mw=(op==mcu0.ST);
  <span class="kw">assign</span> aw=(op==mcu0.LD || op==mcu0.ADD);
  <span class="kw">assign</span> sww=(op==mcu0.CMP);
  <span class="kw">assign</span> pcmux=(op==mcu0.JMP || (op==mcu0.JEQ &amp;&amp; z));
  <span class="kw">assign</span> aluop=(op==mcu0.LD)?alu0.APASS:(op==mcu0.CMP)?alu0.CMP:(op==mcu0.ADD)?alu0.ADD:alu0.ZERO;
<span class="kw">endmodule</span>

<span class="kw">module</span> mcu(<span class="dt">input</span> clock);
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LD=<span class="bn">4&#39;h0</span>,ADD=<span class="bn">4&#39;h1</span>,JMP=<span class="bn">4&#39;h2</span>,ST=<span class="bn">4&#39;h3</span>,CMP=<span class="bn">4&#39;h4</span>,JEQ=<span class="bn">4&#39;h5</span>;
  <span class="dt">wire</span> mw, aw, pcmux, sww;
  <span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>] aluop;
  <span class="dt">wire</span> [<span class="dv">11</span>:<span class="dv">0</span>] pco, pci, pcnext;
  <span class="dt">wire</span> [<span class="dv">15</span>:<span class="dv">0</span>] aluout, ao, swo, ir, mo;
  
  register#(.W(<span class="dv">12</span>)) PC(clock, <span class="dv">1</span>, pci, pco);
  adder#(.W(<span class="dv">12</span>)) adder0(<span class="dv">2</span>, pco, pcnext);
  memory mem(mw, <span class="ot">`C</span>, ao, pco, ir, <span class="ot">`C</span>, mo);
  register#(.W(<span class="dv">16</span>)) A(~clock, aw, aluout, ao);
  register#(.W(<span class="dv">16</span>)) SW(~clock, sww, aluout, swo);
  alu alu0(aluop, mo, ao, aluout);
  mux#(.W(<span class="dv">12</span>)) muxpc(pcmux, pcnext, <span class="ot">`C</span>, pci);
  control cu(<span class="ot">`OP</span>, <span class="ot">`Z</span>, mw, aw, pcmux, sww, aluop);
  
  <span class="kw">initial</span> <span class="kw">begin</span>
    PC.r = <span class="dv">0</span>; SW.r = <span class="dv">0</span>;
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;         <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;           <span class="co">// 時脈 clock 變數</span>

mcu mcu0(clock);

<span class="kw">initial</span> <span class="kw">begin</span> 
  clock = <span class="dv">0</span>;
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns pc=%x ir=%x mo=%x sw=%x a=%d mw=%b aluout=%x&quot;</span>, <span class="dt">$stime</span>, mcu0.PC.r, mcu0.ir, mcu0.mo, mcu0.SW.r, mcu0.A.r, mcu0.mw, mcu0.aluout);
  <span class="bn">#1000</span> <span class="dt">$finish</span>;
<span class="kw">end</span>
<span class="kw">always</span> <span class="bn">#5</span> <span class="kw">begin</span> 
  clock=~clock;    <span class="co">// 每隔 5ns 反相，時脈週期為 10ns</span>
<span class="kw">end</span>  
<span class="kw">endmodule</span></code></pre>
<h3 id="輸入的機器碼-mcu0m.hex"><a href="#輸入的機器碼-mcu0m.hex">輸入的機器碼 mcu0m.hex</a></h3>
<p>為了測試上述程式，我們同樣採用了計算 <code>SUM=1+2+...+10</code> 的這個程式作為輸入，以下是機器碼與對應的組合語言程式。</p>
<pre><code>00 16  // 00    LOOP:   LD    I    
40 1A  // 02            CMP   N    
50 12  // 04            JEQ   EXIT
10 18  // 06            ADD   K1    
30 16  // 08            ST    I    
00 14  // 0A            LD    SUM    
10 16  // 0C            ADD   I    
30 14  // 0E            ST    SUM    
20 00  // 10            JMP   LOOP
20 12  // 12    EXIT:   JMP   EXIT
00 00  // 14    SUM:    WORD  0    
00 00  // 16    I:      WORD  0    
00 01  // 18    K1:     WORD  1    
00 0A  // 1A    N:      WORD  10    </code></pre>
<h3 id="執行結果-1"><a href="#執行結果-1">執行結果</a></h3>
<p>編寫完成之後，我們就可以測試整個 mcu0bm.v 程式了，其執行結果如下所示。</p>
<pre><code>D:\Dropbox\Public\web\co\code\mcu0&gt;iverilog mcu0bm.v -o mcu0bm

D:\Dropbox\Public\web\co\code\mcu0&gt;vvp mcu0bm
WARNING: mcu0bm.v:5: $readmemh(mcu0m.hex): Not enough words in the file for the
requested range [0:4095].
00000000: 0016
00000002: 401a
00000004: 5012
00000006: 1018
00000008: 3016
0000000a: 0014
0000000c: 1016
0000000e: 3014
00000010: 2000
00000012: 2012
00000014: 0000
00000016: 0000
00000018: 0001
0000001a: 000a
0000001c: xxxx
0000001e: xxxx
   0ns pc=000 ir=0016 mo=0000 sw=0000 a=    0 mw=0 aluout=0000
   5ns pc=002 ir=401a mo=000a sw=0000 a=    0 mw=0 aluout=0000
  15ns pc=004 ir=5012 mo=2012 sw=0000 a=    0 mw=0 aluout=0000
  25ns pc=006 ir=1018 mo=0001 sw=0000 a=    0 mw=0 aluout=0001
  30ns pc=006 ir=1018 mo=0001 sw=0000 a=    1 mw=0 aluout=0002
  35ns pc=008 ir=3016 mo=0001 sw=0000 a=    1 mw=1 aluout=0000
  45ns pc=00a ir=0014 mo=0000 sw=0000 a=    1 mw=0 aluout=0000
  50ns pc=00a ir=0014 mo=0000 sw=0000 a=    0 mw=0 aluout=0000
  55ns pc=00c ir=1016 mo=0001 sw=0000 a=    0 mw=0 aluout=0001
  60ns pc=00c ir=1016 mo=0001 sw=0000 a=    1 mw=0 aluout=0002
  65ns pc=00e ir=3014 mo=0001 sw=0000 a=    1 mw=1 aluout=0000
  75ns pc=010 ir=2000 mo=0016 sw=0000 a=    1 mw=0 aluout=0000
  85ns pc=000 ir=0016 mo=0001 sw=0000 a=    1 mw=0 aluout=0001
  95ns pc=002 ir=401a mo=000a sw=0000 a=    1 mw=0 aluout=0000
 105ns pc=004 ir=5012 mo=2012 sw=0000 a=    1 mw=0 aluout=0000
 115ns pc=006 ir=1018 mo=0001 sw=0000 a=    1 mw=0 aluout=0002
 120ns pc=006 ir=1018 mo=0001 sw=0000 a=    2 mw=0 aluout=0003
 125ns pc=008 ir=3016 mo=0002 sw=0000 a=    2 mw=1 aluout=0000
 135ns pc=00a ir=0014 mo=0001 sw=0000 a=    2 mw=0 aluout=0001
 140ns pc=00a ir=0014 mo=0001 sw=0000 a=    1 mw=0 aluout=0001
 145ns pc=00c ir=1016 mo=0002 sw=0000 a=    1 mw=0 aluout=0003
 150ns pc=00c ir=1016 mo=0002 sw=0000 a=    3 mw=0 aluout=0005
 155ns pc=00e ir=3014 mo=0003 sw=0000 a=    3 mw=1 aluout=0000
 165ns pc=010 ir=2000 mo=0016 sw=0000 a=    3 mw=0 aluout=0000
 175ns pc=000 ir=0016 mo=0002 sw=0000 a=    3 mw=0 aluout=0002
 180ns pc=000 ir=0016 mo=0002 sw=0000 a=    2 mw=0 aluout=0002
 185ns pc=002 ir=401a mo=000a sw=0000 a=    2 mw=0 aluout=0000
 195ns pc=004 ir=5012 mo=2012 sw=0000 a=    2 mw=0 aluout=0000
 205ns pc=006 ir=1018 mo=0001 sw=0000 a=    2 mw=0 aluout=0003
 210ns pc=006 ir=1018 mo=0001 sw=0000 a=    3 mw=0 aluout=0004
 215ns pc=008 ir=3016 mo=0003 sw=0000 a=    3 mw=1 aluout=0000
 225ns pc=00a ir=0014 mo=0003 sw=0000 a=    3 mw=0 aluout=0003
 235ns pc=00c ir=1016 mo=0003 sw=0000 a=    3 mw=0 aluout=0006
 240ns pc=00c ir=1016 mo=0003 sw=0000 a=    6 mw=0 aluout=0009
 245ns pc=00e ir=3014 mo=0006 sw=0000 a=    6 mw=1 aluout=0000
 255ns pc=010 ir=2000 mo=0016 sw=0000 a=    6 mw=0 aluout=0000
 265ns pc=000 ir=0016 mo=0003 sw=0000 a=    6 mw=0 aluout=0003
 270ns pc=000 ir=0016 mo=0003 sw=0000 a=    3 mw=0 aluout=0003
 275ns pc=002 ir=401a mo=000a sw=0000 a=    3 mw=0 aluout=0000
 285ns pc=004 ir=5012 mo=2012 sw=0000 a=    3 mw=0 aluout=0000
 295ns pc=006 ir=1018 mo=0001 sw=0000 a=    3 mw=0 aluout=0004
 300ns pc=006 ir=1018 mo=0001 sw=0000 a=    4 mw=0 aluout=0005
 305ns pc=008 ir=3016 mo=0004 sw=0000 a=    4 mw=1 aluout=0000
 315ns pc=00a ir=0014 mo=0006 sw=0000 a=    4 mw=0 aluout=0006
 320ns pc=00a ir=0014 mo=0006 sw=0000 a=    6 mw=0 aluout=0006
 325ns pc=00c ir=1016 mo=0004 sw=0000 a=    6 mw=0 aluout=000a
 330ns pc=00c ir=1016 mo=0004 sw=0000 a=   10 mw=0 aluout=000e
 335ns pc=00e ir=3014 mo=000a sw=0000 a=   10 mw=1 aluout=0000
 345ns pc=010 ir=2000 mo=0016 sw=0000 a=   10 mw=0 aluout=0000
 355ns pc=000 ir=0016 mo=0004 sw=0000 a=   10 mw=0 aluout=0004
 360ns pc=000 ir=0016 mo=0004 sw=0000 a=    4 mw=0 aluout=0004
 365ns pc=002 ir=401a mo=000a sw=0000 a=    4 mw=0 aluout=0000
 375ns pc=004 ir=5012 mo=2012 sw=0000 a=    4 mw=0 aluout=0000
 385ns pc=006 ir=1018 mo=0001 sw=0000 a=    4 mw=0 aluout=0005
 390ns pc=006 ir=1018 mo=0001 sw=0000 a=    5 mw=0 aluout=0006
 395ns pc=008 ir=3016 mo=0005 sw=0000 a=    5 mw=1 aluout=0000
 405ns pc=00a ir=0014 mo=000a sw=0000 a=    5 mw=0 aluout=000a
 410ns pc=00a ir=0014 mo=000a sw=0000 a=   10 mw=0 aluout=000a
 415ns pc=00c ir=1016 mo=0005 sw=0000 a=   10 mw=0 aluout=000f
 420ns pc=00c ir=1016 mo=0005 sw=0000 a=   15 mw=0 aluout=0014
 425ns pc=00e ir=3014 mo=000f sw=0000 a=   15 mw=1 aluout=0000
 435ns pc=010 ir=2000 mo=0016 sw=0000 a=   15 mw=0 aluout=0000
 445ns pc=000 ir=0016 mo=0005 sw=0000 a=   15 mw=0 aluout=0005
 450ns pc=000 ir=0016 mo=0005 sw=0000 a=    5 mw=0 aluout=0005
 455ns pc=002 ir=401a mo=000a sw=0000 a=    5 mw=0 aluout=0000
 465ns pc=004 ir=5012 mo=2012 sw=0000 a=    5 mw=0 aluout=0000
 475ns pc=006 ir=1018 mo=0001 sw=0000 a=    5 mw=0 aluout=0006
 480ns pc=006 ir=1018 mo=0001 sw=0000 a=    6 mw=0 aluout=0007
 485ns pc=008 ir=3016 mo=0006 sw=0000 a=    6 mw=1 aluout=0000
 495ns pc=00a ir=0014 mo=000f sw=0000 a=    6 mw=0 aluout=000f
 500ns pc=00a ir=0014 mo=000f sw=0000 a=   15 mw=0 aluout=000f
 505ns pc=00c ir=1016 mo=0006 sw=0000 a=   15 mw=0 aluout=0015
 510ns pc=00c ir=1016 mo=0006 sw=0000 a=   21 mw=0 aluout=001b
 515ns pc=00e ir=3014 mo=0015 sw=0000 a=   21 mw=1 aluout=0000
 525ns pc=010 ir=2000 mo=0016 sw=0000 a=   21 mw=0 aluout=0000
 535ns pc=000 ir=0016 mo=0006 sw=0000 a=   21 mw=0 aluout=0006
 540ns pc=000 ir=0016 mo=0006 sw=0000 a=    6 mw=0 aluout=0006
 545ns pc=002 ir=401a mo=000a sw=0000 a=    6 mw=0 aluout=0000
 555ns pc=004 ir=5012 mo=2012 sw=0000 a=    6 mw=0 aluout=0000
 565ns pc=006 ir=1018 mo=0001 sw=0000 a=    6 mw=0 aluout=0007
 570ns pc=006 ir=1018 mo=0001 sw=0000 a=    7 mw=0 aluout=0008
 575ns pc=008 ir=3016 mo=0007 sw=0000 a=    7 mw=1 aluout=0000
 585ns pc=00a ir=0014 mo=0015 sw=0000 a=    7 mw=0 aluout=0015
 590ns pc=00a ir=0014 mo=0015 sw=0000 a=   21 mw=0 aluout=0015
 595ns pc=00c ir=1016 mo=0007 sw=0000 a=   21 mw=0 aluout=001c
 600ns pc=00c ir=1016 mo=0007 sw=0000 a=   28 mw=0 aluout=0023
 605ns pc=00e ir=3014 mo=001c sw=0000 a=   28 mw=1 aluout=0000
 615ns pc=010 ir=2000 mo=0016 sw=0000 a=   28 mw=0 aluout=0000
 625ns pc=000 ir=0016 mo=0007 sw=0000 a=   28 mw=0 aluout=0007
 630ns pc=000 ir=0016 mo=0007 sw=0000 a=    7 mw=0 aluout=0007
 635ns pc=002 ir=401a mo=000a sw=0000 a=    7 mw=0 aluout=0000
 645ns pc=004 ir=5012 mo=2012 sw=0000 a=    7 mw=0 aluout=0000
 655ns pc=006 ir=1018 mo=0001 sw=0000 a=    7 mw=0 aluout=0008
 660ns pc=006 ir=1018 mo=0001 sw=0000 a=    8 mw=0 aluout=0009
 665ns pc=008 ir=3016 mo=0008 sw=0000 a=    8 mw=1 aluout=0000
 675ns pc=00a ir=0014 mo=001c sw=0000 a=    8 mw=0 aluout=001c
 680ns pc=00a ir=0014 mo=001c sw=0000 a=   28 mw=0 aluout=001c
 685ns pc=00c ir=1016 mo=0008 sw=0000 a=   28 mw=0 aluout=0024
 690ns pc=00c ir=1016 mo=0008 sw=0000 a=   36 mw=0 aluout=002c
 695ns pc=00e ir=3014 mo=0024 sw=0000 a=   36 mw=1 aluout=0000
 705ns pc=010 ir=2000 mo=0016 sw=0000 a=   36 mw=0 aluout=0000
 715ns pc=000 ir=0016 mo=0008 sw=0000 a=   36 mw=0 aluout=0008
 720ns pc=000 ir=0016 mo=0008 sw=0000 a=    8 mw=0 aluout=0008
 725ns pc=002 ir=401a mo=000a sw=0000 a=    8 mw=0 aluout=0000
 735ns pc=004 ir=5012 mo=2012 sw=0000 a=    8 mw=0 aluout=0000
 745ns pc=006 ir=1018 mo=0001 sw=0000 a=    8 mw=0 aluout=0009
 750ns pc=006 ir=1018 mo=0001 sw=0000 a=    9 mw=0 aluout=000a
 755ns pc=008 ir=3016 mo=0009 sw=0000 a=    9 mw=1 aluout=0000
 765ns pc=00a ir=0014 mo=0024 sw=0000 a=    9 mw=0 aluout=0024
 770ns pc=00a ir=0014 mo=0024 sw=0000 a=   36 mw=0 aluout=0024
 775ns pc=00c ir=1016 mo=0009 sw=0000 a=   36 mw=0 aluout=002d
 780ns pc=00c ir=1016 mo=0009 sw=0000 a=   45 mw=0 aluout=0036
 785ns pc=00e ir=3014 mo=002d sw=0000 a=   45 mw=1 aluout=0000
 795ns pc=010 ir=2000 mo=0016 sw=0000 a=   45 mw=0 aluout=0000
 805ns pc=000 ir=0016 mo=0009 sw=0000 a=   45 mw=0 aluout=0009
 810ns pc=000 ir=0016 mo=0009 sw=0000 a=    9 mw=0 aluout=0009
 815ns pc=002 ir=401a mo=000a sw=0000 a=    9 mw=0 aluout=0000
 825ns pc=004 ir=5012 mo=2012 sw=0000 a=    9 mw=0 aluout=0000
 835ns pc=006 ir=1018 mo=0001 sw=0000 a=    9 mw=0 aluout=000a
 840ns pc=006 ir=1018 mo=0001 sw=0000 a=   10 mw=0 aluout=000b
 845ns pc=008 ir=3016 mo=000a sw=0000 a=   10 mw=1 aluout=0000
 855ns pc=00a ir=0014 mo=002d sw=0000 a=   10 mw=0 aluout=002d
 860ns pc=00a ir=0014 mo=002d sw=0000 a=   45 mw=0 aluout=002d
 865ns pc=00c ir=1016 mo=000a sw=0000 a=   45 mw=0 aluout=0037
 870ns pc=00c ir=1016 mo=000a sw=0000 a=   55 mw=0 aluout=0041
 875ns pc=00e ir=3014 mo=0037 sw=0000 a=   55 mw=1 aluout=0000
 885ns pc=010 ir=2000 mo=0016 sw=0000 a=   55 mw=0 aluout=0000
 895ns pc=000 ir=0016 mo=000a sw=0000 a=   55 mw=0 aluout=000a
 900ns pc=000 ir=0016 mo=000a sw=0000 a=   10 mw=0 aluout=000a
 905ns pc=002 ir=401a mo=000a sw=0000 a=   10 mw=0 aluout=4000
 910ns pc=002 ir=401a mo=000a sw=4000 a=   10 mw=0 aluout=4000
 915ns pc=004 ir=5012 mo=2012 sw=4000 a=   10 mw=0 aluout=0000
 925ns pc=012 ir=2012 mo=2012 sw=4000 a=   10 mw=0 aluout=0000</code></pre>
<p>您可以清楚的看到，該程式在 870ns 時計算出了總合 SUM=55 的結果，這代表 mcu0bm.v 的設計完成了計算 1+...+10 的功能。</p>
<h3 id="結語-5"><a href="#結語-5">結語</a></h3>
<p>在上述實作中，採用區塊式設計的 mcu0bm.v 總共有 98 行，比起同樣功能的流程式設計 mcu0m.v 的 51 行多了將近一倍，而且程式的設計難度感覺高了不少，但是我們可以很清楚的掌握到整個設計的硬體結構，這是採用流程式設計所難以確定的。</p>
<p>當然、由於筆者是「程式人員」，並非硬體設計人員，因此比較喜歡採用流程式的設計方式。不過採用了區塊式設計法設計出 mcu0bm.v 之後，也逐漸開始能理解這種「硬體導向」的設計方式，這大概是我在撰寫本程式時最大的收穫了。</p>
<h2 id="mcu0-完整版"><a href="#mcu0-完整版">MCU0 完整版</a></h2>
<h3 id="mcu0-的架構"><a href="#mcu0-的架構">MCU0 的架構</a></h3>
<p>MCU0 是一顆 16 位元的 CPU，所有暫存器都是 16 位元的，總共有 (IR, SP, LR, SW, PC, A) 等暫存器，如下所示：</p>
<pre><code>`define A    R[0]      // 累積器
`define LR   R[1]      // 狀態暫存器
`define SW   R[2]      // 狀態暫存器
`define SP   R[3]      // 堆疊暫存器
`define PC   R[4]      // 程式計數器</code></pre>
<p>這些暫存器的功能與說明如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">暫存器名稱</th>
<th align="left">功能</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IR</td>
<td align="left">指令暫存器</td>
<td align="left">用來儲存從記憶體載入的機器碼指令</td>
</tr>
<tr class="even">
<td align="left">A =R[0]</td>
<td align="left">累積器</td>
<td align="left">用來儲存計算的結果，像是加減法的結果。</td>
</tr>
<tr class="odd">
<td align="left">LR=R[1]</td>
<td align="left">連結暫存器</td>
<td align="left">用來儲存函數呼叫的返回位址</td>
</tr>
<tr class="even">
<td align="left">SW=R[2]</td>
<td align="left">狀態暫存器</td>
<td align="left">用來儲存 CMP 比較指令的結果旗標，像是負旗標 N 與零旗標 Z 等。作為條件跳躍 JEQ 等指令是否跳躍的判斷依據。</td>
</tr>
<tr class="odd">
<td align="left">SP=R[3]</td>
<td align="left">堆疊暫存器</td>
<td align="left">堆疊指標，PUSH, POP 指令會用到。</td>
</tr>
<tr class="even">
<td align="left">PC=R[4]</td>
<td align="left">程式計數器</td>
<td align="left">用來儲存指令的位址 (也就是目前執行到哪個指令的記憶體位址)</td>
</tr>
</tbody>
</table>
<h3 id="mcu0-的指令表"><a href="#mcu0-的指令表">MCU0 的指令表</a></h3>
<p>指令暫存器 IR 的前 4 個位元是指令代碼 OP，由於 4 位元只能表達 16 種指令，這數量太少不敷使用，因此當 OP=0xF 時， 我們繼續用後面的位元作為延伸代碼，以便有更多的指令可以使用，以下是 MCU0 微控制器的完整指令表。</p>
<table>
<thead>
<tr class="header">
<th align="left">代碼</th>
<th align="left">名稱</th>
<th align="left">格式</th>
<th align="left">說明</th>
<th align="left">語意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">LD</td>
<td align="left">LD C</td>
<td align="left">載入</td>
<td align="left">A = [C]</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">ST</td>
<td align="left">ST C</td>
<td align="left">儲存</td>
<td align="left">[C] = A</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">ADD</td>
<td align="left">ADD C</td>
<td align="left">加法</td>
<td align="left">A = A + [C]</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">SUB</td>
<td align="left">SUB C</td>
<td align="left">減法</td>
<td align="left">A = A - [C]</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">MUL</td>
<td align="left">MUL C</td>
<td align="left">乘法</td>
<td align="left">A = A * [C]</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">DIV</td>
<td align="left">DIV C</td>
<td align="left">除法</td>
<td align="left">A = A / [C]</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">AND</td>
<td align="left">AND C</td>
<td align="left">位元 AND 運算</td>
<td align="left">A = A &amp; [C]</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">OR</td>
<td align="left">OR C</td>
<td align="left">位元 OR 運算</td>
<td align="left">A = A | [C]</td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">XOR</td>
<td align="left">XOR C</td>
<td align="left">位元 XOR 運算</td>
<td align="left">A = A ^ [C]</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="left">CMP</td>
<td align="left">CMP C</td>
<td align="left">比較</td>
<td align="left">SW = A CMP [C] ; N=(A&lt;[C]), Z=(A==[C])</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">JMP</td>
<td align="left">JMP C</td>
<td align="left">跳躍</td>
<td align="left">PC = C</td>
</tr>
<tr class="even">
<td align="left">B</td>
<td align="left">JEQ</td>
<td align="left">JEQ C</td>
<td align="left">相等時跳躍</td>
<td align="left">if Z then PC = C</td>
</tr>
<tr class="odd">
<td align="left">C</td>
<td align="left">JLT</td>
<td align="left">JLT C</td>
<td align="left">小於時跳躍</td>
<td align="left">if N then PC = C</td>
</tr>
<tr class="even">
<td align="left">D</td>
<td align="left">JLE</td>
<td align="left">JLE C</td>
<td align="left">小於或等於時跳躍</td>
<td align="left">if Z or N then PC = C</td>
</tr>
<tr class="odd">
<td align="left">E</td>
<td align="left">CALL</td>
<td align="left">CALL C</td>
<td align="left">呼叫副程式</td>
<td align="left">LR=PC; PC = C</td>
</tr>
<tr class="even">
<td align="left">F</td>
<td align="left">OP8</td>
<td align="left"></td>
<td align="left">OP為8位元的運算</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">F0</td>
<td align="left">LDI</td>
<td align="left">LDI Ra,C4</td>
<td align="left">載入常數</td>
<td align="left">Ra=C4</td>
</tr>
<tr class="even">
<td align="left">F2</td>
<td align="left">MOV</td>
<td align="left">MOV Ra,Rb</td>
<td align="left">暫存器移動</td>
<td align="left">Ra=Rb</td>
</tr>
<tr class="odd">
<td align="left">F3</td>
<td align="left">PUSH</td>
<td align="left">PUSH Ra</td>
<td align="left">堆疊推入</td>
<td align="left">SP--; [SP] = Ra</td>
</tr>
<tr class="even">
<td align="left">F4</td>
<td align="left">POP</td>
<td align="left">POP Ra</td>
<td align="left">堆疊取出</td>
<td align="left">Ra=[SP]; SP++;</td>
</tr>
<tr class="odd">
<td align="left">F5</td>
<td align="left">SHL</td>
<td align="left">SHL Ra,C4</td>
<td align="left">左移</td>
<td align="left">Ra = Ra &lt;&lt; C4</td>
</tr>
<tr class="even">
<td align="left">F6</td>
<td align="left">SHR</td>
<td align="left">SHL Ra,C4</td>
<td align="left">右移</td>
<td align="left">Ra = Ra &gt;&gt; C4</td>
</tr>
<tr class="odd">
<td align="left">F7</td>
<td align="left">ADDI</td>
<td align="left">ADDI Ra,C4</td>
<td align="left">常數加法</td>
<td align="left">Ra = Ra + C4</td>
</tr>
<tr class="even">
<td align="left">F8</td>
<td align="left">SUBI</td>
<td align="left">SUBI Ra,C4</td>
<td align="left">常數減法</td>
<td align="left">Ra = Ra - C4</td>
</tr>
<tr class="odd">
<td align="left">F9</td>
<td align="left">NEG</td>
<td align="left">NEG Ra</td>
<td align="left">反相</td>
<td align="left">Ra = ~Ra</td>
</tr>
<tr class="even">
<td align="left">FA</td>
<td align="left">SWI</td>
<td align="left">SWI C</td>
<td align="left">軟體中斷</td>
<td align="left">BIOS 中斷呼叫</td>
</tr>
<tr class="odd">
<td align="left">FD</td>
<td align="left">NSW</td>
<td align="left">NSW</td>
<td align="left">狀態反相</td>
<td align="left">N=~N, Z=~Z; 由於沒有 JGE, JGT, JNE，因此可用此指令將 SW 反相，再用 JLE, JLT, JEQ 完成跳躍動作</td>
</tr>
<tr class="even">
<td align="left">FE</td>
<td align="left">RET</td>
<td align="left">RET</td>
<td align="left">返回</td>
<td align="left">PC = LR</td>
</tr>
<tr class="odd">
<td align="left">FF</td>
<td align="left">IRET</td>
<td align="left">IRET</td>
<td align="left">從中斷返回</td>
<td align="left">PC = LR; I=0;</td>
</tr>
</tbody>
</table>
<h3 id="mcu0-程式碼"><a href="#mcu0-程式碼">mcu0 程式碼</a></h3>
<p>檔案：mcu0s.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define OP   IR[15:12] </span><span class="co">// 運算碼</span>
<span class="ot">`define C    IR[11:0]  </span><span class="co">// 常數欄位</span>
<span class="ot">`define SC8  $signed(IR[7:0]) </span><span class="co">// 常數欄位</span>
<span class="ot">`define C4   IR[3:0]   </span><span class="co">// 常數欄位</span>
<span class="ot">`define Ra   IR[7:4]   </span><span class="co">// Ra</span>
<span class="ot">`define Rb   IR[3:0]   </span><span class="co">// Rb</span>
<span class="ot">`define A    R[0]      </span><span class="co">// 累積器</span>
<span class="ot">`define LR   R[1]      </span><span class="co">// 狀態暫存器</span>
<span class="ot">`define SW   R[2]      </span><span class="co">// 狀態暫存器</span>
<span class="ot">`define SP   R[3]      </span><span class="co">// 堆疊暫存器</span>
<span class="ot">`define PC   R[4]      </span><span class="co">// 程式計數器</span>
<span class="ot">`define N    `SW[15]   </span><span class="co">// 負號旗標</span>
<span class="ot">`define Z    `SW[14]   </span><span class="co">// 零旗標</span>
<span class="ot">`define I    `SW[3]    </span><span class="co">// 是否中斷中</span>
<span class="ot">`define M    m[`C]     </span><span class="co">// 存取記憶體</span>

<span class="kw">module</span> cpu(<span class="dt">input</span> clock); <span class="co">// CPU0-Mini 的快取版：cpu0mc 模組</span>
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LD=<span class="bn">4&#39;h0</span>,ST=<span class="bn">4&#39;h1</span>,ADD=<span class="bn">4&#39;h2</span>,SUB=<span class="bn">4&#39;h3</span>,MUL=<span class="bn">4&#39;h4</span>,DIV=<span class="bn">4&#39;h5</span>,AND=<span class="bn">4&#39;h6</span>,OR=<span class="bn">4&#39;h7</span>,XOR=<span class="bn">4&#39;h8</span>,CMP=<span class="bn">4&#39;h9</span>,JMP=<span class="bn">4&#39;hA</span>,JEQ=<span class="bn">4&#39;hB</span>, JLT=<span class="bn">4&#39;hC</span>, JLE=<span class="bn">4&#39;hD</span>, JSUB=<span class="bn">4&#39;hE</span>, OP8=<span class="bn">4&#39;hF</span>;
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LDI=<span class="bn">4&#39;h0</span>, MOV=<span class="bn">4&#39;h2</span>, PUSH=<span class="bn">4&#39;h3</span>, POP=<span class="bn">4&#39;h4</span>, SHL=<span class="bn">4&#39;h5</span>, SHR=<span class="bn">4&#39;h6</span>, ADDI=<span class="bn">4&#39;h7</span>, SUBI=<span class="bn">4&#39;h8</span>, NEG=<span class="bn">4&#39;h9</span>, SWI=<span class="bn">4&#39;hA</span>, NSW=<span class="bn">4&#39;hD</span>, RET=<span class="bn">4&#39;hE</span>, IRET=<span class="bn">4&#39;hF</span>;
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] IR;    <span class="co">// 指令暫存器</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] R[<span class="dv">0</span>:<span class="dv">4</span>];
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] pc0;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">4096</span>]; <span class="co">// 內部的快取記憶體</span>
  <span class="dt">integer</span> i;
  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    <span class="ot">`PC</span> = <span class="dv">0</span>; <span class="co">// 將 PC 設為起動位址 0</span>
    <span class="ot">`SW</span> = <span class="dv">0</span>;
    <span class="dt">$readmemh</span>(<span class="st">&quot;mcu0s.hex&quot;</span>, m);
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
    IR = m[<span class="ot">`PC</span>];                <span class="co">// 指令擷取階段：IR=m[PC], 2 個 Byte 的記憶體</span>
    pc0= <span class="ot">`PC</span>;                   <span class="co">// 儲存舊的 PC 值在 pc0 中。</span>
    <span class="ot">`PC</span> = <span class="ot">`PC</span><span class="dv">+1</span>;                <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
    <span class="kw">case</span> (<span class="ot">`OP</span>)                  <span class="co">// 解碼、根據 OP 執行動作</span>
      <span class="dv">LD:</span> <span class="ot">`A</span> = <span class="ot">`M</span>;                 <span class="co">// LD C</span>
      <span class="dv">ST:</span> <span class="ot">`M</span> = <span class="ot">`A</span>;                <span class="co">// ST C</span>
      <span class="dv">ADD:</span> <span class="ot">`A</span> = <span class="ot">`A</span> + <span class="ot">`M</span>;        <span class="co">// ADD C</span>
      <span class="dv">SUB:</span> <span class="ot">`A</span> = <span class="ot">`A</span> - <span class="ot">`M</span>;        <span class="co">// SUB C</span>
      <span class="dv">MUL:</span> <span class="ot">`A</span> = <span class="ot">`A</span> * <span class="ot">`M</span>;        <span class="co">// MUL C</span>
      <span class="dv">DIV:</span> <span class="ot">`A</span> = <span class="ot">`A</span> / <span class="ot">`M</span>;        <span class="co">// DIV C</span>
      <span class="dv">AND:</span> <span class="ot">`A</span> = <span class="ot">`A</span> &amp; <span class="ot">`M</span>;        <span class="co">// AND C</span>
      <span class="dv">OR :</span> <span class="ot">`A</span> = <span class="ot">`A</span> | <span class="ot">`M</span>;        <span class="co">// OR  C</span>
      <span class="dv">XOR:</span> <span class="ot">`A</span> = <span class="ot">`A</span> ^ <span class="ot">`M</span>;        <span class="co">// XOR C</span>
      <span class="dv">CMP:</span> <span class="kw">begin</span> <span class="ot">`N</span>=(<span class="ot">`A</span> &lt; <span class="ot">`M</span>); <span class="ot">`Z</span>=(<span class="ot">`A</span>==<span class="ot">`M</span>); <span class="kw">end</span> <span class="co">// CMP C</span>
      <span class="dv">JMP:</span> <span class="ot">`PC</span> = <span class="ot">`C</span>; <span class="co">// JSUB C</span>
      <span class="dv">JEQ:</span> <span class="kw">if</span> (<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;        <span class="co">// JEQ C</span>
      <span class="dv">JLT:</span> <span class="kw">if</span> (<span class="ot">`N</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;        <span class="co">// JLT C</span>
      <span class="dv">JLE:</span> <span class="kw">if</span> (<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;<span class="co">// JLE C</span>
      <span class="dv">JSUB:</span><span class="kw">begin</span> <span class="ot">`LR</span> = <span class="ot">`PC</span>; <span class="ot">`PC</span> = <span class="ot">`C</span>; <span class="kw">end</span> <span class="co">// JSUB C</span>
      <span class="dv">OP8:</span> <span class="kw">case</span> (IR[<span class="dv">11</span>:<span class="dv">8</span>])      <span class="co">// OP8: 加長運算碼</span>
        <span class="dv">LDI:</span>  R[<span class="ot">`Ra</span>] = <span class="ot">`C4</span>;                         <span class="co">// LDI C</span>
        <span class="dv">ADDI:</span> R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] + <span class="ot">`C4</span>;                <span class="co">// ADDI C</span>
        <span class="dv">SUBI:</span> R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] - <span class="ot">`C4</span>;                <span class="co">// ADDI C</span>
        <span class="dv">MOV:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Rb</span>];                      <span class="co">// MOV Ra, Rb</span>
        <span class="dv">PUSH:</span> <span class="kw">begin</span> <span class="ot">`SP</span>=<span class="ot">`SP</span><span class="dv">-1</span>; m[<span class="ot">`SP</span>] = R[<span class="ot">`Ra</span>]; <span class="kw">end</span> <span class="co">// PUSH Ra</span>
        <span class="dv">POP:</span>  <span class="kw">begin</span> R[<span class="ot">`Ra</span>] = m[<span class="ot">`SP</span>]; <span class="ot">`SP</span>=<span class="ot">`SP</span><span class="dv">+1</span>; <span class="kw">end</span> <span class="co">// POP  Ra</span>
        <span class="dv">SHL:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] &lt;&lt; <span class="ot">`C4</span>;               <span class="co">// SHL C</span>
        <span class="dv">SHR:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] &gt;&gt; <span class="ot">`C4</span>;               <span class="co">// SHR C</span>
        <span class="dv">SWI:</span>  <span class="dt">$display</span>(<span class="st">&quot;SWI C8=%d A=%d&quot;</span>, <span class="ot">`SC8</span>, <span class="ot">`A</span>); <span class="co">// SWI C</span>
        <span class="dv">NEG:</span>  R[<span class="ot">`Ra</span>] = ~R[<span class="ot">`Ra</span>];                     <span class="co">// NEG Ra</span>
        <span class="dv">NSW:</span>  <span class="kw">begin</span> <span class="ot">`N</span>=~<span class="ot">`N</span>; <span class="ot">`Z</span>=~<span class="ot">`Z</span>; <span class="kw">end</span>             <span class="co">// NSW  (negate N, Z)</span>
        <span class="dv">RET:</span>  <span class="ot">`PC</span> = <span class="ot">`LR</span>;                            <span class="co">// RET</span>
        <span class="dv">IRET:</span> <span class="kw">begin</span> <span class="ot">`PC</span> = <span class="ot">`LR</span>; <span class="ot">`I</span> = <span class="dv">0</span>; <span class="kw">end</span>          <span class="co">// IRET</span>
        <span class="kw">default</span>: <span class="dt">$display</span>(<span class="st">&quot;op8=%d , not defined!&quot;</span>, IR[<span class="dv">11</span>:<span class="dv">8</span>]);
      <span class="kw">endcase</span>
    <span class="kw">endcase</span>
    <span class="co">// 印出 PC, IR, SW, A 等暫存器值以供觀察</span>
    <span class="dt">$display</span>(<span class="st">&quot;%4dns PC=%x IR=%x, SW=%x, A=%d SP=%x LR=%x&quot;</span>, <span class="dt">$stime</span>, pc0, IR, <span class="ot">`SW</span>, <span class="ot">`A</span>, <span class="ot">`SP</span>, <span class="ot">`LR</span>);
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>

cpu mcu0(clock);            <span class="co">// 宣告 mcu0 處理器</span>

<span class="kw">initial</span> clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
<span class="kw">always</span>  <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10ns 反相，時脈週期為 20ns</span>
<span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;      <span class="co">// 停止測試。</span>

<span class="kw">endmodule</span></code></pre>
<h3 id="組合語言"><a href="#組合語言">組合語言</a></h3>
<p>檔案：mcu0s.hex</p>
<pre><code>0020  // 00    RESET:  LD    X   
2021  // 01            ADD   Y
3021  // 02            SUB   Y
4021  // 03            MUL   Y
5021  // 04            DIV   Y
7021  // 05            OR    Y             
6021  // 06            AND   Y
8021  // 07            XOR   Y
0020  // 08            LD    X
F503  // 09            SHL   A, 3
F603  // 0A            SHR   A, 3
F701  // 0B            ADDI  1
0023  // 0C            LD    STACKEND
F230  // 0D            MOV   SP, A
E011  // 0E            JSUB  MIN
0022  // 0F            LD    Z
A010  // 10    HALT:   JMP   HALT        
F301  // 11    MIN:    PUSH  LR
0020  // 12            LD    X
9021  // 13            CMP   Y
FD00  // 14            NSW
C018  // 15            JLT   ELSE
1022  // 16            ST    Z
A019  // 17            JMP   NEXT
0021  // 18    ELSE:   LD    Y
1022  // 19    NEXT:   ST    Z
F401  // 1A            POP   LR
FE00  // 1B            RET
0000  // 1C    
0000  // 1D    
0000  // 1E
0000  // 1F
0003  // 20    X:      WORD  3
0005  // 21    Y:      WORD  5
0000  // 22    Z:      WORD  0 
007F  // 23    STACKEND: WORD 127</code></pre>
<h3 id="執行結果-2"><a href="#執行結果-2">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\oc\code\mcu0&gt;iverilog -o mcu0s mcu0s.v

D:\Dropbox\Public\web\oc\code\mcu0&gt;vvp mcu0s
WARNING: mcu0s.v:29: $readmemh(mcu0s.hex): Not enough words in the file for the
requested range [0:4096].
  10ns PC=0000 IR=0020, SW=0000, A=    3 SP=xxxx LR=xxxx
  30ns PC=0001 IR=2021, SW=0000, A=    8 SP=xxxx LR=xxxx
  50ns PC=0002 IR=3021, SW=0000, A=    3 SP=xxxx LR=xxxx
  70ns PC=0003 IR=4021, SW=0000, A=   15 SP=xxxx LR=xxxx
  90ns PC=0004 IR=5021, SW=0000, A=    3 SP=xxxx LR=xxxx
 110ns PC=0005 IR=7021, SW=0000, A=    7 SP=xxxx LR=xxxx
 130ns PC=0006 IR=6021, SW=0000, A=    5 SP=xxxx LR=xxxx
 150ns PC=0007 IR=8021, SW=0000, A=    0 SP=xxxx LR=xxxx
 170ns PC=0008 IR=0020, SW=0000, A=    3 SP=xxxx LR=xxxx
 190ns PC=0009 IR=f503, SW=0000, A=   24 SP=xxxx LR=xxxx
 210ns PC=000a IR=f603, SW=0000, A=    3 SP=xxxx LR=xxxx
 230ns PC=000b IR=f701, SW=0000, A=    4 SP=xxxx LR=xxxx
 250ns PC=000c IR=0023, SW=0000, A=  127 SP=xxxx LR=xxxx
 270ns PC=000d IR=f230, SW=0000, A=  127 SP=007f LR=xxxx
 290ns PC=000e IR=e011, SW=0000, A=  127 SP=007f LR=000f
 310ns PC=0011 IR=f301, SW=0000, A=  127 SP=007e LR=000f
 330ns PC=0012 IR=0020, SW=0000, A=    3 SP=007e LR=000f
 350ns PC=0013 IR=9021, SW=8000, A=    3 SP=007e LR=000f
 370ns PC=0014 IR=fd00, SW=4000, A=    3 SP=007e LR=000f
 390ns PC=0015 IR=c018, SW=4000, A=    3 SP=007e LR=000f
 410ns PC=0016 IR=1022, SW=4000, A=    3 SP=007e LR=000f
 430ns PC=0017 IR=a019, SW=4000, A=    3 SP=007e LR=000f
 450ns PC=0019 IR=1022, SW=4000, A=    3 SP=007e LR=000f
 470ns PC=001a IR=f401, SW=4000, A=  127 SP=007f LR=000f
 490ns PC=001b IR=fe00, SW=4000, A=  127 SP=007f LR=000f
 510ns PC=000f IR=0022, SW=4000, A=    3 SP=007f LR=000f
 530ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 550ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 570ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 590ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 610ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 630ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 650ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 670ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 690ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 710ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 730ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 750ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 770ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 790ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 810ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 830ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 850ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 870ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 890ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 910ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 930ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 950ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 970ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f
 990ns PC=0010 IR=a010, SW=4000, A=    3 SP=007f LR=000f</code></pre>
<h3 id="結語-6"><a href="#結語-6">結語</a></h3>
<p>由於 16 位元處理器的指令長度很短，因此空間必須有效利用，所以我們將一些不包含記憶體位址的指令， 編到最後的 <code>0xF</code> 的 OP 代碼當中，這樣就可以再度延伸出一大群指令空間，於是讓指令數可以不受限於 4 位元 OP 碼的 16 個指令，而能延伸為 30 個左右的指令。</p>
<p>在使用 Verilog 這種硬體描述語言設計處理器時，位元數越少，往往處理器的指令長度越少，這時處理器 不見得會更好設計，往往反而會更難設計，指令集的編碼相對會困難一些。</p>
<h1 id="輸出入單元-io"><a href="#輸出入單元-io">輸出入單元 (I/O)</a></h1>
<h2 id="前言-2"><a href="#前言-2">前言</a></h2>
<div class="figure">
<img src="../img/pcibus.jpg" alt="圖、PC 匯流排的連接結構" /><p class="caption">圖、PC 匯流排的連接結構</p>
</div>
<h2 id="bus-總線-匯流排"><a href="#bus-總線-匯流排">BUS (總線, 匯流排)</a></h2>
<p>由於線路多的話會很混亂，而且成本很高。舉例而言，假如有 n 個節點 (裝置)，所有節點之間都要互相直接相連，那麼就需要 n*(n-1)2/ 這個多組線路，這將會是個密密麻麻的災難。</p>
<p>如果、我們讓所有的節點都連接到一組共用的線路，這套線路就稱為 BUS。只要大家都遵循一套固定的傳送規則，我們就可以用 BUS 作為所有人的通訊橋梁。</p>
<p>以下是用 Verilog 宣告 BUS 線路的三種方法，分別是 wire, wand 與 wor。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [n<span class="dv">-1</span>:<span class="dv">0</span>] BUS;
<span class="dt">wand</span> [n<span class="dv">-1</span>:<span class="dv">0</span>] andBUS;
<span class="dt">wor</span>  [n<span class="dv">-1</span>:<span class="dv">0</span>] orBUS;</code></pre>
<p>下列是採用 wire 方式宣告 BUS 的一個範例，當某個 seli 選擇線為 1 時，就會將對應的來源資料 sourcei 放到 BUS 上。而那些沒被選到的來源，由於是放高阻抗 Z ，所以會處於斷線的狀態。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [n<span class="dv">-1</span>:<span class="dv">0</span>] BUS;
<span class="dt">parameter</span> [n<span class="dv">-1</span>:<span class="dv">0</span>] <span class="kw">disable</span> = n<span class="bn">&#39;bZ</span>;

<span class="kw">assign</span> BUS = sel1?source1:<span class="kw">disable</span>;
<span class="kw">assign</span> BUS = sel2?source2:<span class="kw">disable</span>;
...
<span class="kw">assign</span> BUS = selk?sourcek:<span class="kw">disable</span>;</code></pre>
<p>另外兩種宣告 BUS 的方法，也就是 wand 與 wor，與 wire 其實很像，差別只在於 wand 的 disable 是用 n'b1, 而 wor 的 disable 是用 n'b0。</p>
<h2 id="同步匯流排-synchronous-bus"><a href="#同步匯流排-synchronous-bus">同步匯流排 (Synchronous BUS)</a></h2>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> master(<span class="dt">input</span> clock, w, <span class="dt">output</span> [<span class="dv">15</span>:<span class="dv">0</span>] address, <span class="dt">inout</span> [<span class="dv">15</span>:<span class="dv">0</span>] data);
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] ar, dr;
  <span class="kw">assign</span> address = ar;
  <span class="kw">assign</span> data = (w)?dr : <span class="bn">16&#39;hzzzz</span>;

  <span class="kw">always</span> @(*) <span class="kw">begin</span>
    <span class="kw">if</span> (!w)
      dr=<span class="bn">#1</span> data;
  <span class="kw">end</span>  
<span class="kw">endmodule</span>

<span class="kw">module</span> rdevice(<span class="dt">input</span> clock, w, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] address, <span class="dt">output</span> [<span class="dv">15</span>:<span class="dv">0</span>] data);
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] dr;

  <span class="kw">assign</span> data=(!w)?dr:<span class="bn">16&#39;hZZZZ</span>;
  
  <span class="kw">always</span> @(clock <span class="dt">or</span> w <span class="dt">or</span> address) <span class="kw">begin</span>
    <span class="kw">if</span> (!w &amp;&amp; address == <span class="bn">16&#39;hFFF0</span>)
      dr = <span class="bn">#1</span> <span class="bn">16&#39;he3e3</span>;
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> wdevice(<span class="dt">input</span> clock, w, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] address, <span class="dt">input</span> [<span class="dv">15</span>:<span class="dv">0</span>] data);
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] dr;
  
  <span class="kw">always</span> @(clock <span class="dt">or</span> w <span class="dt">or</span> address) <span class="kw">begin</span>
    <span class="kw">if</span> (w &amp;&amp; address == <span class="bn">16&#39;hFFF8</span>)
      dr = <span class="bn">#1</span> data;
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> clock, w;
<span class="dt">wire</span> [<span class="dv">15</span>:<span class="dv">0</span>] abus, dbus;

master  m(clock, w, abus, dbus);
rdevice rd(clock, w, abus, dbus);
wdevice wd(clock, w, abus, dbus);
<span class="kw">initial</span> <span class="kw">begin</span>
  <span class="dt">$monitor</span>(<span class="st">&quot;%4dns abus=%x dbus=%x w=%x m.ar=%x m.dr=%x rd.dr=%x wd.dr=%x&quot;</span>, <span class="dt">$stime</span>, abus, dbus, w, m.ar, m.dr, rd.dr, wd.dr);
  clock = <span class="dv">0</span>;
  <span class="bn">#10</span>; m.ar=<span class="bn">16&#39;h0000</span>; w=<span class="dv">0</span>; 
  <span class="bn">#50</span>; m.ar=<span class="bn">16&#39;hFFF0</span>; 
  <span class="bn">#50</span>; m.ar=<span class="bn">16&#39;hFFF8</span>; m.dr=<span class="bn">16&#39;h71F0</span>; w=<span class="dv">1</span>;
  <span class="bn">#300</span>; <span class="dt">$finish</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#5</span> clock=~clock; <span class="co">// 每隔 5ns 反相，時脈週期為 10ns</span>
<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\co\code&gt;iverilog syncbus.v -o syncbus

D:\Dropbox\Public\web\co\code&gt;vvp syncbus
   0ns abus=xxxx dbus=xxxx w=x m.ar=xxxx m.dr=xxxx rd.dr=xxxx wd.dr=xxxx
  10ns abus=0000 dbus=xxxx w=0 m.ar=0000 m.dr=xxxx rd.dr=xxxx wd.dr=xxxx
  60ns abus=fff0 dbus=xxxx w=0 m.ar=fff0 m.dr=xxxx rd.dr=xxxx wd.dr=xxxx
  61ns abus=fff0 dbus=e3e3 w=0 m.ar=fff0 m.dr=xxxx rd.dr=e3e3 wd.dr=xxxx
  62ns abus=fff0 dbus=e3e3 w=0 m.ar=fff0 m.dr=e3e3 rd.dr=e3e3 wd.dr=xxxx
 110ns abus=fff8 dbus=71f0 w=1 m.ar=fff8 m.dr=71f0 rd.dr=e3e3 wd.dr=xxxx
 111ns abus=fff8 dbus=71f0 w=1 m.ar=fff8 m.dr=71f0 rd.dr=e3e3 wd.dr=e3e3
 116ns abus=fff8 dbus=71f0 w=1 m.ar=fff8 m.dr=71f0 rd.dr=e3e3 wd.dr=71f0</code></pre>
<div class="figure">
<img src="../img/syncbus_wave.jpg" alt="圖、上述同步 BUS 的波形圖" /><p class="caption">圖、上述同步 BUS 的波形圖</p>
</div>
<h2 id="異步匯流排-asynchronous-bus"><a href="#異步匯流排-asynchronous-bus">異步匯流排 (Asynchronous BUS)</a></h2>
<p>異步匯流排是指沒有共同 Clock 訊號的匯流排，因此無法依賴 Clock 進行同步，所以必須依靠「主控就緒」 (Master Ready)，「從動就緒」(Slave Ready) 等訊號，來進行握手 (Handshaking) 的協調程序。</p>
<h2 id="匯流排仲裁-bus-arbitery"><a href="#匯流排仲裁-bus-arbitery">匯流排仲裁 (BUS arbitery)</a></h2>
<p>當有很多個主控裝置都有可能請求使用 BUS 的時候，就必須要加入一個仲裁機制，通常是由一個仲裁者 (arbiter) 進行仲裁。</p>
<div class="figure">
<img src="../img/arbiter.jpg" />
</div>
<h2 id="循序與平行輸出入-serial-vs.-parallel"><a href="#循序與平行輸出入-serial-vs.-parallel">循序與平行輸出入 (Serial vs. Parallel)</a></h2>
<h2 id="常見的輸出入協定"><a href="#常見的輸出入協定">常見的輸出入協定</a></h2>
<h2 id="mcu0-的輸出入----輪詢篇"><a href="#mcu0-的輸出入----輪詢篇">MCU0 的輸出入 -- 輪詢篇</a></h2>
<p>在本文中，我們利用輪詢的方式實作了 MCU0 的鍵盤與文字輸出的函數。</p>
<h3 id="mcu0-的中斷位元"><a href="#mcu0-的中斷位元">MCU0 的中斷位元</a></h3>
<p>在電腦中，進行輸出入所採用的方式，在指令上可分為「專用輸出入指令」與「記憶體映射輸出入」兩種， 在本文中我們將用「記憶體映射輸出入」進行輸出入。</p>
<p>另外、進行輸出入的驅動方式，可分為「輪詢」與「中斷」兩種方式，本文將採用「輪詢」的方式實作。</p>
<h3 id="mcu0-的輸出入實作方式"><a href="#mcu0-的輸出入實作方式">MCU0 的輸出入實作方式</a></h3>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define OP   IR[15:12] </span><span class="co">// 運算碼</span>
<span class="ot">`define C    IR[11:0]  </span><span class="co">// 常數欄位</span>
<span class="ot">`define SC8  $signed(IR[7:0]) </span><span class="co">// 常數欄位</span>
<span class="ot">`define C4   IR[3:0]   </span><span class="co">// 常數欄位</span>
<span class="ot">`define Ra   IR[7:4]   </span><span class="co">// Ra</span>
<span class="ot">`define Rb   IR[3:0]   </span><span class="co">// Rb</span>
<span class="ot">`define A    R[0]      </span><span class="co">// 累積器</span>
<span class="ot">`define LR   R[1]      </span><span class="co">// 狀態暫存器</span>
<span class="ot">`define SW   R[2]      </span><span class="co">// 狀態暫存器</span>
<span class="ot">`define SP   R[3]      </span><span class="co">// 堆疊暫存器</span>
<span class="ot">`define PC   R[4]      </span><span class="co">// 程式計數器</span>
<span class="ot">`define N    `SW[15]   </span><span class="co">// 負號旗標</span>
<span class="ot">`define Z    `SW[14]   </span><span class="co">// 零旗標</span>
<span class="ot">`define I    `SW[3]    </span><span class="co">// 是否中斷中</span>
<span class="ot">`define M    m[`C]     </span><span class="co">// 存取記憶體</span>

<span class="kw">module</span> mcu(<span class="dt">input</span> clock, <span class="dt">input</span> interrupt, <span class="dt">input</span>[<span class="dv">2</span>:<span class="dv">0</span>] irq);
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LD=<span class="bn">4&#39;h0</span>,ST=<span class="bn">4&#39;h1</span>,ADD=<span class="bn">4&#39;h2</span>,SUB=<span class="bn">4&#39;h3</span>,MUL=<span class="bn">4&#39;h4</span>,DIV=<span class="bn">4&#39;h5</span>,AND=<span class="bn">4&#39;h6</span>,OR=<span class="bn">4&#39;h7</span>,XOR=<span class="bn">4&#39;h8</span>,CMP=<span class="bn">4&#39;h9</span>,JMP=<span class="bn">4&#39;hA</span>,JEQ=<span class="bn">4&#39;hB</span>, JLT=<span class="bn">4&#39;hC</span>, JLE=<span class="bn">4&#39;hD</span>, CALL=<span class="bn">4&#39;hE</span>, OP8=<span class="bn">4&#39;hF</span>;
  <span class="dt">parameter</span> [<span class="dv">3</span>:<span class="dv">0</span>] LDI=<span class="bn">4&#39;h0</span>, MOV=<span class="bn">4&#39;h2</span>, PUSH=<span class="bn">4&#39;h3</span>, POP=<span class="bn">4&#39;h4</span>, SHL=<span class="bn">4&#39;h5</span>, SHR=<span class="bn">4&#39;h6</span>, ADDI=<span class="bn">4&#39;h7</span>, SUBI=<span class="bn">4&#39;h8</span>, NEG=<span class="bn">4&#39;h9</span>, SWI=<span class="bn">4&#39;hA</span>, NSW=<span class="bn">4&#39;hD</span>, RET=<span class="bn">4&#39;hE</span>, IRET=<span class="bn">4&#39;hF</span>;
  <span class="dt">reg</span> [<span class="dv">15</span>:<span class="dv">0</span>] IR;    <span class="co">// 指令暫存器</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] R[<span class="dv">0</span>:<span class="dv">4</span>];
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] pc0;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">4095</span>]; <span class="co">// 內部的快取記憶體</span>
  <span class="dt">integer</span> i;
  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    <span class="ot">`PC</span> = <span class="dv">0</span>; <span class="co">// 將 PC 設為起動位址 0</span>
    <span class="ot">`SW</span> = <span class="dv">0</span>;
    <span class="dt">$readmemh</span>(<span class="st">&quot;mcu0io.hex&quot;</span>, m);
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; <span class="dv">32</span>; i=i<span class="dv">+1</span>) <span class="kw">begin</span>
       <span class="dt">$display</span>(<span class="st">&quot;%x %x&quot;</span>, i, m[i]);
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
    IR = m[<span class="ot">`PC</span>];                <span class="co">// 指令擷取階段：IR=m[PC], 2 個 Byte 的記憶體</span>
    pc0= <span class="ot">`PC</span>;                   <span class="co">// 儲存舊的 PC 值在 pc0 中。</span>
    <span class="ot">`PC</span> = <span class="ot">`PC</span><span class="dv">+1</span>;                <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
    <span class="kw">case</span> (<span class="ot">`OP</span>)                  <span class="co">// 解碼、根據 OP 執行動作</span>
      <span class="dv">LD:</span> <span class="ot">`A</span> = <span class="ot">`M</span>;              <span class="co">// LD C</span>
      <span class="dv">ST:</span> <span class="ot">`M</span> = <span class="ot">`A</span>;              <span class="co">// ST C</span>
      <span class="dv">ADD:</span> <span class="ot">`A</span> = <span class="ot">`A</span> + <span class="ot">`M</span>;        <span class="co">// ADD C</span>
      <span class="dv">SUB:</span> <span class="ot">`A</span> = <span class="ot">`A</span> - <span class="ot">`M</span>;        <span class="co">// SUB C</span>
      <span class="dv">MUL:</span> <span class="ot">`A</span> = <span class="ot">`A</span> * <span class="ot">`M</span>;        <span class="co">// MUL C</span>
      <span class="dv">DIV:</span> <span class="ot">`A</span> = <span class="ot">`A</span> / <span class="ot">`M</span>;        <span class="co">// DIV C</span>
      <span class="dv">AND:</span> <span class="ot">`A</span> = <span class="ot">`A</span> &amp; <span class="ot">`M</span>;        <span class="co">// AND C</span>
      <span class="dv">OR :</span> <span class="ot">`A</span> = <span class="ot">`A</span> | <span class="ot">`M</span>;        <span class="co">// OR  C</span>
      <span class="dv">XOR:</span> <span class="ot">`A</span> = <span class="ot">`A</span> ^ <span class="ot">`M</span>;        <span class="co">// XOR C</span>
      <span class="dv">CMP:</span> <span class="kw">begin</span> <span class="ot">`N</span>=(<span class="ot">`A</span> &lt; <span class="ot">`M</span>); <span class="ot">`Z</span>=(<span class="ot">`A</span>==<span class="ot">`M</span>); <span class="kw">end</span> <span class="co">// CMP C</span>
      <span class="dv">JMP:</span> <span class="ot">`PC</span> = <span class="ot">`C</span>;            <span class="co">// JSUB C</span>
      <span class="dv">JEQ:</span> <span class="kw">if</span> (<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;      <span class="co">// JEQ C</span>
      <span class="dv">JLT:</span> <span class="kw">if</span> (<span class="ot">`N</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;      <span class="co">// JLT C</span>
      <span class="dv">JLE:</span> <span class="kw">if</span> (<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`C</span>;<span class="co">// JLE C</span>
      <span class="dv">CALL:</span><span class="kw">begin</span> <span class="ot">`LR</span> = <span class="ot">`PC</span>; <span class="ot">`PC</span> = <span class="ot">`C</span>; <span class="kw">end</span> <span class="co">// CALL C</span>
      <span class="dv">OP8:</span> <span class="kw">case</span> (IR[<span class="dv">11</span>:<span class="dv">8</span>])      <span class="co">// OP8: 加長運算碼</span>
        <span class="dv">LDI:</span>  R[<span class="ot">`Ra</span>] = <span class="ot">`C4</span>;                         <span class="co">// LDI C</span>
        <span class="dv">ADDI:</span> R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] + <span class="ot">`C4</span>;                <span class="co">// ADDI C</span>
        <span class="dv">SUBI:</span> R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] - <span class="ot">`C4</span>;                <span class="co">// ADDI C</span>
        <span class="dv">MOV:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Rb</span>];                      <span class="co">// MOV Ra, Rb</span>
        <span class="dv">PUSH:</span> <span class="kw">begin</span> <span class="ot">`SP</span>=<span class="ot">`SP</span><span class="dv">-1</span>; m[<span class="ot">`SP</span>] = R[<span class="ot">`Ra</span>]; <span class="kw">end</span> <span class="co">// PUSH Ra</span>
        <span class="dv">POP:</span>  <span class="kw">begin</span> R[<span class="ot">`Ra</span>] = m[<span class="ot">`SP</span>]; <span class="ot">`SP</span>=<span class="ot">`SP</span><span class="dv">+1</span>; <span class="kw">end</span> <span class="co">// POP  Ra</span>
        <span class="dv">SHL:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] &lt;&lt; <span class="ot">`C4</span>;               <span class="co">// SHL C</span>
        <span class="dv">SHR:</span>  R[<span class="ot">`Ra</span>] = R[<span class="ot">`Ra</span>] &gt;&gt; <span class="ot">`C4</span>;               <span class="co">// SHR C</span>
        <span class="dv">SWI:</span>  <span class="dt">$display</span>(<span class="st">&quot;SWI C8=%d A=%d&quot;</span>, <span class="ot">`SC8</span>, <span class="ot">`A</span>); <span class="co">// SWI C</span>
        <span class="dv">NEG:</span>  R[<span class="ot">`Ra</span>] = ~R[<span class="ot">`Ra</span>];                     <span class="co">// NEG Ra</span>
        <span class="dv">NSW:</span>  <span class="kw">begin</span> <span class="ot">`N</span>=~<span class="ot">`N</span>; <span class="ot">`Z</span>=~<span class="ot">`Z</span>; <span class="kw">end</span>             <span class="co">// NSW  (negate N, Z)</span>
        <span class="dv">RET:</span>  <span class="ot">`PC</span> = <span class="ot">`LR</span>;                            <span class="co">// RET</span>
        <span class="dv">IRET:</span> <span class="kw">begin</span> <span class="ot">`PC</span> = <span class="ot">`LR</span>; <span class="ot">`I</span> = <span class="dv">0</span>; <span class="kw">end</span>          <span class="co">// IRET</span>
        <span class="kw">default</span>: <span class="dt">$display</span>(<span class="st">&quot;op8=%d , not defined!&quot;</span>, IR[<span class="dv">11</span>:<span class="dv">8</span>]);
      <span class="kw">endcase</span>
    <span class="kw">endcase</span>
    <span class="co">// 印出 PC, IR, SW, A 等暫存器值以供觀察</span>
    <span class="dt">$display</span>(<span class="st">&quot;%4dns PC=%x IR=%x, SW=%x, A=%d SP=%x LR=%x&quot;</span>, <span class="dt">$stime</span>, pc0, IR, <span class="ot">`SW</span>, <span class="ot">`A</span>, <span class="ot">`SP</span>, <span class="ot">`LR</span>);
    <span class="kw">if</span> (!<span class="ot">`I</span> &amp;&amp; interrupt) <span class="kw">begin</span>
      <span class="ot">`I</span> = <span class="dv">1</span>;
      <span class="ot">`LR</span> = <span class="ot">`PC</span>;
      <span class="ot">`PC</span> = irq;
    <span class="kw">end</span>    
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> keyboard;
<span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] ch[<span class="dv">0</span>:<span class="dv">20</span>];
<span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] i;
<span class="kw">initial</span> <span class="kw">begin</span>
  i=<span class="dv">0</span>;
  {ch[<span class="dv">0</span>],ch[<span class="dv">1</span>],ch[<span class="dv">2</span>],ch[<span class="dv">3</span>],ch[<span class="dv">4</span>],ch[<span class="dv">5</span>],ch[<span class="dv">6</span>],ch[<span class="dv">7</span>],ch[<span class="dv">8</span>],ch[<span class="dv">9</span>],ch[<span class="dv">10</span>],ch[<span class="dv">11</span>],ch[<span class="dv">12</span>],ch[<span class="dv">13</span>]} = <span class="st">&quot;hello verilog!&quot;</span>;
  main.mcu0.m[<span class="bn">16&#39;h07F0</span>] = <span class="dv">0</span>;
  main.mcu0.m[<span class="bn">16&#39;h07F1</span>] = <span class="dv">0</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#20</span> <span class="kw">begin</span> 
  <span class="kw">if</span> (main.mcu0.m[<span class="bn">16&#39;h07F0</span>] == <span class="dv">0</span>) <span class="kw">begin</span>
    main.mcu0.m[<span class="bn">16&#39;h07F1</span>] = {<span class="bn">8&#39;h0</span>, ch[i]};
    main.mcu0.m[<span class="bn">16&#39;h07F0</span>] = <span class="dv">1</span>;
    <span class="dt">$display</span>(<span class="st">&quot;key = %c&quot;</span>, ch[i]);
    i = i<span class="dv">+1</span>;
  <span class="kw">end</span>
<span class="kw">end</span> 

<span class="kw">endmodule</span>

<span class="kw">module</span> screen;
<span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] ch;
<span class="kw">initial</span> <span class="kw">begin</span>
  main.mcu0.m[<span class="bn">16&#39;h07F2</span>] = <span class="dv">0</span>;
  main.mcu0.m[<span class="bn">16&#39;h07F3</span>] = <span class="dv">0</span>;
<span class="kw">end</span>
<span class="kw">always</span> <span class="bn">#10</span> <span class="kw">begin</span>
  <span class="kw">if</span> (main.mcu0.m[<span class="bn">16&#39;h07F2</span>] == <span class="dv">1</span>) <span class="kw">begin</span>
    ch = main.mcu0.m[<span class="bn">16&#39;h07F3</span>][<span class="dv">7</span>:<span class="dv">0</span>];
    <span class="dt">$display</span>(<span class="st">&quot;screen %c&quot;</span>, ch);
    main.mcu0.m[<span class="bn">16&#39;h07F2</span>] = <span class="dv">0</span>;
  <span class="kw">end</span>
<span class="kw">end</span> 
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>
<span class="dt">reg</span> interrupt;
<span class="dt">reg</span> [<span class="dv">2</span>:<span class="dv">0</span>] irq;

mcu mcu0(clock, interrupt, irq); <span class="co">// 宣告 cpu0mc 處理器</span>
keyboard kb0();
screen   sc0();

<span class="kw">initial</span> <span class="kw">begin</span>
  clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
  interrupt = <span class="dv">0</span>;
  irq = <span class="dv">2</span>;
<span class="kw">end</span>
<span class="kw">always</span> <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10ns 反相，時脈週期為 20ns</span>

<span class="kw">initial</span> <span class="bn">#4000</span> <span class="dt">$finish</span>;      <span class="co">// 停止測試。</span>

<span class="kw">endmodule</span></code></pre>
<h3 id="輸入機器碼與組合語言"><a href="#輸入機器碼與組合語言">輸入機器碼與組合語言</a></h3>
<pre><code>07F0  // 00    WAITK:  LD    0x7F0   ; wait keyboard
9010  // 01            CMP   K0
B000  // 02            JEQ   WAIT
07F1  // 03            LD    0x7F1   ; read key
1011  // 04            ST    KEY
0010  // 05            LD    K0
17F0  // 06            ST    0x7F0   ; release keyboard
07F2  // 07    WAITS:  LD    0x7F2   ; wait screen
0010  // 08            CMP   K0
B007  // 09            JEQ   WAITS
0011  // 0A            LD    KEY     ; print key
17F3  // 0B            ST    0x7F3
F001  // 0C            LDI   1
17F2  // 0D            ST    0x7F2   ; eanble screen
A000  // 0E            JMP   WAIT
0000  // 0F
0000  // 10    K0:     WORD  0
0000  // 11    KEY:    WORD  0</code></pre>
<h3 id="執行結果-3"><a href="#執行結果-3">執行結果</a></h3>
<pre><code>D:\Dropbox\Public\web\oc\code\mcu0&gt;iverilog -o mcu0io mcu0io.v

D:\Dropbox\Public\web\oc\code\mcu0&gt;vvp mcu0io
WARNING: mcu0io.v:29: $readmemh(mcu0io.hex): Not enough words in the file for th
e requested range [0:4095].
00000000 07f0
00000001 9010
00000002 b000
00000003 07f1
00000004 1011
00000005 0010
00000006 17f0
00000007 07f2
00000008 0010
00000009 b007
0000000a 0011
0000000b 17f3
0000000c f001
0000000d 17f2
0000000e a000
0000000f 0000
00000010 0000
00000011 0000
00000012 xxxx
00000013 xxxx
00000014 xxxx
00000015 xxxx
00000016 xxxx
00000017 xxxx
00000018 xxxx
00000019 xxxx
0000001a xxxx
0000001b xxxx
0000001c xxxx
0000001d xxxx
0000001e xxxx
0000001f xxxx
  10ns PC=0000 IR=07f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = h
  30ns PC=0001 IR=9010, SW=4000, A=    0 SP=xxxx LR=xxxx
  50ns PC=0002 IR=b000, SW=4000, A=    0 SP=xxxx LR=xxxx
  70ns PC=0000 IR=07f0, SW=4000, A=    1 SP=xxxx LR=xxxx
  90ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
 110ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
 130ns PC=0003 IR=07f1, SW=0000, A=  104 SP=xxxx LR=xxxx
 150ns PC=0004 IR=1011, SW=0000, A=  104 SP=xxxx LR=xxxx
 170ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 190ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = e
 210ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
 230ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 250ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
 270ns PC=000a IR=0011, SW=0000, A=  104 SP=xxxx LR=xxxx
 290ns PC=000b IR=17f3, SW=0000, A=  104 SP=xxxx LR=xxxx
 310ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
 330ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen h
 350ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
 370ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
 390ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
 410ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
 430ns PC=0003 IR=07f1, SW=0000, A=  101 SP=xxxx LR=xxxx
 450ns PC=0004 IR=1011, SW=0000, A=  101 SP=xxxx LR=xxxx
 470ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 490ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = l
 510ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
 530ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 550ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
 570ns PC=000a IR=0011, SW=0000, A=  101 SP=xxxx LR=xxxx
 590ns PC=000b IR=17f3, SW=0000, A=  101 SP=xxxx LR=xxxx
 610ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
 630ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen e
 650ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
 670ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
 690ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
 710ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
 730ns PC=0003 IR=07f1, SW=0000, A=  108 SP=xxxx LR=xxxx
 750ns PC=0004 IR=1011, SW=0000, A=  108 SP=xxxx LR=xxxx
 770ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 790ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = l
 810ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
 830ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
 850ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
 870ns PC=000a IR=0011, SW=0000, A=  108 SP=xxxx LR=xxxx
 890ns PC=000b IR=17f3, SW=0000, A=  108 SP=xxxx LR=xxxx
 910ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
 930ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen l
 950ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
 970ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
 990ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
1010ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
1030ns PC=0003 IR=07f1, SW=0000, A=  108 SP=xxxx LR=xxxx
1050ns PC=0004 IR=1011, SW=0000, A=  108 SP=xxxx LR=xxxx
1070ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1090ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = o
1110ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
1130ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1150ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
1170ns PC=000a IR=0011, SW=0000, A=  108 SP=xxxx LR=xxxx
1190ns PC=000b IR=17f3, SW=0000, A=  108 SP=xxxx LR=xxxx
1210ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
1230ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen l
1250ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
1270ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
1290ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
1310ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
1330ns PC=0003 IR=07f1, SW=0000, A=  111 SP=xxxx LR=xxxx
1350ns PC=0004 IR=1011, SW=0000, A=  111 SP=xxxx LR=xxxx
1370ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1390ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key =
1410ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
1430ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1450ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
1470ns PC=000a IR=0011, SW=0000, A=  111 SP=xxxx LR=xxxx
1490ns PC=000b IR=17f3, SW=0000, A=  111 SP=xxxx LR=xxxx
1510ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
1530ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen o
1550ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
1570ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
1590ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
1610ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
1630ns PC=0003 IR=07f1, SW=0000, A=   32 SP=xxxx LR=xxxx
1650ns PC=0004 IR=1011, SW=0000, A=   32 SP=xxxx LR=xxxx
1670ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1690ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = v
1710ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
1730ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1750ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
1770ns PC=000a IR=0011, SW=0000, A=   32 SP=xxxx LR=xxxx
1790ns PC=000b IR=17f3, SW=0000, A=   32 SP=xxxx LR=xxxx
1810ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
1830ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen
1850ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
1870ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
1890ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
1910ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
1930ns PC=0003 IR=07f1, SW=0000, A=  118 SP=xxxx LR=xxxx
1950ns PC=0004 IR=1011, SW=0000, A=  118 SP=xxxx LR=xxxx
1970ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
1990ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = e
2010ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
2030ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2050ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
2070ns PC=000a IR=0011, SW=0000, A=  118 SP=xxxx LR=xxxx
2090ns PC=000b IR=17f3, SW=0000, A=  118 SP=xxxx LR=xxxx
2110ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
2130ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen v
2150ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
2170ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
2190ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
2210ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
2230ns PC=0003 IR=07f1, SW=0000, A=  101 SP=xxxx LR=xxxx
2250ns PC=0004 IR=1011, SW=0000, A=  101 SP=xxxx LR=xxxx
2270ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2290ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = r
2310ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
2330ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2350ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
2370ns PC=000a IR=0011, SW=0000, A=  101 SP=xxxx LR=xxxx
2390ns PC=000b IR=17f3, SW=0000, A=  101 SP=xxxx LR=xxxx
2410ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
2430ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen e
2450ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
2470ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
2490ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
2510ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
2530ns PC=0003 IR=07f1, SW=0000, A=  114 SP=xxxx LR=xxxx
2550ns PC=0004 IR=1011, SW=0000, A=  114 SP=xxxx LR=xxxx
2570ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2590ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = i
2610ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
2630ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2650ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
2670ns PC=000a IR=0011, SW=0000, A=  114 SP=xxxx LR=xxxx
2690ns PC=000b IR=17f3, SW=0000, A=  114 SP=xxxx LR=xxxx
2710ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
2730ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen r
2750ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
2770ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
2790ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
2810ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
2830ns PC=0003 IR=07f1, SW=0000, A=  105 SP=xxxx LR=xxxx
2850ns PC=0004 IR=1011, SW=0000, A=  105 SP=xxxx LR=xxxx
2870ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2890ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = l
2910ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
2930ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
2950ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
2970ns PC=000a IR=0011, SW=0000, A=  105 SP=xxxx LR=xxxx
2990ns PC=000b IR=17f3, SW=0000, A=  105 SP=xxxx LR=xxxx
3010ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
3030ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen i
3050ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
3070ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
3090ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
3110ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
3130ns PC=0003 IR=07f1, SW=0000, A=  108 SP=xxxx LR=xxxx
3150ns PC=0004 IR=1011, SW=0000, A=  108 SP=xxxx LR=xxxx
3170ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3190ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = o
3210ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
3230ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3250ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
3270ns PC=000a IR=0011, SW=0000, A=  108 SP=xxxx LR=xxxx
3290ns PC=000b IR=17f3, SW=0000, A=  108 SP=xxxx LR=xxxx
3310ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
3330ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen l
3350ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
3370ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
3390ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
3410ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
3430ns PC=0003 IR=07f1, SW=0000, A=  111 SP=xxxx LR=xxxx
3450ns PC=0004 IR=1011, SW=0000, A=  111 SP=xxxx LR=xxxx
3470ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3490ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = g
3510ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
3530ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3550ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
3570ns PC=000a IR=0011, SW=0000, A=  111 SP=xxxx LR=xxxx
3590ns PC=000b IR=17f3, SW=0000, A=  111 SP=xxxx LR=xxxx
3610ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
3630ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen o
3650ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
3670ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
3690ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx
3710ns PC=0002 IR=b000, SW=0000, A=    1 SP=xxxx LR=xxxx
3730ns PC=0003 IR=07f1, SW=0000, A=  103 SP=xxxx LR=xxxx
3750ns PC=0004 IR=1011, SW=0000, A=  103 SP=xxxx LR=xxxx
3770ns PC=0005 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3790ns PC=0006 IR=17f0, SW=0000, A=    0 SP=xxxx LR=xxxx
key = !
3810ns PC=0007 IR=07f2, SW=0000, A=    0 SP=xxxx LR=xxxx
3830ns PC=0008 IR=0010, SW=0000, A=    0 SP=xxxx LR=xxxx
3850ns PC=0009 IR=b007, SW=0000, A=    0 SP=xxxx LR=xxxx
3870ns PC=000a IR=0011, SW=0000, A=  103 SP=xxxx LR=xxxx
3890ns PC=000b IR=17f3, SW=0000, A=  103 SP=xxxx LR=xxxx
3910ns PC=000c IR=f001, SW=0000, A=    1 SP=xxxx LR=xxxx
3930ns PC=000d IR=17f2, SW=0000, A=    1 SP=xxxx LR=xxxx
screen g
3950ns PC=000e IR=a000, SW=0000, A=    1 SP=xxxx LR=xxxx
3970ns PC=0000 IR=07f0, SW=0000, A=    1 SP=xxxx LR=xxxx
3990ns PC=0001 IR=9010, SW=0000, A=    1 SP=xxxx LR=xxxx</code></pre>
<h3 id="結語-7"><a href="#結語-7">結語</a></h3>
<p>以上的輸出入方式，並非典型的設計，而是屬於「系統單晶片」(SOC) 的設計方式，因此直接將「鍵盤」與「螢幕」的 輸出入暫存器直接內建在 MCU0 的記憶體之內，這樣的設計會比將「輸出入控制卡」與「CPU」分開的方式更容易一些， 但是由於這種 ASIC 的量產費用昂貴，所以目前還很少有這種設計方式。</p>
<p>不過、就簡單性而言，這樣的設計確實非常簡單，因此符合「開放電腦計畫」的 Keep it Simple and Stupid (KISS) 原則， 所以我們先介紹這樣一個簡易的輸出入設計方式，以便讓讀者能從最簡單的架構入手。</p>
<h1 id="記憶系統-storage"><a href="#記憶系統-storage">記憶系統 (Storage)</a></h1>
<p>除了記憶體之外，電腦裏還有隨身碟、記憶卡、硬碟、光碟、磁帶等儲存裝置，這些裝置構成一整個儲存體系，只有充分考慮這些儲存體的速度問題，才能讓電腦得到最好的效能。</p>
<p>事實上、記憶體也有很多種，而且速度不一，像是靜態記憶體 SRAM、動態記憶體 DRAM、唯讀記憶體 ROM 等等，而且靜態記憶體的速度又可以分為很多種等級，因此整個儲存體會形成一個多層次不同速度的記憶體階層。</p>
<p>「高階處理器」與「微處理器」之間最大的差別，是「高階處理器」會利用各種記憶單元的速度差異，有效的安排並平衡「既快又大」的這種速度與大小的考量。</p>
<p>因此、「高階處理器」通常有「快取」(cache)、「記憶體管理單元」(Memory Management Unit, MMU) 等機制，以便能讓電腦能夠「容量又大、速度又快」。</p>
<p>要能夠讓「高階處理器」充分利用這種「記憶體階層」特性，首先讓我們來看看一個經典的「三階層」情況，那就是 (cache/memory/disk)，如下圖所示。</p>
<h2 id="記憶體階層-memory-hierarchy"><a href="#記憶體階層-memory-hierarchy">記憶體階層 (Memory Hierarchy)</a></h2>
<div class="figure">
<img src="../img/hierarchy3.jpg" alt="圖、常見的三層式記憶體階層" /><p class="caption">圖、常見的三層式記憶體階層</p>
</div>
<p>在上圖中，cache 是直接封裝在 CPU 內部的靜態記憶體，其運作速度與 CPU 的內部電路一樣快，因此可以在 1 個 Clock Cycle 之內完成存取。</p>
<p>而身為主記憶體的 DRAM，速度比靜態記憶體慢上數十倍，因此必須耗費幾十個 Cycle 才能完成存取。</p>
<p>最下層的「硬碟」 (hard disk) 速度更慢，由於依賴讀寫頭與硬盤轉動的機械性動作，因此又比 DRAM 慢上數百倍 (雖然轉到了之後讀取還算快速，但是仍然相對緩慢，而且每次必須讀一大塊，否則轉了好久才讀 1 個 byte 將會慢如蝸牛)。</p>
<p>當然、有些電腦包含更多種類的記憶單元，這些記憶裝置的速度與容量不一，以下是一個更多層次的記憶階層範例。</p>
<div class="figure">
<img src="../img/hierarchy.jpg" alt="圖、更多層次的記憶體階層" /><p class="caption">圖、更多層次的記憶體階層</p>
</div>
<p>為了要讓電腦能夠又快又大，「高階處理器」通常採用了「快取」(cache) 與「記憶體管理單元」(MMU) 等兩個技術，其中的 cache 位於 CPU 內部，用來儲存常用的「指令與資料」，而 MMU 則是利用「分段或分頁」等機制，讓記憶體管理更有效率，甚至可以用「虛擬記憶體」技術把「硬碟」拿來當「備援記憶體」使用，讓容量可以進一步提升。</p>
<p>當然、要使用這些「快取」與「暫存」技術，都必須付出相對應的代價，那就是讓你的 CPU 設計更加複雜，而且有時也會「快不起來」。</p>
<p>(套句俗話說，出來混的，總有一天是要還的，CPU 的設計也是如此)</p>
<h2 id="快取記憶體-cache"><a href="#快取記憶體-cache">快取記憶體 (Cache)</a></h2>
<p>傳統的處理器通常採用「單一匯流排馮紐曼架構」設計，這種架構非常簡單且易懂，如下圖所示：</p>
<div class="figure">
<img src="../img/voneumann1bus.jpg" alt="圖、單一匯流排的馮紐曼架構" /><p class="caption">圖、單一匯流排的馮紐曼架構</p>
</div>
<p>但是、以當今的技術，上圖中的記憶體通常採用 DRAM 為主。</p>
<p>這是因為快速的靜態記憶體 (SRAM) 仍然相當昂貴，而速度慢上數十倍的動態記憶體 (DRAM) 則相對便宜，因此電腦的主記憶體通常仍然採用 DRAM 為主。</p>
<p>如果要讓 CPU 的執行速度更快，就不能讓 CPU 遷就於 DRAM 的速度跟著變慢，此時我們可以在 CPU 內部加入一個快取記憶體 (cache)，讓位於 DRAM 中常用到的指令與資料放入快取當中，如下圖所示：</p>
<div class="figure">
<img src="../img/voneumann1cache.jpg" alt="圖、單一匯流排的馮紐曼架構" /><p class="caption">圖、單一匯流排的馮紐曼架構</p>
</div>
<p>當 CPU 想要執行一個指令時，如果該指令已經在 cache 當中，就不需要讀取 DRAM，因此「指令擷取」階段就可以快上數十倍。</p>
<p>當然、如果該指令需要存取資料，而該資料已經在 cache 當中了，那麼 CPU 就不需要從 DRAM 中讀取資料，因此「資料讀取」階段就可以快上數十倍。</p>
<p>當需要寫入資料時，如果暫時先寫到 cache 當中，而不是直接寫回 DRAM，那麼「資料寫入」的動作就可以快上數十倍。</p>
<p>當然、上述的美好情況不會永遠都成立，假如想存取的指令或資料不存在 cache 當中，那麼就必須從 DRAM 讀取資料，這時 CPU 的速度就會被打回原形，變成與 DRAM 的速度一樣。</p>
<p>而且、當資料被放入 cache 之後，由於 DRAM 當中還有一份同樣的資料，要又如何才能快速的查出資料是否在 cache 當中，就是一個不容易的問題了。這個問題的解決，必須依靠某種「記憶體位址的標籤」 (tag)，透過這種標籤我們可以查出某個位址的內容到底是在 cache 當中的那一格。</p>
<p>而標籤的設計方法，大致可分為「直接映射」 (direct-mapping)，「關連映射」(associate-mapping)與「組關連映射」 (set associative-mapping) 等幾種方法。其中最常採用的是後者。</p>
<p>對這些 cache 作法的細節有興趣的讀者，可以參考下列文件。</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">維基百科：CPU快取</a></li>
</ul>
<h1 id="高階處理器-processor"><a href="#高階處理器-processor">高階處理器 (Processor)</a></h1>
<p>在前一章當中，我們說明了「微處理器」的設計方式，在本章中、我們將說明「高階處理器」的設計方式。</p>
<p>與「微處理器」比起來，「高階處理器」除了指令寬度較大之外，能定址的記憶體空間通常也很大，而且會內建「記憶體管理單元」(Memory Management Unit, MMU) 與多層快取機制 (cache) 等等，這些都是為了充分發揮處理器的效能的設計，這也正是為何稱為「高階」處理器的原因。</p>
<p>在本章當中，我們將透過 cpu0 這個架構，給出一個「處理器」的簡易範例之後，就開始針對現今的高階處理器之結構進行探討，以便讓讀者在能清楚的理解現代高階處理器的設計原理與特性。</p>
<h2 id="哈佛架構-harvard-architecture"><a href="#哈佛架構-harvard-architecture">哈佛架構 (Harvard Architecture)</a></h2>
<p>在「單一匯流排馮紐曼架構」之下，由於指令與資料放在同一個記憶體當中，而且只有一套匯流排，因此指令與資料勢必無法同時存取。</p>
<p>如果、我們希望同時進行指令與資料的存取，那麼就可以將指令與資料分別放在兩塊不同的記憶體當中，並且各用一套內部匯流排連接到 CPU，這樣就有可能同時存取「指令和資料」，也就有可能將「指令擷取」(instruction fetch) 與「資料存取」 (data access) 階段重疊執行了。</p>
<div class="figure">
<img src="../img/harvard2memory.jpg" alt="圖、指令與資料分開為兩套記憶體的哈佛架構" /><p class="caption">圖、指令與資料分開為兩套記憶體的哈佛架構</p>
</div>
<p>採用「指令與資料分開」的兩套記憶體模式，如果都是 DRAM 的話，那麼該處理器仍然會式非常緩慢的，因為受限於 DRAM 的速度限制，因此這種方式根本就是「花了兩倍力氣卻得不到太多好處」，可以說是一種很爛的設計。</p>
<p>但是、假如我們不是將主記憶體分為兩套，而是將 cache 分為「指令快取」 (i-cache) 與「資料快取」 (d-cache) 的「變種哈佛架構」話，那麼速度就真的是會變快了。</p>
<div class="figure">
<img src="../img/harvard2cache.jpg" alt="圖、採用兩套快取的單一匯流排哈佛架構" /><p class="caption">圖、採用兩套快取的單一匯流排哈佛架構</p>
</div>
<p>不過、其實還可以變得更快，只要我們能夠用「流水線的模式」，就能讓 CPU 快上五倍，這必須讓指令的每個階段都能重疊起來才行 (包含「指令擷取」與「資料存取」階段的重疊，這也正是為何要討論「哈佛架構」的原因)。</p>
<h2 id="流水線架構-pipeline"><a href="#流水線架構-pipeline">流水線架構 (Pipeline)</a></h2>
<p>Pipeline 是一種讓指令分成幾個步驟，然後兩個指令的不同步驟可以「瀑布式重疊」的方法。</p>
<p>舉例而言、假如我們將一個指令的執行分為五個步驟如下：</p>
<ol style="list-style-type: decimal">
<li>擷取 F (Fatch)</li>
<li>解碼 D (Decode)</li>
<li>計算 C (Compute)</li>
<li>存取 M (Memory Access)</li>
<li>寫回 W (Write Back)</li>
</ol>
<p>那麼在理想的情況下，我們就能夠讓這些指令充分的重疊執行，如下圖所示。</p>
<div class="figure">
<img src="../img/Pipeline1.jpg" alt="圖、理想的 Pipeline 執行情況" /><p class="caption">圖、理想的 Pipeline 執行情況</p>
</div>
<p>如此、只要讓每個步驟所需的時間幾乎一樣，然後將 Clock 調快五倍，就能讓速度整整加快五倍。</p>
<p>這就是所謂的 Pipeline 流水線架構的原理。</p>
<p>然而、流水線架構的處理器設計比較困難，因為上圖的理想情況畢竟只是理想，現實生活中有很多因素會干擾流水線的運行，造成流水線某個階段受到阻礙無法完成，必須暫停等後某個步驟完成，這種暫停會形成流水線當中的氣泡 (bubble)，這種情況統稱為「指令圍障」 (instruction hazard)。</p>
<p>Hazard 有好幾種，像是資料圍障 (data hazard)、快取失敗 (cache miss)、分支延遲 (branch penalty) 等等。</p>
<p>流水線架構的設計，通常必須用暫存器圍牆 (Register wall) 將每個步驟之間相互隔開，以避免線路之間的干擾，如下所示：</p>
<div class="figure">
<img src="../img/pipeline_register_wall.jpg" alt="圖、以暫存器圍牆分隔流水線架構的每個階段" /><p class="caption">圖、以暫存器圍牆分隔流水線架構的每個階段</p>
</div>
<p>Pipeline 處理器最困難的地方，就是要盡可能的減少這些 hazard。然而、有些 hazard 是可以用硬體方式消除的，但是很多 hazard 的消除卻是需要編譯器的配合才能夠做得到。</p>
<p>透過編譯器的協助減少 hazard 的方法，包括「指令重排、插入 NOP 指令、分支預測」等等。</p>
<p>想要進一步瞭解流水線架構細節的讀者，可以參考下列文件。</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E7%AE%A1%E7%B7%9A">維基百科：流水線</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%B7%9A%E5%8C%96">維基百科：指令管線化</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">維基百科：分支預測器</a></li>
</ul>
<h2 id="cpu0-迷你版---cpu0m"><a href="#cpu0-迷你版---cpu0m">CPU0 迷你版 - CPU0m</a></h2>
<p>在本章中，我們將透過設計一顆只支援 4 個指令的超微小處理器 CPU0m (CPU0-Mini) 開始，來解說處理器的設計方式。</p>
<h3 id="只有-4-個指令的處理器---cpu0m"><a href="#只有-4-個指令的處理器---cpu0m">只有 4 個指令的處理器 - CPU0m</a></h3>
<p>在此、我們將用最簡單的方式，在完全不考慮成本與實用性的情況之下，設計一個將記憶體嵌入處理器內部的 CPU，也就是整個記憶體都用 Verilog 內嵌在 CPU 理面。</p>
<p>我們從 CPU0 的指令集當中，挑出了以下的四個指令，以便寫出一個可以計算 1+2+.....+n+.... 的組合語言程式 (喔！不、應該說是機器語言程式)，然後用 Verilog 實作一個可以執行這些指令的 CPU0m 處理器。</p>
<table>
<thead>
<tr class="header">
<th align="left">格式</th>
<th align="left">指令</th>
<th align="left">OP</th>
<th align="left">說明</th>
<th align="left">語法</th>
<th align="left">語意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">L</td>
<td align="left">LD</td>
<td align="left">00</td>
<td align="left">載入word</td>
<td align="left">LD Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">ST</td>
<td align="left">01</td>
<td align="left">儲存word</td>
<td align="left">ST Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ADD</td>
<td align="left">13</td>
<td align="left">加法</td>
<td align="left">ADD Ra, Rb, Rc</td>
<td align="left">Ra=Rb+Rc</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JMP</td>
<td align="left">26</td>
<td align="left">跳躍 (無條件)</td>
<td align="left">JMP Cx</td>
<td align="left">PC=PC+Cx</td>
</tr>
</tbody>
</table>
<p>然後，我們就可以用這幾個指令寫出以下的程式：</p>
<table>
<thead>
<tr class="header">
<th align="left">位址</th>
<th align="left">機器碼</th>
<th align="left">標記</th>
<th align="left">組合語言</th>
<th align="left">對照的 C 語言</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0000</td>
<td align="left">001F0018</td>
<td align="left"></td>
<td align="left">LD R1, K1</td>
<td align="left">R1 = K1</td>
</tr>
<tr class="even">
<td align="left">0004</td>
<td align="left">002F0010</td>
<td align="left"></td>
<td align="left">LD R2, K0</td>
<td align="left">R2 = K0</td>
</tr>
<tr class="odd">
<td align="left">0008</td>
<td align="left">003F0014</td>
<td align="left"></td>
<td align="left">LD R3, SUM</td>
<td align="left">R3 = SUM</td>
</tr>
<tr class="even">
<td align="left">000C</td>
<td align="left">13221000</td>
<td align="left">LOOP:</td>
<td align="left">ADD R2, R2, R1</td>
<td align="left">R2 = R2 + R1</td>
</tr>
<tr class="odd">
<td align="left">0010</td>
<td align="left">13332000</td>
<td align="left"></td>
<td align="left">ADD R3, R3, R2</td>
<td align="left">R3 = R3 + R2</td>
</tr>
<tr class="even">
<td align="left">0014</td>
<td align="left">26FFFFF4</td>
<td align="left"></td>
<td align="left">JMP LOOP</td>
<td align="left">goto LOOP</td>
</tr>
<tr class="odd">
<td align="left">0018</td>
<td align="left">00000000</td>
<td align="left">K0:</td>
<td align="left">WORD 0</td>
<td align="left">int K0=0</td>
</tr>
<tr class="even">
<td align="left">001C</td>
<td align="left">00000001</td>
<td align="left">K1:</td>
<td align="left">WORD 1</td>
<td align="left">int K1=1</td>
</tr>
<tr class="odd">
<td align="left">0020</td>
<td align="left">00000000</td>
<td align="left">SUM:</td>
<td align="left">WORD 0</td>
<td align="left">int SUM=0</td>
</tr>
</tbody>
</table>
<p>這個程式的行為模式，是會讓暫存器 R3 (對應到 SUM) 從 0, 1, 1+2, 1+2+3, .... 一路向上跑，而且是永無止境的無窮迴圈。 因此我們會看到 R3 的內容會是 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 ... ，的情況。</p>
<p>透過 CPU0m ，讀者將可以開始瞭解一顆 CPU 的結構與設計方式，並且更清楚的理解 CPU 的控制單元之功能。</p>
<h3 id="指令提取解碼與執行"><a href="#指令提取解碼與執行">指令提取、解碼與執行</a></h3>
<p>CPU0 在執行一個指令時，必須經過提取、解碼與執行等三大階段，以下是這三個階段的詳細步驟。</p>
<pre><code>階段 (a)：提取階段
    動作1、提取指令      ：IR = m[PC]
    動作2、更新計數器    ：PC = PC + 4
階段 (b)：解碼階段
    動作3、解碼          ：將 IR 分解為 (運算代碼 op, 暫存器代號 ra, rb, rc, 常數 c5, c16, c24 等欄位)。
階段 (c)：執行階段
    動作4、執行          ：根據運算代碼 op，執行對應的動作。</code></pre>
<p>執行階段的動作根據指令的類型而有所不同。舉例而言，假如執行的指令是 ADD R1, R2, R1，那麼執行階段所進行的動作如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">格式</th>
<th align="left">指令</th>
<th align="left">OP</th>
<th align="left">說明</th>
<th align="left">語法</th>
<th align="left">執行動作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">L</td>
<td align="left">LD</td>
<td align="left">00</td>
<td align="left">載入word</td>
<td align="left">LD Ra, [Rb+Cx]</td>
<td align="left">R[ra] = m[rb+c16] (4byte)</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">ST</td>
<td align="left">01</td>
<td align="left">儲存word</td>
<td align="left">ST Ra, [Rb+Cx]</td>
<td align="left">m[rb+c16] = R[ra] (4byte)</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ADD</td>
<td align="left">13</td>
<td align="left">加法</td>
<td align="left">ADD Ra, Rb, Rc</td>
<td align="left">R[ra] = R[rb]+R[rc]</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JMP</td>
<td align="left">26</td>
<td align="left">跳躍 (無條件)</td>
<td align="left">JMP Cx</td>
<td align="left">PC = PC+c24</td>
</tr>
</tbody>
</table>
<h3 id="cpu0m-模組"><a href="#cpu0m-模組">CPU0m 模組</a></h3>
<p>以下就是我們所設計的 CPU0m 模組，以及測試的主程式，我們在程式中寫了詳細的說明，請讀者對照閱讀。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201310/code/CPU0m.v">CPU0m</a></p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define PC R[15] </span><span class="co">// 程式計數器 PC 其實是 R[15] 的別名</span>

<span class="kw">module</span> CPU(<span class="dt">input</span> clock); <span class="co">// CPU0-Mini 的快取版：cpu0m 模組</span>
  <span class="dt">parameter</span> [<span class="dv">7</span>:<span class="dv">0</span>] LD = <span class="bn">8&#39;h00</span>, ST=<span class="bn">8&#39;h01</span>, ADD=<span class="bn">8&#39;h13</span>, JMP=<span class="bn">8&#39;h26</span>; <span class="co">// 支援 4 個指令</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] R [<span class="dv">0</span>:<span class="dv">15</span>];   <span class="co">// 宣告暫存器 R[0..15] 等 16 個 32 位元暫存器</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] IR;         <span class="co">// 指令暫存器 IR</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">128</span>];          <span class="co">// 內部的快取記憶體</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] op;                 <span class="co">// 變數：運算代碼 op</span>
  <span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra, rb, rc;         <span class="co">// 變數：暫存器代號 ra, rb, rc</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">11</span>:<span class="dv">0</span>] cx12;       <span class="co">// 變數：12 位元常數 cx12</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] cx16;       <span class="co">// 變數：16 位元常數 cx16</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">23</span>:<span class="dv">0</span>] cx24;       <span class="co">// 變數：24 位元常數 cx24</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] addr;       <span class="co">// 變數：暫存記憶體位址</span>

  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    <span class="ot">`PC</span> = <span class="dv">0</span>;                    <span class="co">// 將 PC 設為起動位址 0</span>
    R[<span class="dv">0</span>] = <span class="dv">0</span>;                   <span class="co">// 將 R[0] 暫存器強制設定為 0</span>
    {m[<span class="dv">0</span>],m[<span class="dv">1</span>],m[<span class="dv">2</span>],m[<span class="dv">3</span>]}    = <span class="bn">32&#39;h001F0018</span>; <span class="co">// 0000       LD   R1, K1</span>
    {m[<span class="dv">4</span>],m[<span class="dv">5</span>],m[<span class="dv">6</span>],m[<span class="dv">7</span>]}    = <span class="bn">32&#39;h002F0010</span>; <span class="co">// 0004       LD   R2, K0</span>
    {m[<span class="dv">8</span>],m[<span class="dv">9</span>],m[<span class="dv">10</span>],m[<span class="dv">11</span>]}  = <span class="bn">32&#39;h003F0014</span>; <span class="co">// 0008       LD   R3, SUM</span>
    {m[<span class="dv">12</span>],m[<span class="dv">13</span>],m[<span class="dv">14</span>],m[<span class="dv">15</span>]}= <span class="bn">32&#39;h13221000</span>; <span class="co">// 000C LOOP: ADD  R2, R2, R1</span>
    {m[<span class="dv">16</span>],m[<span class="dv">17</span>],m[<span class="dv">18</span>],m[<span class="dv">19</span>]}= <span class="bn">32&#39;h13332000</span>; <span class="co">// 0010       ADD  R3, R3, R2</span>
    {m[<span class="dv">20</span>],m[<span class="dv">21</span>],m[<span class="dv">22</span>],m[<span class="dv">23</span>]}= <span class="bn">32&#39;h26FFFFF4</span>; <span class="co">// 0014       JMP  LOOP</span>
    {m[<span class="dv">24</span>],m[<span class="dv">25</span>],m[<span class="dv">26</span>],m[<span class="dv">27</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0018 K0:   WORD 0</span>
    {m[<span class="dv">28</span>],m[<span class="dv">29</span>],m[<span class="dv">30</span>],m[<span class="dv">31</span>]}= <span class="bn">32&#39;h00000001</span>; <span class="co">// 001C K1:   WORD 1</span>
    {m[<span class="dv">32</span>],m[<span class="dv">33</span>],m[<span class="dv">34</span>],m[<span class="dv">35</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0020 SUM:  WORD 0</span>
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
      IR = {m[<span class="ot">`PC</span>], m[<span class="ot">`PC</span><span class="dv">+1</span>], m[<span class="ot">`PC</span><span class="dv">+2</span>], m[<span class="ot">`PC</span><span class="dv">+3</span>]};  <span class="co">// 指令擷取階段：IR=m[PC], 4 個 Byte 的記憶體</span>
      <span class="ot">`PC</span> = <span class="ot">`PC</span><span class="dv">+4</span>;                                  <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
      {op,ra,rb,rc,cx12} = IR;                      <span class="co">// 解碼階段：將 IR 解為 {op, ra, rb, rc, cx12}</span>
      cx24 = IR[<span class="dv">23</span>:<span class="dv">0</span>];                              <span class="co">//           解出 IR[23:0] 放入 cx24</span>
      cx16 = IR[<span class="dv">15</span>:<span class="dv">0</span>];                              <span class="co">//           解出 IR[15:0] 放入 cx16</span>
      addr = R[rb]+cx16;                              <span class="co">// 記憶體存取位址 = PC+cx16</span>
      <span class="kw">case</span> (op) <span class="co">// 根據 OP 執行對應的動作</span>
        <span class="dv">LD:</span> <span class="kw">begin</span>   <span class="co">// 載入指令： R[ra] = m[addr]</span>
          R[ra] = {m[addr], m[addr<span class="dv">+1</span>], m[addr<span class="dv">+2</span>], m[addr<span class="dv">+3</span>]};
          <span class="dt">$write</span>(<span class="st">&quot;%4dns %8x : LD  %x,%x,%-4x&quot;</span>, <span class="dt">$stime</span>, <span class="ot">`PC</span>, ra, rb, cx16);
          <span class="kw">end</span>
        <span class="dv">ST:</span> <span class="kw">begin</span>   <span class="co">// 儲存指令： m[addr] = R[ra]</span>
          {m[addr], m[addr<span class="dv">+1</span>], m[addr<span class="dv">+2</span>], m[addr<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$write</span>(<span class="st">&quot;%4dns %8x : ST  %x,%x,%-4x&quot;</span>, <span class="dt">$stime</span>, <span class="ot">`PC</span>, ra, rb, cx16);
          <span class="kw">end</span>
        <span class="dv">ADD:</span> <span class="kw">begin</span>  <span class="co">// 加法指令： R[ra] = R[rb]+R[rc]</span>
          R[ra] = R[rb]+R[rc];
          <span class="dt">$write</span>(<span class="st">&quot;%4dns %8x : ADD %x,%x,%-4x&quot;</span>, <span class="dt">$stime</span>, <span class="ot">`PC</span>, ra, rb, rc);
          <span class="kw">end</span>
        <span class="dv">JMP:</span><span class="kw">begin</span>   <span class="co">// 跳躍指令： PC = PC + cx24</span>
          <span class="ot">`PC</span> = <span class="ot">`PC</span> + cx24; <span class="co">// 跳躍目標位址=PC+cx</span>
          <span class="dt">$write</span>(<span class="st">&quot;%4dns %8x : JMP %-8x&quot;</span>, <span class="dt">$stime</span>, <span class="ot">`PC</span>, cx24);
          <span class="kw">end</span>
      <span class="kw">endcase</span>
      <span class="dt">$display</span>(<span class="st">&quot; R[%2d]=%4d&quot;</span>, ra, R[ra]); <span class="co">// 顯示目標暫存器的值</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>

cpu cpu0m(clock);          <span class="co">// 宣告 cpu0m 處理器</span>

<span class="kw">initial</span> clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
<span class="kw">always</span> <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10 奈秒將 clock 反相，產生週期為 20 奈秒的時脈</span>
<span class="kw">initial</span> <span class="bn">#640</span> <span class="dt">$finish</span>;       <span class="co">// 在 640 奈秒的時候停止測試。(因為這時的 R[1] 恰好是 1+2+...+10=55 的結果)</span>
<span class="kw">endmodule</span></code></pre>
<h3 id="測試結果"><a href="#測試結果">測試結果</a></h3>
<p>上述程式使用 icarus 測試與執行的結果如下所示。</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o cpu0m cpu0m.v

D:\Dropbox\Public\web\oc\code&gt;vvp cpu0m
  10ns 00000004 : LD  1,f,0018 R[ 1]=   1
  30ns 00000008 : LD  2,f,0010 R[ 2]=   0
  50ns 0000000c : LD  3,f,0014 R[ 3]=   0
  70ns 00000010 : ADD 2,2,1    R[ 2]=   1
  90ns 00000014 : ADD 3,3,2    R[ 3]=   1
 110ns 0000000c : JMP fffff4   R[15]=  12
 130ns 00000010 : ADD 2,2,1    R[ 2]=   2
 150ns 00000014 : ADD 3,3,2    R[ 3]=   3
 170ns 0000000c : JMP fffff4   R[15]=  12
 190ns 00000010 : ADD 2,2,1    R[ 2]=   3
 210ns 00000014 : ADD 3,3,2    R[ 3]=   6
 230ns 0000000c : JMP fffff4   R[15]=  12
 250ns 00000010 : ADD 2,2,1    R[ 2]=   4
 270ns 00000014 : ADD 3,3,2    R[ 3]=  10
 290ns 0000000c : JMP fffff4   R[15]=  12
 310ns 00000010 : ADD 2,2,1    R[ 2]=   5
 330ns 00000014 : ADD 3,3,2    R[ 3]=  15
 350ns 0000000c : JMP fffff4   R[15]=  12
 370ns 00000010 : ADD 2,2,1    R[ 2]=   6
 390ns 00000014 : ADD 3,3,2    R[ 3]=  21
 410ns 0000000c : JMP fffff4   R[15]=  12
 430ns 00000010 : ADD 2,2,1    R[ 2]=   7
 450ns 00000014 : ADD 3,3,2    R[ 3]=  28
 470ns 0000000c : JMP fffff4   R[15]=  12
 490ns 00000010 : ADD 2,2,1    R[ 2]=   8
 510ns 00000014 : ADD 3,3,2    R[ 3]=  36
 530ns 0000000c : JMP fffff4   R[15]=  12
 550ns 00000010 : ADD 2,2,1    R[ 2]=   9
 570ns 00000014 : ADD 3,3,2    R[ 3]=  45
 590ns 0000000c : JMP fffff4   R[15]=  12
 610ns 00000010 : ADD 2,2,1    R[ 2]=  10
 630ns 00000014 : ADD 3,3,2    R[ 3]=  55</code></pre>
<p>從上述輸出訊息當中，您可以看到程式的執行是正確的，其中 R[2] 從 0, 1, 2, ..... 一路上數， 而 R[3] 則從 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 一路累加上來，完成了我們想要的程式功能。</p>
<h3 id="結語-8"><a href="#結語-8">結語</a></h3>
<p>其實、CPU0m 這樣的設計應該還不能稱之為快取，而是在程式不大的情況之下，將 SRAM 直接包入在 CPU 當中的一種作法， 這種作法的好處是記憶體存取速度很快，但相對的記憶體成本也很貴，因為這些記憶體是直接用靜態記憶體的方式內建在 CPU 當中的。</p>
<p>這種方式比較像 SOC 系統單晶片的做法，在程式很小的情況之下，直接將記憶體包入 SOC 當中，會得到比較高速的電路， 可惜的是這種做法不像目前的電腦架構一樣，是採用外掛 DRAM 的方式，可以大幅降低記憶體的成本，增大記憶體的容量 就是了。</p>
<h2 id="cpu0-完整版----cpu0s"><a href="#cpu0-完整版----cpu0s">CPU0 完整版 -- cpu0s</a></h2>
<p>CPU0 是一個簡易的 32 位元單匯流排處理器，其架構如下圖所示，包含R0..R15, IR, MAR, MDR 等暫存器，其中 IR是指令暫存器， R0 是一個永遠為常數 0 的唯讀暫存器，R15 是程式計數器 (Program Counter : PC)，R14 是連結暫存器 (Link Register : LR)， R13 是堆疊指標暫存器 (Stack Pointer : SP)，而 R12 是狀態暫存器 (Status Word : SW)。</p>
<div class="figure">
<img src="../img/cpu0architecture.jpg" alt="圖、CPU0 的架構圖" /><p class="caption">圖、CPU0 的架構圖</p>
</div>
<h3 id="cpu0-的指令集-1"><a href="#cpu0-的指令集-1">CPU0 的指令集</a></h3>
<p>CPU0 包含『載入儲存』、『運算指令』、『跳躍指令』、『堆疊指令』等四大類指令，以下表格是 CPU0 的指令編碼表，記載了 CPU0 的指令集與每個指令的編碼。</p>
<table>
<thead>
<tr class="header">
<th align="left">格式</th>
<th align="left">指令</th>
<th align="left">OP</th>
<th align="left">說明</th>
<th align="left">語法</th>
<th align="left">語意</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">L</td>
<td align="left">LD</td>
<td align="left">00</td>
<td align="left">載入word</td>
<td align="left">LD Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">ST</td>
<td align="left">01</td>
<td align="left">儲存word</td>
<td align="left">ST Ra, [Rb+Cx]</td>
<td align="left">Ra=[Rb+Cx]</td>
</tr>
<tr class="odd">
<td align="left">L</td>
<td align="left">LDB</td>
<td align="left">02</td>
<td align="left">載入 byte</td>
<td align="left">LDB Ra, [Rb+Cx]</td>
<td align="left">Ra=(byte)[Rb+Cx]</td>
</tr>
<tr class="even">
<td align="left">L</td>
<td align="left">STB</td>
<td align="left">03</td>
<td align="left">儲存 byte</td>
<td align="left">STB Ra, [Rb+Cx]</td>
<td align="left">Ra=(byte)[Rb+Cx]</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">LDR</td>
<td align="left">04</td>
<td align="left">LD的暫存器版</td>
<td align="left">LDR Ra, [Rb+Rc]</td>
<td align="left">Ra=[Rb+Rc]</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">STR</td>
<td align="left">05</td>
<td align="left">ST的暫存器版</td>
<td align="left">STR Ra, [Rb+Rc]</td>
<td align="left">Ra=[Rb+Rc]</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">LBR</td>
<td align="left">06</td>
<td align="left">LDB的暫存器版</td>
<td align="left">LBR Ra, [Rb+Rc]</td>
<td align="left">Ra=(byte)[Rb+Rc]</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">SBR</td>
<td align="left">07</td>
<td align="left">STB的暫存器版</td>
<td align="left">SBR Ra, [Rb+Rc]</td>
<td align="left">Ra=(byte)[Rb+Rc]</td>
</tr>
<tr class="odd">
<td align="left">L</td>
<td align="left">LDI</td>
<td align="left">08</td>
<td align="left">載入常數</td>
<td align="left">LDI Ra, Cx</td>
<td align="left">Ra=Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">CMP</td>
<td align="left">10</td>
<td align="left">比較</td>
<td align="left">CMP Ra, Rb</td>
<td align="left">SW=Ra &gt;=&lt; Rb</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">MOV</td>
<td align="left">12</td>
<td align="left">移動</td>
<td align="left">MOV Ra, Rb</td>
<td align="left">Ra=Rb</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">ADD</td>
<td align="left">13</td>
<td align="left">加法</td>
<td align="left">ADD Ra, Rb, Rc</td>
<td align="left">Ra=Rb+Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">SUB</td>
<td align="left">14</td>
<td align="left">減法</td>
<td align="left">SUB Ra, Rb, Rc</td>
<td align="left">Ra=Rb-Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">MUL</td>
<td align="left">15</td>
<td align="left">乘法</td>
<td align="left">MUL Ra, Rb, Rc</td>
<td align="left">Ra=Rb*Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">DIV</td>
<td align="left">16</td>
<td align="left">除法</td>
<td align="left">DIV Ra, Rb, Rc</td>
<td align="left">Ra=Rb/Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">AND</td>
<td align="left">18</td>
<td align="left">邏輯 AND</td>
<td align="left">AND Ra, Rb, Rc</td>
<td align="left">Ra=Rb and Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">OR</td>
<td align="left">19</td>
<td align="left">邏輯 OR</td>
<td align="left">OR Ra, Rb, Rc</td>
<td align="left">Ra=Rb or Rc</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">XOR</td>
<td align="left">1A</td>
<td align="left">邏輯 XOR</td>
<td align="left">XOR Ra, Rb, Rc</td>
<td align="left">Ra=Rb xor Rc</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ADDI</td>
<td align="left">1B</td>
<td align="left">常數加法</td>
<td align="left">ADDI Ra, Rb, Cx</td>
<td align="left">Ra=Rb + Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">ROL</td>
<td align="left">1C</td>
<td align="left">向左旋轉</td>
<td align="left">ROL Ra, Rb, Cx</td>
<td align="left">Ra=Rb rol Cx</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">ROR</td>
<td align="left">1D</td>
<td align="left">向右旋轉</td>
<td align="left">ROR Ra, Rb, Cx</td>
<td align="left">Ra=Rb ror Cx</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">SHL</td>
<td align="left">1E</td>
<td align="left">向左移位</td>
<td align="left">SHL Ra, Rb, Cx</td>
<td align="left">Ra=Rb &lt;&lt; Cx</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">SHR</td>
<td align="left">1F</td>
<td align="left">向右移位</td>
<td align="left">SHR Ra, Rb, Cx</td>
<td align="left">Ra=Rb &gt;&gt; Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JEQ</td>
<td align="left">20</td>
<td align="left">跳躍 (相等)</td>
<td align="left">JEQ Cx</td>
<td align="left">if SW(=) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JNE</td>
<td align="left">21</td>
<td align="left">跳躍 (不相等)</td>
<td align="left">JNE Cx</td>
<td align="left">if SW(!=) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JLT</td>
<td align="left">22</td>
<td align="left">跳躍 (&lt;)</td>
<td align="left">JLT Cx</td>
<td align="left">if SW(&lt;) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JGT</td>
<td align="left">23</td>
<td align="left">跳躍 (&gt;)</td>
<td align="left">JGT Cx</td>
<td align="left">if SW(&gt;) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JLE</td>
<td align="left">24</td>
<td align="left">跳躍 (&lt;=)</td>
<td align="left">JLE Cx</td>
<td align="left">if SW(&lt;=) PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">JGE</td>
<td align="left">25</td>
<td align="left">跳躍 (&gt;=)</td>
<td align="left">JGE Cx</td>
<td align="left">if SW(&gt;=) PC=PC+Cx</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">JMP</td>
<td align="left">26</td>
<td align="left">跳躍 (無條件)</td>
<td align="left">JMP Cx</td>
<td align="left">PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">SWI</td>
<td align="left">2A</td>
<td align="left">軟體中斷</td>
<td align="left">SWI Cx</td>
<td align="left">LR=PC; PC=Cx; INT=1</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">CALL</td>
<td align="left">2B</td>
<td align="left">跳到副程式</td>
<td align="left">CALL Cx</td>
<td align="left">LR=PC; PC=PC+Cx</td>
</tr>
<tr class="odd">
<td align="left">J</td>
<td align="left">RET</td>
<td align="left">2C</td>
<td align="left">返回</td>
<td align="left">RET</td>
<td align="left">PC=LR</td>
</tr>
<tr class="even">
<td align="left">J</td>
<td align="left">IRET</td>
<td align="left">2D</td>
<td align="left">中斷返回</td>
<td align="left">IRET</td>
<td align="left">PC=LR; INT=0</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">PUSH</td>
<td align="left">30</td>
<td align="left">推入word</td>
<td align="left">PUSH Ra</td>
<td align="left">SP-=4; [SP]=Ra;</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">POP</td>
<td align="left">31</td>
<td align="left">彈出 word</td>
<td align="left">POP Ra</td>
<td align="left">Ra=[SP]; SP+=4;</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">PUSHB</td>
<td align="left">32</td>
<td align="left">推入 byte</td>
<td align="left">PUSHB Ra</td>
<td align="left">SP--; [SP]=Ra; (byte)</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">POPB</td>
<td align="left">33</td>
<td align="left">彈出 byte</td>
<td align="left">POPB Ra</td>
<td align="left">Ra=[SP]; SP++; (byte)</td>
</tr>
</tbody>
</table>
<h3 id="cpu0-指令格式-1"><a href="#cpu0-指令格式-1">CPU0 指令格式</a></h3>
<p>CPU0 所有指令長度均為 32 位元，這些指令也可根據編碼方式分成三種不同的格式，分別是 A 型、J 型與 L 型。</p>
<p>大部分的運算指令屬於A (Arithmatic) 型，而載入儲存指令通常屬於 L (Load &amp; Store) 型，跳躍指令則通常屬於 J (Jump) 型， 這三種型態的指令格式如下圖所示。</p>
<div class="figure">
<img src="../img/cpu0format.jpg" alt="圖、CPU0的指令格式" /><p class="caption">圖、CPU0的指令格式</p>
</div>
<h3 id="狀態暫存器-1"><a href="#狀態暫存器-1">狀態暫存器</a></h3>
<p>R12 狀態暫存器 (Status Word : SW) 是用來儲存 CPU 的狀態值，這些狀態是許多旗標的組合。例如，零旗標 (Zero，簡寫為Z) 代表比較的結果為 0，負旗標 (Negative ，簡寫為N) 代表比較的結果為負值，另外常見的旗標還有進位旗標 (Carry ，簡寫為 C)， 溢位旗標 (Overflow，簡寫為 V) 等等。下圖顯示了 CPU0 的狀態暫存器格式，最前面的四個位元 N、Z、C、V所代表的， 正是上述的幾個旗標值。</p>
<div class="figure">
<img src="../img/cpu0sw.jpg" alt="圖、CPU0 中狀態暫存器 SW 的結構" /><p class="caption">圖、CPU0 中狀態暫存器 SW 的結構</p>
</div>
<p>條件旗標的 N、Z 旗標值可以用來代表比較結果是大於 (&gt;)、等於 (=) 還是小於 (&lt;)，當執行 CMP Ra, Rb 動作後，會有下列三種可能的情形。</p>
<ol style="list-style-type: decimal">
<li>若 Ra &gt; Rb，則 N=0, Z=0。</li>
<li>若 Ra &lt; Rb，則 N=1, Z=0。</li>
<li>若 Ra = Rb，則 N=0, Z=1。</li>
</ol>
<p>如此，用來進行條件跳躍的 JGT、JGE、JLT、JLE、JEQ、JNE指令，就可以根據 SW 暫存器當中的 N、Z 等旗標決定是否進行跳躍。</p>
<p>SW 中還包含中斷控制旗標 I (Interrupt) 與 T (Trap)，用以控制中斷的啟動與禁止等行為，假如將 I 旗標設定為 0，則CPU0將禁止所有種類的中斷，也就是對任何中斷都不會起反應。但如果只是將 T 旗標設定為0，則只會禁止軟體 中斷指令 SWI (Software Interrupt)，不會禁止由硬體觸發的中斷。</p>
<p>SW 中還儲存有『處理器模式』的欄位，M=0 時為『使用者模式』 (user mode) 與 M=1 時為『特權模式』(super mode) 等， 這在作業系統的設計上經常被用來製作安全保護功能。在使用者模式當中，任何設定狀態暫存器 R12 的動作都會被視為是非法的， 這是為了進行保護功能的緣故。但是在特權模式中，允許進行任何動作，包含設定中斷旗標與處理器模式等位元， 通常作業系統會使用特權模式 (M=1)，而一般程式只能處於使用者模式 (M=0)。</p>
<h3 id="cpu0-處理器的-verilog-實作----cpu0sc.v"><a href="#cpu0-處理器的-verilog-實作----cpu0sc.v">CPU0 處理器的 Verilog 實作 -- CPU0sc.v</a></h3>
<p>檔案：cpu0sc.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`define PC   R[15]   </span><span class="co">// 程式計數器</span>
<span class="ot">`define LR   R[14]   </span><span class="co">// 連結暫存器</span>
<span class="ot">`define SP   R[13]   </span><span class="co">// 堆疊暫存器</span>
<span class="ot">`define SW   R[12]   </span><span class="co">// 狀態暫存器</span>
<span class="co">// 狀態暫存器旗標位元</span>
<span class="ot">`define N    `SW[31] </span><span class="co">// 負號旗標</span>
<span class="ot">`define Z    `SW[30] </span><span class="co">// 零旗標</span>
<span class="ot">`define C    `SW[29] </span><span class="co">// 進位旗標</span>
<span class="ot">`define V    `SW[28] </span><span class="co">// 溢位旗標</span>
<span class="ot">`define I    `SW[7]  </span><span class="co">// 硬體中斷許可</span>
<span class="ot">`define T    `SW[6]  </span><span class="co">// 軟體中斷許可</span>
<span class="ot">`define M    `SW[0]  </span><span class="co">// 模式位元</span>

<span class="kw">module</span> cpu0c(<span class="dt">input</span> clock); <span class="co">// CPU0-Mini 的快取版：cpu0mc 模組</span>
  <span class="dt">parameter</span> [<span class="dv">7</span>:<span class="dv">0</span>] LD=<span class="bn">8&#39;h00</span>,ST=<span class="bn">8&#39;h01</span>,LDB=<span class="bn">8&#39;h02</span>,STB=<span class="bn">8&#39;h03</span>,LDR=<span class="bn">8&#39;h04</span>,STR=<span class="bn">8&#39;h05</span>,
    LBR=<span class="bn">8&#39;h06</span>,SBR=<span class="bn">8&#39;h07</span>,ADDI=<span class="bn">8&#39;h08</span>,CMP=<span class="bn">8&#39;h10</span>,MOV=<span class="bn">8&#39;h12</span>,ADD=<span class="bn">8&#39;h13</span>,SUB=<span class="bn">8&#39;h14</span>,
    MUL=<span class="bn">8&#39;h15</span>,DIV=<span class="bn">8&#39;h16</span>,AND=<span class="bn">8&#39;h18</span>,OR=<span class="bn">8&#39;h19</span>,XOR=<span class="bn">8&#39;h1A</span>,ROL=<span class="bn">8&#39;h1C</span>,ROR=<span class="bn">8&#39;h1D</span>,
    SHL=<span class="bn">8&#39;h1E</span>,SHR=<span class="bn">8&#39;h1F</span>,JEQ=<span class="bn">8&#39;h20</span>,JNE=<span class="bn">8&#39;h21</span>,JLT=<span class="bn">8&#39;h22</span>,JGT=<span class="bn">8&#39;h23</span>,JLE=<span class="bn">8&#39;h24</span>,
    JGE=<span class="bn">8&#39;h25</span>,JMP=<span class="bn">8&#39;h26</span>,SWI=<span class="bn">8&#39;h2A</span>,CALL=<span class="bn">8&#39;h2B</span>,RET=<span class="bn">8&#39;h2C</span>,IRET=<span class="bn">8&#39;h2D</span>,
    PUSH=<span class="bn">8&#39;h30</span>,POP=<span class="bn">8&#39;h31</span>,PUSHB=<span class="bn">8&#39;h32</span>,POPB=<span class="bn">8&#39;h33</span>;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] R [<span class="dv">0</span>:<span class="dv">15</span>];   <span class="co">// 宣告暫存器 R[0..15] 等 16 個 32 位元暫存器</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] IR;         <span class="co">// 指令暫存器 IR</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] m [<span class="dv">0</span>:<span class="dv">256</span>];          <span class="co">// 內部的快取記憶體</span>
  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] op;                 <span class="co">// 變數：運算代碼 op</span>
  <span class="dt">reg</span> [<span class="dv">3</span>:<span class="dv">0</span>] ra, rb, rc;         <span class="co">// 變數：暫存器代號 ra, rb, rc</span>
  <span class="dt">reg</span> [<span class="dv">4</span>:<span class="dv">0</span>] c5;                 <span class="co">// 變數：5 位元常數 c5</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">11</span>:<span class="dv">0</span>] c12;        <span class="co">// 變數：12 位元常數 c12</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">15</span>:<span class="dv">0</span>] c16;        <span class="co">// 變數：16 位元常數 c16</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">23</span>:<span class="dv">0</span>] c24;        <span class="co">// 變數：24 位元常數 c24</span>
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] sp, jaddr, laddr, raddr;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] temp;
  <span class="dt">reg</span> <span class="dt">signed</span> [<span class="dv">31</span>:<span class="dv">0</span>] pc;

  <span class="dt">integer</span> i;  
  <span class="kw">initial</span>  <span class="co">// 初始化</span>
  <span class="kw">begin</span>
    <span class="ot">`PC</span> = <span class="dv">0</span>;                    <span class="co">// 將 PC 設為起動位址 0</span>
    <span class="ot">`SW</span> = <span class="dv">0</span>;
    R[<span class="dv">0</span>] = <span class="dv">0</span>;                   <span class="co">// 將 R[0] 暫存器強制設定為 0</span>
    <span class="dt">$readmemh</span>(<span class="st">&quot;cpu0s.hex&quot;</span>, m);
    <span class="kw">for</span> (i=<span class="dv">0</span>; i &lt; <span class="dv">255</span>; i=i<span class="dv">+4</span>) <span class="kw">begin</span>
       <span class="dt">$display</span>(<span class="st">&quot;%8x: %8x&quot;</span>, i, {m[i], m[i<span class="dv">+1</span>], m[i<span class="dv">+2</span>], m[i<span class="dv">+3</span>]});
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 在 clock 時脈的正邊緣時觸發</span>
      pc = <span class="ot">`PC</span>;
      IR = {m[<span class="ot">`PC</span>], m[<span class="ot">`PC</span><span class="dv">+1</span>], m[<span class="ot">`PC</span><span class="dv">+2</span>], m[<span class="ot">`PC</span><span class="dv">+3</span>]};  <span class="co">// 指令擷取階段：IR=m[PC], 4 個 Byte 的記憶體</span>
      <span class="ot">`PC</span> = <span class="ot">`PC</span><span class="dv">+4</span>;                                  <span class="co">// 擷取完成，PC 前進到下一個指令位址</span>
      {op,ra,rb,rc,c12} = IR;                      <span class="co">// 解碼階段：將 IR 解為 {op, ra, rb, rc, c12}</span>
      c5  = IR[<span class="dv">4</span>:<span class="dv">0</span>];
      c24 = IR[<span class="dv">23</span>:<span class="dv">0</span>];
      c16 = IR[<span class="dv">15</span>:<span class="dv">0</span>];
      jaddr = <span class="ot">`PC</span>+c16;
      laddr = R[rb]+c16;
      raddr = R[rb]+R[rc];
      <span class="kw">case</span> (op) <span class="co">// 根據 OP 執行對應的動作</span>
        <span class="dv">LD:</span> <span class="kw">begin</span>   <span class="co">// 載入指令： R[ra] = m[addr]</span>
          R[ra] = {m[laddr], m[laddr<span class="dv">+1</span>], m[laddr<span class="dv">+2</span>], m[laddr<span class="dv">+3</span>]};
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LD    R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">ST:</span> <span class="kw">begin</span>   <span class="co">// 儲存指令： m[addr] = R[ra]</span>
          {m[laddr], m[laddr<span class="dv">+1</span>], m[laddr<span class="dv">+2</span>], m[laddr<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ST    R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LDB:</span><span class="kw">begin</span>   <span class="co">// 載入byte;     LDB Ra, [Rb+ Cx];   Ra&lt;=(byte)[Rb+ Cx]</span>
          R[ra] = { <span class="bn">24&#39;b0</span>, m[laddr] };
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LDB   R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">STB:</span><span class="kw">begin</span>   <span class="co">// 儲存byte;     STB Ra, [Rb+ Cx];   Ra=&gt;(byte)[Rb+ Cx]</span>
          m[laddr] = R[ra][<span class="dv">7</span>:<span class="dv">0</span>];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : STB   R%-d R%-d 0x%x ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LDR:</span><span class="kw">begin</span>   <span class="co">// LD 的 Rc 版;  LDR Ra, [Rb+Rc];    Ra&lt;=[Rb+ Rc]</span>
          R[ra] = {m[raddr], m[raddr<span class="dv">+1</span>], m[raddr<span class="dv">+2</span>], m[raddr<span class="dv">+3</span>]};
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LDR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">STR:</span><span class="kw">begin</span>   <span class="co">// ST 的 Rc 版;  STR Ra, [Rb+Rc];    Ra=&gt;[Rb+ Rc]</span>
          {m[raddr], m[raddr<span class="dv">+1</span>], m[raddr<span class="dv">+2</span>], m[raddr<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : STR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">LBR:</span><span class="kw">begin</span>   <span class="co">// LDB 的 Rc 版; LBR Ra, [Rb+Rc];    Ra&lt;=(byte)[Rb+ Rc]</span>
          R[ra] = { <span class="bn">24&#39;b0</span>, m[raddr] };
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : LBR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SBR:</span><span class="kw">begin</span>   <span class="co">// STB 的 Rc 版; SBR Ra, [Rb+Rc];    Ra=&gt;(byte)[Rb+ Rc]</span>
          m[raddr] = R[ra][<span class="dv">7</span>:<span class="dv">0</span>];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SBR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">MOV:</span><span class="kw">begin</span>   <span class="co">// 移動;        MOV Ra, Rb;         Ra&lt;=Rb</span>
          R[ra] = R[rb];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : MOV   R%-d R%-d        ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">CMP:</span><span class="kw">begin</span>   <span class="co">// 比較;        CMP Ra, Rb;         SW=(Ra &gt;=&lt; Rb)</span>
          temp = R[ra]-R[rb];
          <span class="ot">`N</span>=(temp&lt;<span class="dv">0</span>);<span class="ot">`Z</span>=(temp==<span class="dv">0</span>);
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : CMP   R%-d R%-d        ; SW=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, <span class="ot">`SW</span>);
          <span class="kw">end</span>
        <span class="dv">ADDI:</span><span class="kw">begin</span>  <span class="co">// R[a] = Rb+c16;  // 立即值加法;   LDI Ra, Rb+Cx; Ra&lt;=Rb + Cx</span>
          R[ra] = R[rb]+c16;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ADDI  R%-d R%-d %-d ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c16, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">ADD:</span> <span class="kw">begin</span>  <span class="co">// 加法指令： R[ra] = R[rb]+R[rc]</span>
          R[ra] = R[rb]+R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : ADD   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SUB:</span><span class="kw">begin</span>   <span class="co">// 減法;        SUB Ra, Rb, Rc;     Ra&lt;=Rb-Rc</span>
          R[ra] = R[rb]-R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SUB   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">MUL:</span><span class="kw">begin</span>   <span class="co">// 乘法;        MUL Ra, Rb, Rc;     Ra&lt;=Rb*Rc</span>
          R[ra] = R[rb]*R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : MUL   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">DIV:</span><span class="kw">begin</span>   <span class="co">// 除法;        DIV Ra, Rb, Rc;     Ra&lt;=Rb/Rc</span>
          R[ra] = R[rb]/R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : DIV   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">AND:</span><span class="kw">begin</span>   <span class="co">// 位元 AND;    AND Ra, Rb, Rc;     Ra&lt;=Rb and Rc</span>
          R[ra] = R[rb]&amp;R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : AND   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">OR:</span><span class="kw">begin</span>    <span class="co">// 位元 OR;     OR Ra, Rb, Rc;         Ra&lt;=Rb or Rc</span>
          R[ra] = R[rb]|R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : OR    R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">XOR:</span><span class="kw">begin</span>   <span class="co">// 位元 XOR;    XOR Ra, Rb, Rc;     Ra&lt;=Rb xor Rc</span>
          R[ra] = R[rb]^R[rc];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : XOR   R%-d R%-d R%-d    ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, rc, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SHL:</span><span class="kw">begin</span>   <span class="co">// 向左移位;    SHL Ra, Rb, Cx;     Ra&lt;=Rb &lt;&lt; Cx</span>
          R[ra] = R[rb]&lt;&lt;c5;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SHL   R%-d R%-d %-d     ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c5, ra, R[ra], R[ra]);
          <span class="kw">end</span>
        <span class="dv">SHR:</span><span class="kw">begin</span>   <span class="co">// 向右移位;        SHR Ra, Rb, Cx;     Ra&lt;=Rb &gt;&gt; Cx</span>
          R[ra] = R[rb]&gt;&gt;c5;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SHR   R%-d R%-d %-d     ; R%-2d=0x%8x=%-d&quot;</span>, <span class="dt">$stime</span>, pc, ra, rb, c5, ra, R[ra], R[ra]);
          <span class="kw">end</span>          
        <span class="dv">JMP:</span><span class="kw">begin</span>   <span class="co">// 跳躍指令： PC = PC + cx24</span>
          <span class="ot">`PC</span> = <span class="ot">`PC</span> + c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JMP   0x%x       ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JEQ:</span><span class="kw">begin</span>   <span class="co">// 跳躍 (相等);        JEQ Cx;        if SW(=) PC  PC+Cx</span>
          <span class="kw">if</span> (<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JEQ   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JNE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 (不相等);    JNE Cx;     if SW(!=) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JNE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JLT:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &lt; );        JLT Cx;     if SW(&lt;) PC  PC+Cx</span>
          <span class="kw">if</span> (<span class="ot">`N</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JLT   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JGT:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &gt; );        JGT Cx;     if SW(&gt;) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`N</span>&amp;&amp;!<span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JGT   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JLE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &lt;= );        JLE Cx;     if SW(&lt;=) PC  PC+Cx  </span>
          <span class="kw">if</span> (<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JLE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">JGE:</span><span class="kw">begin</span>   <span class="co">// 跳躍 ( &gt;= );        JGE Cx;     if SW(&gt;=) PC  PC+Cx</span>
          <span class="kw">if</span> (!<span class="ot">`N</span> || <span class="ot">`Z</span>) <span class="ot">`PC</span>=<span class="ot">`PC</span>+c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : JGE   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">SWI:</span><span class="kw">begin</span>   <span class="co">// 軟中斷;    SWI Cx;         LR &lt;= PC; PC &lt;= Cx; INT&lt;=1</span>
          <span class="ot">`LR</span>=<span class="ot">`PC</span>;<span class="ot">`PC</span>= c24; <span class="ot">`I</span> = <span class="bn">1&#39;b1</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : SWI   0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">CALL:</span><span class="kw">begin</span>  <span class="co">// 跳到副程式;    CALL Cx;     LR&lt;=PC; PC&lt;=PC+Cx</span>
          <span class="ot">`LR</span>=<span class="ot">`PC</span>;<span class="ot">`PC</span>=<span class="ot">`PC</span> + c24;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : CALL  0x%08x     ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, c24, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">RET:</span><span class="kw">begin</span>   <span class="co">// 返回;            RET;         PC &lt;= LR</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : RET                  ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">if</span> (<span class="ot">`PC</span>&lt;<span class="dv">0</span>) <span class="dt">$finish</span>;
          <span class="kw">end</span>
        <span class="dv">IRET:</span><span class="kw">begin</span>  <span class="co">// 中斷返回;        IRET;         PC &lt;= LR; INT&lt;=0</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;<span class="ot">`I</span> = <span class="bn">1&#39;b0</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : IRET             ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">end</span>
        <span class="dv">PUSH:</span><span class="kw">begin</span>  <span class="co">// 推入 word;    PUSH Ra;    SP-=4;[SP]&lt;=Ra;</span>
          sp = <span class="ot">`SP</span><span class="dv">-4</span>; <span class="ot">`SP</span> = sp; {m[sp], m[sp<span class="dv">+1</span>], m[sp<span class="dv">+2</span>], m[sp<span class="dv">+3</span>]} = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : PUSH  R%-d            ; R%-2d=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">POP:</span><span class="kw">begin</span>   <span class="co">// 彈出 word;    POP Ra;     Ra=[SP];SP+=4;</span>
          sp = <span class="ot">`SP</span>; R[ra]={m[sp], m[sp<span class="dv">+1</span>], m[sp<span class="dv">+2</span>], m[sp<span class="dv">+3</span>]}; <span class="ot">`SP</span> = sp<span class="dv">+4</span>; 
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : POP   R%-d            ; R%-2d=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">PUSHB:</span><span class="kw">begin</span> <span class="co">// 推入 byte;    PUSHB Ra;   SP--;[SP]&lt;=Ra;(byte)</span>
          sp = <span class="ot">`SP</span><span class="dv">-1</span>; <span class="ot">`SP</span> = sp; m[sp] = R[ra];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : PUSHB R%-d            ; R[%-d]=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
        <span class="dv">POPB:</span><span class="kw">begin</span>  <span class="co">// 彈出 byte;    POPB Ra;  Ra&lt;=[SP];SP++;(byte)</span>
          sp = <span class="ot">`SP</span><span class="dv">+1</span>; <span class="ot">`SP</span> = sp; R[ra]=m[sp];
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : POPB  R%-d            ; R[%-d]=0x%8x, SP=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, ra, ra, R[ra], <span class="ot">`SP</span>);
          <span class="kw">end</span>
      <span class="kw">endcase</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
<span class="dt">reg</span> clock;                  <span class="co">// 時脈 clock 變數</span>

cpu0c cpu(clock);           <span class="co">// 宣告 cpu0mc 處理器</span>

<span class="kw">initial</span> clock = <span class="dv">0</span>;          <span class="co">// 一開始 clock 設定為 0</span>
<span class="kw">always</span> <span class="bn">#10</span> clock=~clock;    <span class="co">// 每隔 10 奈秒將 clock 反相，產生週期為 20 奈秒的時脈</span>
<span class="kw">initial</span> <span class="bn">#2000</span> <span class="dt">$finish</span>;      <span class="co">// 在 640 奈秒的時候停止測試。(因為這時的 R[1] 恰好是 1+2+...+10=55 的結果)</span>
<span class="kw">endmodule</span></code></pre>
<h3 id="程式碼解析與執行"><a href="#程式碼解析與執行">程式碼解析與執行</a></h3>
<p>在上一章的 CPU0mc.v 當中，我們直接使用下列程式將「機器碼」塞入到記憶體當中，但是這樣做顯然彈性不太夠。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">    {m[<span class="dv">0</span>],m[<span class="dv">1</span>],m[<span class="dv">2</span>],m[<span class="dv">3</span>]}    = <span class="bn">32&#39;h001F0018</span>; <span class="co">// 0000       LD   R1, K1</span>
    {m[<span class="dv">4</span>],m[<span class="dv">5</span>],m[<span class="dv">6</span>],m[<span class="dv">7</span>]}    = <span class="bn">32&#39;h002F0010</span>; <span class="co">// 0004       LD   R2, K0</span>
    {m[<span class="dv">8</span>],m[<span class="dv">9</span>],m[<span class="dv">10</span>],m[<span class="dv">11</span>]}  = <span class="bn">32&#39;h003F0014</span>; <span class="co">// 0008       LD   R3, SUM</span>
    {m[<span class="dv">12</span>],m[<span class="dv">13</span>],m[<span class="dv">14</span>],m[<span class="dv">15</span>]}= <span class="bn">32&#39;h13221000</span>; <span class="co">// 000C LOOP: ADD  R2, R2, R1</span>
    {m[<span class="dv">16</span>],m[<span class="dv">17</span>],m[<span class="dv">18</span>],m[<span class="dv">19</span>]}= <span class="bn">32&#39;h13332000</span>; <span class="co">// 0010       ADD  R3, R3, R2</span>
    {m[<span class="dv">20</span>],m[<span class="dv">21</span>],m[<span class="dv">22</span>],m[<span class="dv">23</span>]}= <span class="bn">32&#39;h26FFFFF4</span>; <span class="co">// 0014       JMP  LOOP</span>
    {m[<span class="dv">24</span>],m[<span class="dv">25</span>],m[<span class="dv">26</span>],m[<span class="dv">27</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0018 K0:   WORD 0</span>
    {m[<span class="dv">28</span>],m[<span class="dv">29</span>],m[<span class="dv">30</span>],m[<span class="dv">31</span>]}= <span class="bn">32&#39;h00000001</span>; <span class="co">// 001C K1:   WORD 1</span>
    {m[<span class="dv">32</span>],m[<span class="dv">33</span>],m[<span class="dv">34</span>],m[<span class="dv">35</span>]}= <span class="bn">32&#39;h00000000</span>; <span class="co">// 0020 SUM:  WORD 0</span></code></pre>
<p>因此，在本章的 CPU0sc.v 這個程式中，我們採用讀取外部檔案的方式，將機器碼寫在 「cpu0s.hex」這個檔案中， 然後再用下列指令將該 16 進位的機器碼檔案讀入。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">    <span class="dt">$readmemh</span>(<span class="st">&quot;cpu0s.hex&quot;</span>, m);</code></pre>
<p>其中的 readmemh 是一個可以讀取 16 進位的文字檔的函數，上述指令會將 cpu0s.hex 這個檔案內的 16 進位字串 讀入到「記憶體變數」 m 當中。</p>
<p>以下是 cpu0s.hex 的完整內容。</p>
<p>輸入檔：cpu0s.hex</p>
<pre><code>00 DF 00 B6  //  0           LD   R13, StackEnd
08 40 00 04  //  4           ADDI R4, 4
08 50 00 08  //  8           ADDI R5, 8
05 4D 50 00  //  c           STR  R4, [R13+R5]
04 6D 50 00  // 10           LDR  R6, [R13+R5]
07 5D 40 00  // 14           SBR  R5, [R13+R4]
06 6D 40 00  // 18           LBR  R6, [R13+R4]
08 E0 FF FF  // 1C           ADDI R14,R0,-1
30 E0 00 00  // 20           PUSH R14
13 85 40 00  // 24           ADD  R8, R5, R4
14 85 40 00  // 28           SUB  R8, R5, R4
15 85 40 00  // 2c           MUL  R8, R5, R4
16 85 40 00  // 30           DIV  R8, R5, R4
18 85 40 00  // 34           AND  R8, R5, R4
19 85 40 00  // 38           OR   R8, R5, R4
1A 85 40 00  // 3c           XOR  R8, R5, R4
1E 85 00 03  // 40           SHL  R8, R5, 3
1F 85 00 02  // 44           SHR  R8, R5, 2
10 45 00 00  // 48           CMP  R4, R5
20 00 00 18  // 4c           JEQ  L1
23 00 00 14  // 50           JGT  L1
25 00 00 10  // 54           JGE  L1
22 00 00 0C  // 58           JLT  L1
24 00 00 08  // 5c           JLE  L1
21 00 00 04  // 60           JNE  L1
26 00 00 00  // 64           JMP  L1
08 10 00 0A  // 68   L1:     ADDI R1, R0, 10
2B 00 00 08  // 6c           CALL SUM
31 E0 00 00  // 70           POP  R14
2C 00 00 00  // 74           RET
30 E0 00 00  // 78   SUM:    PUSH R14
12 30 00 00  // 7c           MOV  R3, R0     // R3 = i = 0
02 4F 00 24  // 80           LDB  R4, k1     // R4 = 1
08 20 00 00  // 84           ADDI R2, 0      // SUM = R2 = 0
13 22 30 00  // 88   LOOP:   ADD  R2, R2, R3 // SUM = SUM + i
13 33 40 00  // 8c           ADD  R3, R3, R4 // i = i + 1
10 31 00 00  // 90           CMP  R3, R1     // if (i &lt; R1)
24 FF FF F0  // 94           JLE  LOOP       //   goto LOOP
01 2F 00 0D  // 98           ST   R2, s
03 3F 00 0D  // 9c           STB  R3, i
31 E0 00 00  // a0           POP  R14
2C 00 00 00  // a4           RET                   // return
01           // a8   k1:     BYTE 1                // char K1=1
00 00 00 00  // a9   s:      WORD 0                // int s
00           // ad   i:      BYTE 0                // char i=1
00 01 02 03  // ae   Stack:  BYTE  0, 1, 2, 3, 4, 5, 6, 7, 8, 9 , 10, 11
04 05 06 07  // b2
08 09 0A 0B  // b6
00 00 00 BA  // ba   StackEnd: WORD StackEnd
01 02 03 04  // be   Data:   BYTE 0, 1, 2, 3, 4, 5, 6, 7, 8
05 06 07 08  // c2</code></pre>
<p>上述程式的內容，大致是先準備好堆疊，然後就開始測試 ADDI, STR, LDR, ADD, SUB, ... 等指令。 接著在呼叫 CMP R4, R5 之後進行跳躍測試動作，由於 R4=4, R5=8，所以 CMP 的結果會是「小於」， 因此在後面的 JEQ, JGT, JGE 等指令都不會真的跳躍，直到執行 JLT L1 時就會真的跳到 L1 去。</p>
<p>接著用 ADDI R1, R0, 10 將 R1 設為 10，然後就用 CALL SUM 這個指令呼叫 SUM 這個副程式，於是跳到 位於 0x78 的 SUM: PUSH R14 這一行，並開始執行副程式，該副程式會計算 1+2+...+R1 的結果，放在 R2 當中， 並在最後用 STB R2, s 這個指令存入變數 s 當中，然後在執行完 RET 指令後返回上一層，也就是 0x70 行的 POP R14 指令，接著在執行 RET 指令時，由於此時 R14 為 -1，因此 Verilog 程式就在完成 RET 指令時發現 <code>PC 已經小於 0 了，因此執行</code>$finish` 指令停止整個程式。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog">        <span class="dv">RET:</span><span class="kw">begin</span>   <span class="co">// 返回;            RET;         PC &lt;= LR</span>
          <span class="ot">`PC</span>=<span class="ot">`LR</span>;
          <span class="dt">$display</span>(<span class="st">&quot;%4dns %8x : RET                  ; PC=0x%x&quot;</span>, <span class="dt">$stime</span>, pc, <span class="ot">`PC</span>);
          <span class="kw">if</span> (<span class="ot">`PC</span>&lt;<span class="dv">0</span>) <span class="dt">$finish</span>;
          <span class="kw">end</span></code></pre>
<h3 id="執行結果-4"><a href="#執行結果-4">執行結果</a></h3>
<p>有了上述的程式 cpu0sc.v 與輸入的機器碼 cpu0s.hex 檔案之後，我們就可以用下列指令進行編譯與執行， 以下是該程式編譯與執行的結果。</p>
<pre><code>D:\verilog&gt;iverilog -o cpu0sc cpu0sc.v

D:\verilog&gt;vvp cpu0sc
WARNING: cpu0sc.v:40: $readmemh(cpu0s.hex): Not enough words in the file for the
 requested range [0:256].
00000000: 00df00b6
00000004: 08400004
00000008: 08500008
0000000c: 054d5000
00000010: 046d5000
00000014: 075d4000
00000018: 066d4000
0000001c: 08e0ffff
00000020: 30e00000
00000024: 13854000
00000028: 14854000
0000002c: 15854000
00000030: 16854000
00000034: 18854000
00000038: 19854000
0000003c: 1a854000
00000040: 1e850003
00000044: 1f850002
00000048: 10450000
0000004c: 20000018
00000050: 23000014
00000054: 25000010
00000058: 2200000c
0000005c: 24000008
00000060: 21000004
00000064: 26000000
00000068: 0810000a
0000006c: 2b000008
00000070: 31e00000
00000074: 2c000000
00000078: 30e00000
0000007c: 12300000
00000080: 024f0024
00000084: 08200000
00000088: 13223000
0000008c: 13334000
00000090: 10310000
00000094: 24fffff0
00000098: 012f000d
0000009c: 033f000d
000000a0: 31e00000
000000a4: 2c000000
000000a8: 01000000
000000ac: 00000001
000000b0: 02030405
000000b4: 06070809
000000b8: 0a0b0000
000000bc: 00ba0102
000000c0: 03040506
000000c4: 0708xxxx
000000c8: xxxxxxxx
000000cc: xxxxxxxx
000000d0: xxxxxxxx
000000d4: xxxxxxxx
000000d8: xxxxxxxx
000000dc: xxxxxxxx
000000e0: xxxxxxxx
000000e4: xxxxxxxx
000000e8: xxxxxxxx
000000ec: xxxxxxxx
000000f0: xxxxxxxx
000000f4: xxxxxxxx
000000f8: xxxxxxxx
000000fc: xxxxxxxx
  10ns 00000000 : LD    R13 R15 0x00b6 ; R13=0x000000ba=186
  30ns 00000004 : ADDI  R4  R0  4      ; R4 =0x00000004=4
  50ns 00000008 : ADDI  R5  R0  8      ; R5 =0x00000008=8
  70ns 0000000c : STR   R4  R13 R5     ; R4 =0x00000004=4
  90ns 00000010 : LDR   R6  R13 R5     ; R6 =0x00000004=4
 110ns 00000014 : SBR   R5  R13 R4     ; R5 =0x00000008=8
 130ns 00000018 : LBR   R6  R13 R4     ; R6 =0x00000008=8
 150ns 0000001c : ADDI  R14 R0  -1     ; R14=0xffffffff=-1
 170ns 00000020 : PUSH  R14            ; R14=0xffffffff, SP=0x000000b6
 190ns 00000024 : ADD   R8  R5  R4     ; R8 =0x0000000c=12
 210ns 00000028 : SUB   R8  R5  R4     ; R8 =0x00000004=4
 230ns 0000002c : MUL   R8  R5  R4     ; R8 =0x00000020=32
 250ns 00000030 : DIV   R8  R5  R4     ; R8 =0x00000002=2
 270ns 00000034 : AND   R8  R5  R4     ; R8 =0x00000000=0
 290ns 00000038 : OR    R8  R5  R4     ; R8 =0x0000000c=12
 310ns 0000003c : XOR   R8  R5  R4     ; R8 =0x0000000c=12
 330ns 00000040 : SHL   R8  R5  3      ; R8 =0x00000040=64
 350ns 00000044 : SHR   R8  R5  2      ; R8 =0x00000002=2
 370ns 00000048 : CMP   R4  R5         ; SW=0x80000000
 390ns 0000004c : JEQ   0x00000018     ; PC=0x00000050
 410ns 00000050 : JGT   0x00000014     ; PC=0x00000054
 430ns 00000054 : JGE   0x00000010     ; PC=0x00000058
 450ns 00000058 : JLT   0x0000000c     ; PC=0x00000068
 470ns 00000068 : ADDI  R1  R0  10     ; R1 =0x0000000a=10
 490ns 0000006c : CALL  0x00000008     ; PC=0x00000078
 510ns 00000078 : PUSH  R14            ; R14=0x00000070, SP=0x000000b2
 530ns 0000007c : MOV   R3  R0         ; R3 =0x00000000=0
 550ns 00000080 : LDB   R4  R15 0x0024 ; R4 =0x00000001=1
 570ns 00000084 : ADDI  R2  R0  0      ; R2 =0x00000000=0
 590ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000000=0
 610ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000001=1
 630ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 650ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 670ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000001=1
 690ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000002=2
 710ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 730ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 750ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000003=3
 770ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000003=3
 790ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 810ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 830ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000006=6
 850ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000004=4
 870ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 890ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 910ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000000a=10
 930ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000005=5
 950ns 00000090 : CMP   R3  R1         ; SW=0x80000000
 970ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
 990ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000000f=15
1010ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000006=6
1030ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1050ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1070ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000015=21
1090ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000007=7
1110ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1130ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1150ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000001c=28
1170ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000008=8
1190ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1210ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1230ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000024=36
1250ns 0000008c : ADD   R3  R3  R4     ; R3 =0x00000009=9
1270ns 00000090 : CMP   R3  R1         ; SW=0x80000000
1290ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1310ns 00000088 : ADD   R2  R2  R3     ; R2 =0x0000002d=45
1330ns 0000008c : ADD   R3  R3  R4     ; R3 =0x0000000a=10
1350ns 00000090 : CMP   R3  R1         ; SW=0x40000000
1370ns 00000094 : JLE   0x00fffff0     ; PC=0x00000088
1390ns 00000088 : ADD   R2  R2  R3     ; R2 =0x00000037=55
1410ns 0000008c : ADD   R3  R3  R4     ; R3 =0x0000000b=11
1430ns 00000090 : CMP   R3  R1         ; SW=0x00000000
1450ns 00000094 : JLE   0x00fffff0     ; PC=0x00000098
1470ns 00000098 : ST    R2  R15 0x000d ; R2 =0x00000037=55
1490ns 0000009c : STB   R3  R15 0x000d ; R3 =0x0000000b=11
1510ns 000000a0 : POP   R14            ; R14=0x00000070, SP=0x000000b6
1530ns 000000a4 : RET                  ; PC=0x00000070
1550ns 00000070 : POP   R14            ; R14=0xffffffff, SP=0x000000ba
1570ns 00000074 : RET                  ; PC=0xffffffff</code></pre>
<h3 id="結語-9"><a href="#結語-9">結語</a></h3>
<p>從本章的內容中，您應該可以瞭解到直接使用高階的 Verilog 流程式語法來設計處理器，像是 cpu0mc.v 與 cpu0sc.v ， 都是相當容易的事，這完全是因為 verilog 支援了相當高階的運算，像是 「+, -, *, /, &amp;, |, ^, &lt;&lt;, &gt;&gt;」等運算的原故。</p>
<p>不過、在上述程式當中，我們並沒有支援「硬體中斷」的功能，也沒有實作「軟體中斷」SWI 的函數呼叫，這樣 CPU0sc.v 就 只能是一顆單工 (Single Task) 的處理器，而無法支援多工 (Multi Task) 的功能了。</p>
<p>在下一章當中，我們將繼續擴充 CPU0sc.v 這個程式，加入支援「軟硬體中斷」的功能，以及支援「浮點運算」的功能， 該程式稱為 CPU0ic.v (i 代表 Interrupt, c 代表 cache memory)。</p>
<p>然後我們將再度用 16 進位的方式，寫出一個機器語言的程式，可以同時執行兩個「行程」(Task) ，並且每隔一小段時間就利用 硬體中斷進行「行程切換」，以示範如何設計一個可以支援「多工」能力的 CPU 處理器。</p>
<h3 id="參考文獻-5"><a href="#參考文獻-5">參考文獻</a></h3>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:cpu0s">陳鍾誠的網站：使用 Verilog 設計 CPU0 處理器</a></li>
<li><a href="http://ccckmit.wikidot.com/ve:cpu0m">陳鍾誠的網站：CPU0-Mini 處理器設計</a></li>
</ul>
<h1 id="速度議題"><a href="#速度議題">速度議題</a></h1>
<h2 id="乘法與除法"><a href="#乘法與除法">乘法與除法</a></h2>
<h3 id="for-迴圈的實作方法"><a href="#for-迴圈的實作方法">for 迴圈的實作方法</a></h3>
<p>最簡單的乘法器是移位乘法器，這種乘法器基本上只用了一個加法器和一個移位器所組成， 電路上而言相當簡單，但缺點是執行速度不快，以下是一個 32 位元的移位乘法器之程式碼。</p>
<p>參考：http://www.edaboard.com/thread235191.html</p>
<p>檔案：shift_mult.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> multiplier(<span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>] z, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] x, y); 
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] a;
<span class="dt">integer</span> i; 

<span class="kw">always</span> @(x , y)
<span class="kw">begin</span> 
  a=x;
  z=<span class="dv">0</span>; <span class="co">// 初始化為 0</span>
  <span class="kw">for</span>(i=<span class="dv">0</span>;i&lt;<span class="dv">31</span>;i=i<span class="dv">+1</span>) <span class="kw">begin</span>
    <span class="kw">if</span> (y[i])
      z = z + a; <span class="co">// 請注意，這是 block assignment =，所以會造成延遲，長度越長延遲越久。</span>
    a=a &lt;&lt; <span class="dv">1</span>;
  <span class="kw">end</span>
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main; 
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] a, b; 
<span class="dt">wire</span> [<span class="dv">63</span>:<span class="dv">0</span>] c; 

multiplier m(c, a, b); 

<span class="kw">initial</span> <span class="kw">begin</span> 
  a = <span class="dv">17</span>;
  b = <span class="dv">7</span>; 
  <span class="bn">#10</span>;
  <span class="dt">$display</span>(<span class="st">&quot;a=%d b=%d c=%d&quot;</span>, a, b, c); 
<span class="kw">end</span> 

<span class="kw">endmodule</span> </code></pre>
<p>其編譯執行結果如下：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o mul32a mul32a.v

D:\Dropbox\Public\web\oc\code&gt;vvp mul32a
a=        17 b=         7 c=                 119</code></pre>
<p>但是、以上的這個程式，採用了 for 迴圈，而且使用 = 這種阻隔式的方式，應該會相當耗費電路資源， 筆者認為上述電路應該會用到 32 組 32 位元的加法器，這樣實在是難以接受的一種情況，所以我們接 下來將採用只有一組加法器，然後用多個時脈的方式來設計乘法器。</p>
<p>參考：http://www.edaboard.com/thread86772.html</p>
<ol style="list-style-type: decimal">
<li>for loop verilog synthesis</li>
</ol>
<blockquote>
<p>It is synthesizable but it is always advised that for loops are not to be used in RTL coding. This is because it consumes lot of resources (like area etc.etc) . However u can use it in behavioral coding becuse we do not synthesize behavioral codes.</p>
</blockquote>
<ol start="2" style="list-style-type: decimal">
<li>verilog for loop syntax</li>
</ol>
<blockquote>
<p>In verilog,synthesizable of for loop and while loop depends on which tools you are using . But it is better dont use it in RTL because it reflects replica of hardware.</p>
</blockquote>
<h3 id="個時脈的實作方法"><a href="#個時脈的實作方法">32 個時脈的實作方法</a></h3>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> multiplier(<span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>] z, <span class="dt">output</span> ready, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>] x, y, <span class="dt">input</span> start, clk); 
   <span class="dt">reg</span> [<span class="dv">5</span>:<span class="dv">0</span>] bit; 
   <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] a;
   
   <span class="dt">wire</span> ready = !bit;
   
   <span class="kw">initial</span> bit = <span class="dv">0</span>;

   <span class="kw">always</span> @( <span class="kw">posedge</span> clk ) <span class="kw">begin</span>
     <span class="kw">if</span>( ready &amp;&amp; start ) <span class="kw">begin</span>
        bit = <span class="dv">32</span>;
        z = <span class="dv">0</span>;
        a = x;
     <span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span>
        bit = bit - <span class="dv">1</span>;
        z = z &lt;&lt; <span class="dv">1</span>;
        <span class="kw">if</span> (y[bit])
          z = z + a;
     <span class="kw">end</span>
      ![](../timg/f227758f3c73.jpg) stime, x, y, z, ready, bit);
   <span class="kw">end</span> 
<span class="kw">endmodule</span>

<span class="kw">module</span> main; 
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] a, b; 
<span class="dt">wire</span> [<span class="dv">63</span>:<span class="dv">0</span>] c; 
<span class="dt">reg</span> clk, start;
<span class="dt">wire</span> ready;

multiplier m(c, ready, a, b, start, clk); 

<span class="kw">initial</span> <span class="kw">begin</span> 
  a = <span class="dv">17</span>;
  b = <span class="dv">7</span>; 
  start = <span class="dv">1</span>;
  clk = <span class="dv">0</span>;
  <span class="bn">#200</span>;
  start = <span class="dv">0</span>;
  <span class="bn">#200</span>;
  <span class="dt">$finish</span>;
<span class="kw">end</span> 

<span class="kw">always</span> <span class="bn">#5</span> clk = !clk;
<span class="co">// always @(posedge clk)  ![](../timg/cef23b92b13b.jpg) stime, a, b, c, ready);</span>

<span class="kw">endmodule</span> </code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o mul32b mul32b.v

D:\Dropbox\Public\web\oc\code&gt;vvp mul32b
         5ns : x=        17 y=         7 z=                   0 ready=0 bit=32
        15ns : x=        17 y=         7 z=                   0 ready=0 bit=31
        25ns : x=        17 y=         7 z=                   0 ready=0 bit=30
        35ns : x=        17 y=         7 z=                   0 ready=0 bit=29
        45ns : x=        17 y=         7 z=                   0 ready=0 bit=28
        55ns : x=        17 y=         7 z=                   0 ready=0 bit=27
        65ns : x=        17 y=         7 z=                   0 ready=0 bit=26
        75ns : x=        17 y=         7 z=                   0 ready=0 bit=25
        85ns : x=        17 y=         7 z=                   0 ready=0 bit=24
        95ns : x=        17 y=         7 z=                   0 ready=0 bit=23
       105ns : x=        17 y=         7 z=                   0 ready=0 bit=22
       115ns : x=        17 y=         7 z=                   0 ready=0 bit=21
       125ns : x=        17 y=         7 z=                   0 ready=0 bit=20
       135ns : x=        17 y=         7 z=                   0 ready=0 bit=19
       145ns : x=        17 y=         7 z=                   0 ready=0 bit=18
       155ns : x=        17 y=         7 z=                   0 ready=0 bit=17
       165ns : x=        17 y=         7 z=                   0 ready=0 bit=16
       175ns : x=        17 y=         7 z=                   0 ready=0 bit=15
       185ns : x=        17 y=         7 z=                   0 ready=0 bit=14
       195ns : x=        17 y=         7 z=                   0 ready=0 bit=13
       205ns : x=        17 y=         7 z=                   0 ready=0 bit=12
       215ns : x=        17 y=         7 z=                   0 ready=0 bit=11
       225ns : x=        17 y=         7 z=                   0 ready=0 bit=10
       235ns : x=        17 y=         7 z=                   0 ready=0 bit= 9
       245ns : x=        17 y=         7 z=                   0 ready=0 bit= 8
       255ns : x=        17 y=         7 z=                   0 ready=0 bit= 7
       265ns : x=        17 y=         7 z=                   0 ready=0 bit= 6
       275ns : x=        17 y=         7 z=                   0 ready=0 bit= 5
       285ns : x=        17 y=         7 z=                   0 ready=0 bit= 4
       295ns : x=        17 y=         7 z=                   0 ready=0 bit= 3
       305ns : x=        17 y=         7 z=                  17 ready=0 bit= 2
       315ns : x=        17 y=         7 z=                  51 ready=0 bit= 1
       325ns : x=        17 y=         7 z=                 119 ready=1 bit= 0
       335ns : x=        17 y=         7 z=                 238 ready=0 bit=63
       345ns : x=        17 y=         7 z=                 476 ready=0 bit=62
       355ns : x=        17 y=         7 z=                 952 ready=0 bit=61
       365ns : x=        17 y=         7 z=                1904 ready=0 bit=60
       375ns : x=        17 y=         7 z=                3808 ready=0 bit=59</code></pre>
<h3 id="除法器"><a href="#除法器">除法器</a></h3>
<p>檔案： div32.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 參考：http://www.ece.lsu.edu/ee3755/2002/l07.html</span>
<span class="co">// 參考：http://answers.google.com/answers/threadview/id/109219.html</span>
<span class="co">// a/b = q ; a%b = r;</span>
<span class="kw">module</span> divider(<span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] q, <span class="dt">output</span> [<span class="dv">31</span>:<span class="dv">0</span>] r, <span class="dt">output</span> ready, <span class="dt">input</span> [<span class="dv">31</span>:<span class="dv">0</span>]  a,b, <span class="dt">input</span> start, clk);
   <span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>]    ta, tb, diff;
   <span class="dt">reg</span> [<span class="dv">5</span>:<span class="dv">0</span>]     bit; 
   <span class="dt">wire</span>          ready = !bit;
   
   <span class="kw">initial</span> bit = <span class="dv">0</span>;

   <span class="kw">assign</span> r = ta[<span class="dv">31</span>:<span class="dv">0</span>];
   
   <span class="kw">always</span> @( <span class="kw">posedge</span> clk ) 
     <span class="kw">if</span>( ready &amp;&amp; start ) <span class="kw">begin</span>
        bit = <span class="dv">32</span>;
        q = <span class="dv">0</span>;
        ta = {<span class="bn">32&#39;d0</span>, a};
        tb = {<span class="bn">1&#39;b0</span>, b,<span class="bn">31&#39;d0</span>};
     <span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span>
        diff = ta - tb;
        q = q &lt;&lt; <span class="dv">1</span>;
        <span class="kw">if</span>( !diff[<span class="dv">63</span>] ) <span class="kw">begin</span>
           ta = diff;
           q[<span class="dv">0</span>] = <span class="bn">1&#39;d1</span>;
        <span class="kw">end</span>
        tb = tb &gt;&gt; <span class="dv">1</span>;
        bit = bit - <span class="dv">1</span>;
     <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">reg</span> clk, start;
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] a, b;
<span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] q, r;
<span class="dt">wire</span> ready;

divider div(q,r,ready,a,b,start,clk);

<span class="kw">initial</span> <span class="kw">begin</span>
  clk = <span class="dv">0</span>;
  a = <span class="dv">90</span>; b = <span class="dv">13</span>; start = <span class="dv">1</span>; 
  <span class="bn">#200</span>;
  start = <span class="dv">0</span>;
  <span class="bn">#200</span>;
  <span class="dt">$finish</span>;
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#5</span> clk = !clk;
<span class="kw">always</span> @(<span class="kw">posedge</span> clk)  ![](../timg/f777313541ae.jpg) stime, a, b, q, r, ready);

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o div32 div32.v

D:\Dropbox\Public\web\oc\code&gt;vvp div32
         5ns : a=        90 b=        13 q=         0 r=        90 ready=0
        15ns : a=        90 b=        13 q=         0 r=        90 ready=0
        25ns : a=        90 b=        13 q=         0 r=        90 ready=0
        35ns : a=        90 b=        13 q=         0 r=        90 ready=0
        45ns : a=        90 b=        13 q=         0 r=        90 ready=0
        55ns : a=        90 b=        13 q=         0 r=        90 ready=0
        65ns : a=        90 b=        13 q=         0 r=        90 ready=0
        75ns : a=        90 b=        13 q=         0 r=        90 ready=0
        85ns : a=        90 b=        13 q=         0 r=        90 ready=0
        95ns : a=        90 b=        13 q=         0 r=        90 ready=0
       105ns : a=        90 b=        13 q=         0 r=        90 ready=0
       115ns : a=        90 b=        13 q=         0 r=        90 ready=0
       125ns : a=        90 b=        13 q=         0 r=        90 ready=0
       135ns : a=        90 b=        13 q=         0 r=        90 ready=0
       145ns : a=        90 b=        13 q=         0 r=        90 ready=0
       155ns : a=        90 b=        13 q=         0 r=        90 ready=0
       165ns : a=        90 b=        13 q=         0 r=        90 ready=0
       175ns : a=        90 b=        13 q=         0 r=        90 ready=0
       185ns : a=        90 b=        13 q=         0 r=        90 ready=0
       195ns : a=        90 b=        13 q=         0 r=        90 ready=0
       205ns : a=        90 b=        13 q=         0 r=        90 ready=0
       215ns : a=        90 b=        13 q=         0 r=        90 ready=0
       225ns : a=        90 b=        13 q=         0 r=        90 ready=0
       235ns : a=        90 b=        13 q=         0 r=        90 ready=0
       245ns : a=        90 b=        13 q=         0 r=        90 ready=0
       255ns : a=        90 b=        13 q=         0 r=        90 ready=0
       265ns : a=        90 b=        13 q=         0 r=        90 ready=0
       275ns : a=        90 b=        13 q=         0 r=        90 ready=0
       285ns : a=        90 b=        13 q=         0 r=        90 ready=0
       295ns : a=        90 b=        13 q=         0 r=        90 ready=0
       305ns : a=        90 b=        13 q=         1 r=        38 ready=0
       315ns : a=        90 b=        13 q=         3 r=        12 ready=0
       325ns : a=        90 b=        13 q=         6 r=        12 ready=1
       335ns : a=        90 b=        13 q=        13 r=         6 ready=0
       345ns : a=        90 b=        13 q=        27 r=         3 ready=0
       355ns : a=        90 b=        13 q=        55 r=         2 ready=0
       365ns : a=        90 b=        13 q=       111 r=         2 ready=0
       375ns : a=        90 b=        13 q=       223 r=         2 ready=0
       385ns : a=        90 b=        13 q=       447 r=         2 ready=0
       395ns : a=        90 b=        13 q=       895 r=         2 ready=0</code></pre>
<h3 id="booth-乘法器"><a href="#booth-乘法器">Booth 乘法器</a></h3>
<ul>
<li>參考：<a href="http://zh.wikipedia.org/wiki/%E5%B8%83%E6%96%AF%E4%B9%98%E6%B3%95%E7%AE%97%E6%B3%95">維基百科：布斯乘法演算法</a></li>
</ul>
<p>以下範例來自維基百科</p>
<h4 id="booth-算法範例"><a href="#booth-算法範例">Booth 算法範例：</a></h4>
<p>考慮一個由若干個 0 包圍著若干個 1 的正的[[二進制]]乘數，比如 00111110，積可以表達為：</p>
<div class="figure">
<img src="../timg/c50047a6fb34.jpg" />
</div>
<p>其中，M 代表被乘數。變形為下式可以使運算次數可以減為兩次：</p>
<div class="figure">
<img src="../timg/0bbd0af78615.jpg" />
</div>
<p>事實上，任何二進制數中連續的 1 可以被分解為兩個二進制數之差：</p>
<p><img src="../img/BoothExp.jpg" /> .</p>
<!-- ![](../timg/e57d19c4ce90.jpg) -->

<p>因此，我們可以用更簡單的運算來替換原數中連續為 1 的數字的乘法，通過加上乘數，對部分積進行移位運算， 最後再將之從乘數中減去。它利用了我們在針對為零的位做乘法時，不需要做其他運算，只需移位這一特點， 這很像我們在做和 99 的乘法時利用 99=100-1 這一性質。</p>
<p>這種模式可以擴展應用於任何一串數字中連續為 1 的部分（包括只有一個 1 的情況）。那麼，</p>
<div class="figure">
<img src="../timg/31f528e10ca3.jpg" />
</div>
<div class="figure">
<img src="../timg/cafc15c58172.jpg" />
</div>
<p>布斯算法遵從這種模式，它在遇到一串數字中的第一組從 0 到 1 的變化時（即遇到 01 時）執行加法， 在遇到這一串連續 1 的尾部時（即遇到 10 時）執行減法。這在乘數為負時同樣有效。當乘數中的連續 1 比較多時（形成比較長的 1 串時），布斯算法較一般的乘法算法執行的加減法運算少。</p>
<h2 id="浮點數運算"><a href="#浮點數運算">浮點數運算</a></h2>
<h3 id="浮點運算單元-falu"><a href="#浮點運算單元-falu">浮點運算單元 FALU</a></h3>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// 輸入 a, b 後會執行 op 所指定的運算，然後將結果放在暫存器 y 當中</span>
<span class="kw">module</span> falu(<span class="dt">input</span> [<span class="dv">63</span>:<span class="dv">0</span>] ia, <span class="dt">input</span> [<span class="dv">63</span>:<span class="dv">0</span>] ib, <span class="dt">input</span> [<span class="dv">1</span>:<span class="dv">0</span>] op, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>] oy);
<span class="dt">real</span> a, b, y;

<span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> op) <span class="kw">begin</span>
  a = <span class="dt">$bitstoreal</span>(ia);
  b = <span class="dt">$bitstoreal</span>(ib); 
  <span class="kw">case</span> (op)
    <span class="bn">2&#39;b00</span>: y = a + b;
    <span class="bn">2&#39;b01</span>: y = a - b;
    <span class="bn">2&#39;b10</span>: y = a * b;
    <span class="bn">2&#39;b11</span>: y = a / b;
  <span class="kw">endcase</span>
  <span class="dt">$display</span>(<span class="st">&quot;falu32:op=%d a=%f b=%f y=%f&quot;</span>, op, a, b, y);
  oy = <span class="dt">$realtobits</span>(y);
<span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;                <span class="co">// 測試程式開始</span>
  <span class="dt">reg</span>  [<span class="dv">63</span>:<span class="dv">0</span>] a64, b64;
  <span class="dt">wire</span> [<span class="dv">63</span>:<span class="dv">0</span>] y64;
  <span class="dt">reg</span>  [<span class="dv">1</span>:<span class="dv">0</span>] op;
  <span class="dt">real</span> a, b;

  falu falu1(a64, b64, op, y64);     <span class="co">// 建立一個 alu 單元，名稱為 alu1</span>

  <span class="kw">initial</span> <span class="kw">begin</span>              <span class="co">// 測試程式的初始化動作</span>
    a = <span class="fl">3.14159</span>;  a64 = <span class="dt">$realtobits</span>(a);
    b = <span class="fl">2.71818</span>;  b64 = <span class="dt">$realtobits</span>(b);
    op = <span class="dv">0</span>;
  <span class="kw">end</span>

  <span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>           <span class="co">// 每個 50 奈秒就作下列動作</span>
    op = op + <span class="dv">1</span>;             <span class="co">// 讓 op 的值加 1</span>
  <span class="kw">end</span>

  <span class="kw">initial</span> <span class="bn">#1000</span> <span class="dt">$finish</span>;      <span class="co">// 時間到 1000 奈秒就結束</span>

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o flu64 flu64.v

D:\Dropbox\Public\web\oc\code&gt;vvp flu64
falu32:op=0 a=3.141590 b=2.718180 y=5.859770
falu32:op=1 a=3.141590 b=2.718180 y=0.423410
falu32:op=2 a=3.141590 b=2.718180 y=8.539407
falu32:op=3 a=3.141590 b=2.718180 y=1.155770
falu32:op=0 a=3.141590 b=2.718180 y=5.859770
falu32:op=1 a=3.141590 b=2.718180 y=0.423410
falu32:op=2 a=3.141590 b=2.718180 y=8.539407
falu32:op=3 a=3.141590 b=2.718180 y=1.155770
falu32:op=0 a=3.141590 b=2.718180 y=5.859770
falu32:op=1 a=3.141590 b=2.718180 y=0.423410
falu32:op=2 a=3.141590 b=2.718180 y=8.539407
falu32:op=3 a=3.141590 b=2.718180 y=1.155770
falu32:op=0 a=3.141590 b=2.718180 y=5.859770
falu32:op=1 a=3.141590 b=2.718180 y=0.423410
falu32:op=2 a=3.141590 b=2.718180 y=8.539407
falu32:op=3 a=3.141590 b=2.718180 y=1.155770
falu32:op=0 a=3.141590 b=2.718180 y=5.859770
falu32:op=1 a=3.141590 b=2.718180 y=0.423410
falu32:op=2 a=3.141590 b=2.718180 y=8.539407
falu32:op=3 a=3.141590 b=2.718180 y=1.155770</code></pre>
<h3 id="使用-verilog-預設的浮點數運算"><a href="#使用-verilog-預設的浮點數運算">使用 Verilog 預設的浮點數運算</a></h3>
<p>檔案： float.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> main;
<span class="dt">real</span> x, y, x2, y2, xyadd, xysub, xymul, xydiv;
<span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>] x1, y1;

<span class="kw">initial</span> 
<span class="kw">begin</span>
  x=<span class="fl">3.14159</span>;
  y=-<span class="fl">2.3e4</span>;
  x1 = <span class="dt">$realtobits</span>(x);
  x2 = <span class="dt">$bitstoreal</span>(x1);
  y1 = <span class="dt">$realtobits</span>(y);
  y2 = <span class="dt">$bitstoreal</span>(y1);
  xyadd = x+y;
  xysub = x-y;
  xymul = x*y;
  xydiv = x/y;
  <span class="dt">$display</span>(<span class="st">&quot;x=%f x1=%b x2=%f&quot;</span>, x, x1, x2);
  <span class="dt">$display</span>(<span class="st">&quot;y=%f y1=%b y2=%f&quot;</span>, y, y1, y2);
  <span class="dt">$display</span>(<span class="st">&quot;x+y=%f xyadd=%f&quot;</span>, x+y, xyadd);
  <span class="dt">$display</span>(<span class="st">&quot;x-y=%f xysub=%f&quot;</span>, x-y, xysub);
  <span class="dt">$display</span>(<span class="st">&quot;x*y=%f xymul=%f&quot;</span>, x*y, xymul);
  <span class="dt">$display</span>(<span class="st">&quot;x/y=%f xydiv=%f&quot;</span>, x/y, xydiv);
<span class="kw">end</span>

<span class="kw">endmodule</span></code></pre>
<p>執行結果：</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o float float.v

D:\Dropbox\Public\web\oc\code&gt;vvp float
x=3.141590 x1=0100000000001001001000011111100111110000000110111000011001101110 x
2=3.141590
y=-23000.000000 y1=1100000011010110011101100000000000000000000000000000000000000
000 y2=-23000.000000
x+y=-22996.858410 xyadd=-22996.858410
x-y=23003.141590 xysub=23003.141590
x*y=-72256.570000 xymul=-72256.570000
x/y=-0.000137 xydiv=-0.000137</code></pre>
<h3 id="自行設計浮點運算器"><a href="#自行設計浮點運算器">自行設計浮點運算器</a></h3>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// https://instruct1.cit.cornell.edu/courses/ece576/StudentWork/ss868/fp/Reg27FP/FpMul.v</span>
<span class="co">// https://instruct1.cit.cornell.edu/courses/ece576/StudentWork/ss868/fp/Reg27FP/FpAdd.v</span>
<span class="co">// https://instruct1.cit.cornell.edu/courses/ece576/FloatingPoint/index.html#Schneider_fp</span>

<span class="ot">`define F_SIGN               63</span>
<span class="ot">`define F_EXP                62:52</span>
<span class="ot">`define F_FRAC               51:0</span>

<span class="co">// a = (-1)^a.s (1+a.f) * 2 ^ {a.e-1023} </span>
<span class="co">// b = (-1)^b.s (1+b.f) * 2 ^ {b.e-1023} </span>
<span class="co">// a*b = (-1)^(a.s xor b.s) (1+a.f) (1+b.f) * 2^{ (a.e+b.e-1023) - 1023}</span>
<span class="co">//       z.s = a.s xor b.s  z.f = tail(...)   z.e = a.e+b.e-1023</span>
<span class="kw">module</span> fmul(<span class="dt">input</span> [<span class="dv">63</span>:<span class="dv">0</span>] a, <span class="dt">input</span> [<span class="dv">63</span>:<span class="dv">0</span>] b, <span class="dt">output</span> [<span class="dv">63</span>:<span class="dv">0</span>] z);
    <span class="dt">wire</span>        a_s = a[<span class="ot">`F_SIGN</span>];
    <span class="dt">wire</span> [<span class="dv">10</span>:<span class="dv">0</span>] a_e = a[<span class="ot">`F_EXP</span>];
    <span class="dt">wire</span> [<span class="dv">51</span>:<span class="dv">0</span>] a_f = a[<span class="ot">`F_FRAC</span>];
    <span class="dt">wire</span>        b_s = b[<span class="ot">`F_SIGN</span>];
    <span class="dt">wire</span> [<span class="dv">10</span>:<span class="dv">0</span>] b_e = b[<span class="ot">`F_EXP</span>];
    <span class="dt">wire</span> [<span class="dv">51</span>:<span class="dv">0</span>] b_f = b[<span class="ot">`F_FRAC</span>];

    <span class="dt">wire</span>   z_s = a_s ^ b_s;<span class="co">// 正負號 z.s = a.s xor b.s</span>
    <span class="dt">wire</span> [<span class="dv">105</span>:<span class="dv">0</span>] f = {<span class="bn">1&#39;b1</span>, a_f} * {<span class="bn">1&#39;b1</span>, b_f}; <span class="co">// 小數部分： f = {1, a.f} * {1, b.f}</span>
    <span class="dt">wire</span> [<span class="dv">11</span>:<span class="dv">0</span>]  e = a_e + b_e - <span class="bn">12&#39;d1023</span>; <span class="co">// 指數部份： e = a.e + b.e - 1023</span>
    <span class="dt">wire</span> [<span class="dv">51</span>:<span class="dv">0</span>]  z_f = f[<span class="dv">105</span>] ? f[<span class="dv">104</span>:<span class="dv">53</span>] : f[<span class="dv">103</span>:<span class="dv">52</span>]; <span class="co">// 若最高位 f[105] == 1，則取 z.f[104:53]，否則取 z.f[103:52]</span>
    <span class="dt">wire</span> [<span class="dv">10</span>:<span class="dv">0</span>]  z_e = f[<span class="dv">105</span>] ? e[<span class="dv">10</span>:<span class="dv">0</span>]+<span class="dv">1</span> : e[<span class="dv">10</span>:<span class="dv">0</span>]; <span class="co">// 若最高位 f[105] == 1，則取 z.e 要上升 1 (???)，否則不變 </span>
    <span class="dt">wire</span> underflow = a_e[<span class="dv">10</span>] &amp; b_e[<span class="dv">10</span>] &amp; ~z_e[<span class="dv">10</span>];  <span class="co">// underflow</span>
    <span class="kw">assign</span> z = underflow ? <span class="bn">64&#39;b0</span> : {z_s, z_e, z_f}; <span class="co">// 若 underflow，則傳回零，否則傳回 z={z.s, z.e, z.f}。</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main;
<span class="dt">real</span> x, y, z;
<span class="dt">reg</span> [<span class="dv">63</span>:<span class="dv">0</span>] x1, y1;
<span class="dt">wire</span> [<span class="dv">63</span>:<span class="dv">0</span>] z1;

fmul f1(x1, y1, z1);

<span class="kw">initial</span> 
<span class="kw">begin</span>
<span class="co">//  x=7.00;  y=-9.00;</span>
<span class="co">//  x=6.00;  y=8.00;</span>
<span class="co">//  x=301.00;  y=200.00;</span>
  x=<span class="fl">1.75</span>;  y=<span class="fl">1.75</span>;
  x1 = <span class="dt">$realtobits</span>(x);
  y1 = <span class="dt">$realtobits</span>(y);
  <span class="bn">#100</span>;
  <span class="dt">$display</span>(<span class="st">&quot;a.s=%b a.e=%b a.f=%b&quot;</span>, f1.a_s, f1.a_e, f1.a_f);
  <span class="dt">$display</span>(<span class="st">&quot;a.s=%b b.e=%b b.f=%b&quot;</span>, f1.b_s, f1.b_e, f1.b_f);
  <span class="dt">$display</span>(<span class="st">&quot;e=%b </span><span class="ch">\n</span><span class="st">f=%b </span><span class="ch">\n</span><span class="st">underflow=%b&quot;</span>, f1.e, f1.f, f1.underflow);
  <span class="dt">$display</span>(<span class="st">&quot;z.s=%b z.e=%b z.f=%b&quot;</span>, f1.z_s, f1.z_e, f1.z_f);

  z = <span class="dt">$bitstoreal</span>(z1);
  <span class="dt">$display</span>(<span class="st">&quot;x=%f y=%f z=%f&quot;</span>, x, y, z);
  <span class="dt">$display</span>(<span class="st">&quot;x1=%b </span><span class="ch">\n</span><span class="st">y1=%b </span><span class="ch">\n</span><span class="st">z1=%b&quot;</span>, x1, y1, z1);
<span class="kw">end</span>

<span class="kw">endmodule</span></code></pre>
<p>執行結果</p>
<pre><code>D:\Dropbox\Public\web\oc\code&gt;iverilog -o fpu64 fpu64.v

D:\Dropbox\Public\web\oc\code&gt;vvp fpu64
a.s=0 a.e=01111111111 a.f=1100000000000000000000000000000000000000000000000000
a.s=0 b.e=01111111111 b.f=1100000000000000000000000000000000000000000000000000
e=001111111111
f=110001000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000
underflow=0
z.s=0 z.e=10000000000 z.f=1000100000000000000000000000000000000000000000000000
x=1.750000 y=1.750000 z=3.062500
x1=0011111111111100000000000000000000000000000000000000000000000000
y1=0011111111111100000000000000000000000000000000000000000000000000
z1=0100000000001000100000000000000000000000000000000000000000000000</code></pre>
<h3 id="參考文獻-6"><a href="#參考文獻-6">參考文獻</a></h3>
<ul>
<li>http://en.wikipedia.org/wiki/Single-precision_floating-point_format</li>
<li>http://en.wikipedia.org/wiki/Double-precision_floating-point_format</li>
</ul>
<h2 id="繪圖加速功能-graphics"><a href="#繪圖加速功能-graphics">繪圖加速功能 (Graphics)</a></h2>
<p>在 3D 的遊戲或動畫的運算當中，經常要計算向量的加法、內積的浮點數運算，而且這些運算通常獨立性很高，可以採用平行的方式計算，所以就需要在繪圖處理器 GPU 當中內建很多平行的向量式浮點運算器來加速此一計算過程。</p>
<p>舉例而言，當我們想計算下列的 N 維向量加法時，如果採用 GPU 就會快上很多：</p>
<pre class="sourceCode CPP"><code class="sourceCode cpp"><span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;N; i++)
  C[i] = A[i]+B[i];</code></pre>
<p>當這樣的程式被放到 GPU 去執行時，可能會翻譯出如下的組合語言。</p>
<pre><code>        LD          R1, N
        LD          R2, A
        LD          R3, B
        LD          R4, C
LOOP:   VectorLoad  V2, [R2]
        VectorLoad  V3, [R3]
        VectorAdd   V4, V2, V3
        VectorStore V4, [R4]
        ADD         R2, R2, 4*L
        ADD         R3, R3, 4*L
        ADDd        R4, R4, 4*L
        SUB         R5, R5, L
        CMP         R5, R0
        JGE         LOOP</code></pre>
<p>如果上述 GPU 的一次可以計算的浮點長度為 L 個，那麼整個計算幾乎就可以快上 L 倍了。</p>
<p>GPU 通常有著與 CPU 不同的指令集，像是 GPU 大廠 NVIDIA 的 CUDA 就是一種 GPU 指令集， NVIDIA 甚至還為 CUDA 設計了一種擴充式的 C 語言 -- 稱為 CUDA C，這種 C 語言可以用標記指定哪些部份應該展開到 CPU 當中，哪些應該展開到 GPU 當中，以及如何有效的運用 GPU 進行向量計算等等。甚至、 CUDA 還提供了專用的函式庫，以便讓 CUDA C 能夠方便的呼叫這些常用的繪圖函數。</p>
<p>另外、為了讓各家廠商的 CPU 與 GPU 可以更有效的合作，甚至有組織制定了一種稱為 OpenCL 的標準，可以讓各家廠商的 CPU 與 GPU 可以在一個標準架構下進行協同運算，以便有效的運用這些異質處理器的效能。</p>
<h2 id="平行處理-parallel"><a href="#平行處理-parallel">平行處理 (Parallel)</a></h2>
<p>由於散熱等因素無法克服，目前的處理器頻率已經不容易再快速往上調整，但是晶片的密度與容量還再持續增加，於是處理器內的平行，也就是多核心的情況就愈來愈普遍了。</p>
<p>目前雙核心、四核心、八核心甚至 16 核心的處理器已經很常見了，在可見的未來，或許成百上千核心的處理器也會被開發出來，因此如何運用平行技術充份利用這麼多核心將會是一個重要的課題。</p>
<p>另外、網路雲端運算的需求不斷增強，也會進一步增加多處理器技術的重要性，像是 Google 提出的 MapReduce 就在「大數據」的潮流下愈來愈形重要，而 MPI 與 Hadoop 等分散式平行處理技術也就在這種情況下逐漸普及了。</p>
<p>對於平行計算的架構，有一種相當好的分類方式，是根據「指令與資料是單數還複數」所進行的分類，這種分類法將平行架構分為「單指令多資料」(SIMD), 「多指令單資料」(MISD), 「多指令多資料」(MIMD) 等架構，在加上傳統非平行化的「單指令單資料」(SISD) 等形成一個 2*2 的矩陣。</p>
<p>舉例而言，像是上述的 GPU 向量架構，是屬於 SIMD 的平行架構，而下圖中的 UMA 與 NUMA 架構，則是屬於 MIMD 的平行架構。</p>
<div class="figure">
<img src="../img/UMAvsNUMA.jpg" />
</div>
<p>當然、在上述架構下，每個處理器理又有自己的 cache ，如何保持這些 cache 的一至性就會是個問題，而解決這些問題所依賴的方法仍然是與快取一至性中的所使用的「寫穿」 (write-through) 和「寫回」 (write-back) 等方法類似，只是規模要放大到整個網路上的快取而已。</p>
<h2 id="結語-10"><a href="#結語-10">結語</a></h2>
<p>目前在本書當中，我們對於「高階處理器」的實作還很缺乏，像是快取、MMU 與 pipeline 等部份的實作都還沒有完成，因此還無法完全實現「開放電腦計畫硬體部份」的目標。</p>
<p>不過在探索過程當中，筆者對硬體領域開始有了更深一層的瞭解，希望未來能夠將這些部份實作好之後，盡快加入到本書裏面。</p>
<p>到時、隨著本書進化成「第二版、第三版、....」，相信讀者與我對電腦硬體的理解也會變得愈來愈深入了。</p>
<h1 id="附錄"><a href="#附錄">附錄</a></h1>
<h2 id="本書內容與相關資源"><a href="#本書內容與相關資源">本書內容與相關資源</a></h2>
<table>
<thead>
<tr class="header">
<th align="left">主題</th>
<th align="left">投影片</th>
<th align="left">實作程式</th>
<th align="left">教學影片</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">第 1 章. <a href="opencomputer.html">開放電腦計畫</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/goi-VUwUnjI">http://youtu.be/goi-VUwUnjI</a></td>
</tr>
<tr class="even">
<td align="left">第 2 章. <a href="hardware.html">電腦硬體架構</a></td>
<td align="left"><a href="https://dl.dropboxusercontent.com/u/101584453/web/oc/slide/co01_Overview.pdf">co01_Overview.pdf</a></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/goi-VUwUnjI">http://youtu.be/goi-VUwUnjI</a></td>
</tr>
<tr class="odd">
<td align="left">─ 計算機結構：簡介 1</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/PX2jDLoVLmg">http://youtu.be/PX2jDLoVLmg</a></td>
</tr>
<tr class="even">
<td align="left">─ 計算機結構：簡介 2</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/_TUGe1GtJ6A">http://youtu.be/_TUGe1GtJ6A</a></td>
</tr>
<tr class="odd">
<td align="left">第 3 章. <a href="verilog.html">硬體描述語言 -- Verilog</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="verilog1.html">區塊式設計</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="verilog2.html">流程式設計</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ Icarus</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/wIKqxZ-9cI0">http://youtu.be/wIKqxZ-9cI0</a></td>
</tr>
<tr class="odd">
<td align="left">─ Verilog</td>
<td align="left"></td>
<td align="left"><a href="../code/xor3.v">xor3.v</a></td>
<td align="left"><a href="http://youtu.be/m_pM57K1G80">http://youtu.be/m_pM57K1G80</a></td>
</tr>
<tr class="even">
<td align="left">─ Quartus II</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/raf1IGnoFik">http://youtu.be/raf1IGnoFik</a></td>
</tr>
<tr class="odd">
<td align="left">─ DE2-70</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/TOz4gyuUOgA">http://youtu.be/TOz4gyuUOgA</a></td>
</tr>
<tr class="even">
<td align="left">第 4 章. <a href="combinatorial.html">組合邏輯</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ 多工器</td>
<td align="left"></td>
<td align="left"><a href="../code/mux.v">mux.v</a></td>
<td align="left"><a href="http://youtu.be/tMdq_WcMlMI">http://youtu.be/tMdq_WcMlMI</a></td>
</tr>
<tr class="even">
<td align="left">─ 全加器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><a href="http://youtu.be/UD3o5XQNKfQ">http://youtu.be/UD3o5XQNKfQ</a></td>
</tr>
<tr class="odd">
<td align="left">─ 4 位元加法器</td>
<td align="left"></td>
<td align="left">[adder4.v]</td>
<td align="left"><a href="http://youtu.be/t_0Q5Ddi4xE">http://youtu.be/t_0Q5Ddi4xE</a></td>
</tr>
<tr class="even">
<td align="left">─ 4 位元加減器</td>
<td align="left"></td>
<td align="left">[addsub4.v]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ 4 位元快速加法器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ N 位元加法器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ 乘法器</td>
<td align="left"></td>
<td align="left"><a href="../code/mult4.v">mult4.v</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 移位乘法器</td>
<td align="left"></td>
<td align="left"><a href="../code/shift_mult.v">shift_mult.v</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ 除法器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 浮點乘法器</td>
<td align="left"></td>
<td align="left">[fmult4.v]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">第 5 章. <a href="alu.html">算術邏輯單元</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 算術邏輯單元 ALU</td>
<td align="left"></td>
<td align="left">[alu.v]</td>
<td align="left"><a href="http://youtu.be/tMdq_WcMlMI">http://youtu.be/tMdq_WcMlMI</a></td>
</tr>
<tr class="odd">
<td align="left">第 6 章. <a href="memory.html">記憶單元</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 正反器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ 栓鎖器</td>
<td align="left"></td>
<td align="left"><a href="../code/latch.v">latch.v</a></td>
<td align="left"><a href="http://youtu.be/2EsDL8aGHgI">http://youtu.be/2EsDL8aGHgI</a></td>
</tr>
<tr class="even">
<td align="left">─ 計數器</td>
<td align="left"></td>
<td align="left"><a href="../code/counter.v">counter.v</a></td>
<td align="left"><a href="http://youtu.be/BlWFOpPSL1A">http://youtu.be/BlWFOpPSL1A</a></td>
</tr>
<tr class="odd">
<td align="left">─ 狀態機</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 多工器</td>
<td align="left"></td>
<td align="left"><a href="../code/mux.v">mux.v</a></td>
<td align="left"><a href="http://youtu.be/KcbUO_VRQ0U">http://youtu.be/KcbUO_VRQ0U</a></td>
</tr>
<tr class="odd">
<td align="left">─ 暫存器</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 暫存器群</td>
<td align="left"></td>
<td align="left"><a href="../code/regbank.v">regbank.v</a></td>
<td align="left"><a href="http://youtu.be/6zLPnv-PUBA">http://youtu.be/6zLPnv-PUBA</a></td>
</tr>
<tr class="odd">
<td align="left">─ 8 位元記憶體</td>
<td align="left"></td>
<td align="left"><a href="../code/memory8.v">memory8.v</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ 32位元記憶體</td>
<td align="left"></td>
<td align="left"><a href="../code/memory32.v">memory32.v</a></td>
<td align="left"><a href="http://youtu.be/dGmY6YhTbNw">http://youtu.be/dGmY6YhTbNw</a></td>
</tr>
<tr class="odd">
<td align="left">第 7 章. <a href="control.html">控制單元</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">第 8 章. <a href="mcu.html">微處理器</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="mcu0.html">MCU0 指令集</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="mcu0m.html">MCU0 迷你版</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="mcu0bm.html">MCU0 迷你版 (區塊設計)</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="mcu0s.html">MCU0 完整版</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">第 9 章. <a href="io.html">中斷與輸出入</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="mcu0i.html">MCU0 中斷處理</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="mcu0io.html">MCU0 的輸出入</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">第 10 章. <a href="storage.html">記憶系統</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="hierarchy.html">記憶體階層</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ <a href="cache.html">快取記憶體</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">第 11 章. <a href="cpu.html">高階處理器</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ <a href="harvard.html">哈佛架構</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ <a href="pipeline.html">流水線</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="mcu0.html">CPU0 指令集</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">- <a href="cpu0m.html">CPU0 迷你版</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">- <a href="cpu0s.html">CPU0 完整版</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">第 12 章. <a href="speed.html">速度議題</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ <a href="mult.html">乘法與除法</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ <a href="fpu.html">浮點運算單元 FPU</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ <a href="graphics.html">繪圖加速功能</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">─ <a href="parallel.html">平行處理</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">─ <a href="end.html">結語</a></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<!--
| - [MCU0 迷你版 (獨立記憶體+直接存取)](mcu0mb0.1.html) |                |                |                                           |
| - [MCU0 迷你版 (獨立記憶體+匯流排)](mcu0mb.html) |                |                |                                           |
-->
</div>
<div id="footer">
<a href="http://ccckmit.wikidot.com">陳鍾誠</a>衍生自<a href="http://zh.wikipedia.org/">維基百科</a>之作品：採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> <a href="license.html">授權</a>
</div>
</body>
</html>
